AALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def AALOAD	= '\x32'; \/\/ 50$/;"	d
AASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def AASTORE	= '\x53'; \/\/ 83$/;"	d
ABS32	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^def ABS32 = '\x99';$/;"	d
ABS_CONST	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_CONST  = 0x44332211;$/;"	d
ABS_CONST0	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_CONST0 = 0x11;$/;"	d
ABS_CONST1	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_CONST1 = 0x22;$/;"	d
ABS_CONST2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_CONST2 = 0x33;$/;"	d
ABS_CONST3	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_CONST3 = 0x44;$/;"	d
ABS_MARKER	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ABS_MARKER = 0x11223344;$/;"	d
ABS_MARKER	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def ABS_MARKER = 0x11223344;$/;"	d
ABS_MARKER	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^def ABS_MARKER = 0x44332299;$/;"	d
ABS_PATCH	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_PATCH = X86Addr.new(null, null, 1, 0x44332211);$/;"	d
ABS_PATCH_SSE	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def ABS_PATCH_SSE = ABS_PATCH.toSSEAddr();$/;"	d
ACC_ABSTRACT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_ABSTRACT	= 0x0400;$/;"	d
ACC_FINAL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_FINAL		= 0x0010;$/;"	d
ACC_INTERFACE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_INTERFACE	= 0x0200;$/;"	d
ACC_NATIVE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_NATIVE		= 0x0100;$/;"	d
ACC_PRIVATE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_PRIVATE 	= 0x0002;$/;"	d
ACC_PROTECTED	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_PROTECTED 	= 0x0004;$/;"	d
ACC_PUBLIC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_PUBLIC 		= 0x0001;$/;"	d
ACC_STATIC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_STATIC		= 0x0008;$/;"	d
ACC_STRICT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_STRICT		= 0x0800;$/;"	d
ACC_SUPER	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_SUPER		= 0x0020;$/;"	d
ACC_SYNCHRONIZED	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_SYNCHRONIZED	= 0x0020;$/;"	d
ACC_TRANSIENT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_TRANSIENT	= 0x0080;$/;"	d
ACC_VOLATILE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACC_VOLATILE	= 0x0040;$/;"	d
ACONST_NULL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ACONST_NULL	= '\x01'; \/\/ 1$/;"	d
ADDR_MODE_MASK	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ADDR_MODE_MASK: u8 = 0x3f;$/;"	d
ADDR_MODE_SHIFT	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ADDR_MODE_SHIFT: u5 = 8;$/;"	d
ALL	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def ALL = '\x0f';$/;"	d
ALL	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def ALL = set("{all}", Arrays.concat(allocatableGprs, sfrs));$/;"	d
ALL	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def ALL = set("{all}", Arrays.concat(GPR_ARRAY, XMM_ARRAY));$/;"	d
ALL	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def ALL = '\x17';$/;"	d
ALL_ARRAY	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def ALL_ARRAY = Array<Array<byte>>.new(ALL_COUNT);$/;"	d
ALL_COUNT	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def ALL_COUNT = 41;$/;"	d
ALL_NAMES	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def ALL_NAMES = Array<Array<byte>>.new(ALL_COUNT);$/;"	d
ALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ALOAD	= '\x19'; \/\/ 25$/;"	d
ALOAD_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ALOAD_0	= '\x2a'; \/\/ 42$/;"	d
ALOAD_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ALOAD_1	= '\x2b'; \/\/ 43$/;"	d
ALOAD_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ALOAD_2	= '\x2c'; \/\/ 44$/;"	d
ALOAD_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ALOAD_3	= '\x2d'; \/\/ 45$/;"	d
ALWAYS	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ALWAYS: X86_64Cond;$/;"	d
ALWAYS	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ALWAYS: X86Cond;$/;"	d
AM_MRRSD_IMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_MRRSD_IMM = 0x03;$/;"	d
AM_MRRSD_REG	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_MRRSD_REG = 0x02;$/;"	d
AM_MRRSD_XMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_MRRSD_XMM = 0x0C;$/;"	d
AM_NONE	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_NONE	 = 0x00;$/;"	d
AM_OP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_OP	 = 0x05;$/;"	d
AM_OP_IMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_OP_IMM	 = 0x06;$/;"	d
AM_OP_REG	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_OP_REG	 = 0x07;$/;"	d
AM_OP_XMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_OP_XMM	 = 0x0A;$/;"	d
AM_REG_MRRSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_REG_MRRSD = 0x04;$/;"	d
AM_REG_OP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_REG_OP	 = 0x01;$/;"	d
AM_REG_XOP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_REG_XOP	 = 0x0E;$/;"	d
AM_SHIFT	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_SHIFT = u5.view(8);$/;"	d
AM_XMM_IMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_XMM_IMM	 = 0x0D;$/;"	d
AM_XMM_MRRSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_XMM_MRRSD = 0x0B;$/;"	d
AM_XMM_OP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_XMM_OP	 = 0x09;$/;"	d
AM_XMM_REG	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_XMM_REG	 = 0x08;$/;"	d
AM_XMM_XMM	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def AM_XMM_XMM	 = 0x0F;$/;"	d
ANDAND	$VIRGIL/aeneas/src/types/Bool.v3	/^	def ANDAND = V3Op.newVstSugar(VstOperator.BoolAndAnd, TypeUtil.NO_TYPES, ARRAY_TT, TYPE);$/;"	d
ANEWARRAY	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ANEWARRAY		= '\xbd'; \/\/ 189$/;"	d
ANY_V4	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def ANY_V4 = InetAddress.Ipv4(0, 0, 0, 0);$/;"	d
ANY_V6	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def ANY_V6 = InetAddress.Ipv6(0, 0, 0, 0);$/;"	d
ARCH_ALLOCSHADOWSTACK	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_ALLOCSHADOWSTACK = -12;$/;"	d
ARCH_BLOCK	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_BLOCK	 = -5;$/;"	d
ARCH_BLOCK_END	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_BLOCK_END = -7;$/;"	d
ARCH_DELETEVAR	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_DELETEVAR = -16;$/;"	d
ARCH_END	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_END	 = -2;$/;"	d
ARCH_ENTRY	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_ENTRY	 = -4;$/;"	d
ARCH_GETSHADOWSTACKPTR	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_GETSHADOWSTACKPTR = -13;$/;"	d
ARCH_NEWVAR	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_NEWVAR = -15;$/;"	d
ARCH_NOP	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_NOP	 = -6;$/;"	d
ARCH_PARMOVE	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_PARMOVE = -3;$/;"	d
ARCH_RELOAD	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_RELOAD = -8;$/;"	d
ARCH_RESTORE	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_RESTORE = -9;$/;"	d
ARCH_RET	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_RET	 = -1;$/;"	d
ARCH_SAVE	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_SAVE = -10;$/;"	d
ARCH_SETSHADOWSTACKPTR	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_SETSHADOWSTACKPTR = -11;$/;"	d
ARCH_SOURCELINE	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_SOURCELINE = -14;$/;"	d
ARCH_UPDATEVAR	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ARCH_UPDATEVAR = -17;$/;"	d
ARETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ARETURN		= '\xb0'; \/\/ 176$/;"	d
ARMA_2IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2IMM        = 0x0b;$/;"	d
ARMA_2REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2REG        = 0x0c;$/;"	d
ARMA_2ROR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2ROR_IMM    = 0x10;$/;"	d
ARMA_2ROR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2ROR_REG    = 0x14;$/;"	d
ARMA_2SAR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SAR_IMM    = 0x0f;$/;"	d
ARMA_2SAR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SAR_REG    = 0x13;$/;"	d
ARMA_2SHL_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SHL_IMM    = 0x0d;$/;"	d
ARMA_2SHL_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SHL_REG    = 0x11;$/;"	d
ARMA_2SHR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SHR_IMM    = 0x0e;$/;"	d
ARMA_2SHR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_2SHR_REG    = 0x12;$/;"	d
ARMA_3IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3IMM        = 0x01;$/;"	d
ARMA_3REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3REG        = 0x02;$/;"	d
ARMA_3ROR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3ROR_IMM    = 0x06;$/;"	d
ARMA_3ROR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3ROR_REG    = 0x0a;$/;"	d
ARMA_3SAR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SAR_IMM    = 0x05;$/;"	d
ARMA_3SAR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SAR_REG    = 0x09;$/;"	d
ARMA_3SHL_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SHL_IMM    = 0x03;$/;"	d
ARMA_3SHL_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SHL_REG    = 0x07;$/;"	d
ARMA_3SHR_IMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SHR_IMM    = 0x04;$/;"	d
ARMA_3SHR_REG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_3SHR_REG    = 0x08;$/;"	d
ARMA_NONE	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_NONE        = 0x00;$/;"	d
ARMA_OFFL_ADDIMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFL_ADDIMM = 0x15;$/;"	d
ARMA_OFFL_ADDREG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFL_ADDREG = 0x17;$/;"	d
ARMA_OFFL_SUBIMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFL_SUBIMM = 0x16;$/;"	d
ARMA_OFFL_SUBREG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFL_SUBREG = 0x18;$/;"	d
ARMA_OFFS_ADDIMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFS_ADDIMM = 0x19;$/;"	d
ARMA_OFFS_ADDREG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFS_ADDREG = 0x20;$/;"	d
ARMA_OFFS_SUBIMM	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFS_SUBIMM = 0x1a;$/;"	d
ARMA_OFFS_SUBREG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARMA_OFFS_SUBREG = 0x21;$/;"	d
ARM_ADD	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_ADD    = 0x06;$/;"	d
ARM_AND	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_AND    = 0x09;$/;"	d
ARM_APPLY	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_APPLY  = 0x04;$/;"	d
ARM_B	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_B      = 0x15;$/;"	d
ARM_BL	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_BL     = 0x16;$/;"	d
ARM_CMP	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_CMP    = 0x0c;$/;"	d
ARM_EOR	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_EOR    = 0x0b;$/;"	d
ARM_IBL	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_IBL    = 0x17;$/;"	d
ARM_LDRBSX	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_LDRBSX = 0x0e;$/;"	d
ARM_LDRBZX	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_LDRBZX = 0x0d;$/;"	d
ARM_LDRHSX	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_LDRHSX = 0x10;$/;"	d
ARM_LDRHZX	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_LDRHZX = 0x0f;$/;"	d
ARM_LDRW	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_LDRW   = 0x11;$/;"	d
ARM_MOV	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_MOV    = 0x02;$/;"	d
ARM_MUL	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_MUL    = 0x08;$/;"	d
ARM_ORR	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_ORR    = 0x0a;$/;"	d
ARM_SDIV	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_SDIV   = 0x18;$/;"	d
ARM_STRB	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_STRB   = 0x12;$/;"	d
ARM_STRH	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_STRH   = 0x13;$/;"	d
ARM_STRW	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_STRW   = 0x14;$/;"	d
ARM_SUB	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_SUB    = 0x07;$/;"	d
ARM_SWITCH	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_SWITCH = 0x05;$/;"	d
ARM_THROW	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_THROW  = 0x03;$/;"	d
ARM_UDIV	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def ARM_UDIV   = 0x19;$/;"	d
ARRAYLENGTH	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ARRAYLENGTH		= '\xbe'; \/\/ 190$/;"	d
ARRAY_LENGTH_FIELD	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^def ARRAY_LENGTH_FIELD = newField(V3.stringType, Int.TYPE, Fact.F_VALUE);$/;"	d
ARRAY_T	$VIRGIL/aeneas/src/types/Bool.v3	/^	def ARRAY_T: Array<Type> = [TYPE];$/;"	d
ARRAY_T	$VIRGIL/aeneas/src/types/Int.v3	/^	def ARRAY_T: Array<Type> = [TYPE];$/;"	d
ARRAY_TT	$VIRGIL/aeneas/src/types/Bool.v3	/^	def ARRAY_TT: Array<Type> = [TYPE, TYPE];$/;"	d
ASSIGNED_MASK	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def ASSIGNED_MASK = 0x4;$/;"	d
ASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ASTORE	= '\x3a'; \/\/ 58$/;"	d
ASTORE_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ASTORE_0	= '\x4b'; \/\/ 75$/;"	d
ASTORE_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ASTORE_1	= '\x4c'; \/\/ 76$/;"	d
ASTORE_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ASTORE_2	= '\x4d'; \/\/ 77$/;"	d
ASTORE_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ASTORE_3	= '\x4e'; \/\/ 78$/;"	d
ATHROW	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ATHROW		= '\xbf'; \/\/ 191$/;"	d
Abbrev_code	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^var Abbrev_code: u32 = 5; \/\/ next unique code for abbrev tag$/;"	d
AddImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddImm(off: u8);$/;"	d
AddReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddReg(rm: ArmReg);$/;"	d
Addr	$VIRGIL/aeneas/src/mach/Memory.v3	/^class Addr(region: Region, base: Addr, offset: int) extends Val {$/;"	c
Address	$VIRGIL/aeneas/src/mach/Memory.v3	/^class Address<T> extends Addr {$/;"	c
AddressSpace	$VIRGIL/aeneas/src/mach/Memory.v3	/^class AddressSpace {$/;"	c
Aeneas	$VIRGIL/aeneas/src/main/Aeneas.v3	/^component Aeneas {$/;"	n
Alignment	$VIRGIL/aeneas/src/util/Alignment.v3	/^class Alignment(size: int) {$/;"	c
All	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case All;$/;"	d
Alloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case Alloc;$/;"	d
Animator	$VIRGIL/lib/term/Animator.v3	/^class Animator(animate: u32 -> void, keypress: int -> void) {$/;"	c
AnyFuncType	$VIRGIL/aeneas/src/types/Void.v3	/^class AnyFuncType extends Type {$/;"	c
AnyFunction	$VIRGIL/aeneas/src/types/Void.v3	/^component AnyFunction {$/;"	n
AnyRef	$VIRGIL/aeneas/src/types/Void.v3	/^component AnyRef {$/;"	n
AnyRefOverflow	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var AnyRefOverflow: bool;$/;"	d
AnyRefType	$VIRGIL/aeneas/src/types/Void.v3	/^class AnyRefType extends Type {$/;"	c
App	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case App(p: VarExpr, args: VstList<VstPackingExpr>);$/;"	d
AppBinding	$VIRGIL/aeneas/src/vst/Vst.v3	/^type AppBinding {$/;"	c
AppBinding.Apply	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Apply(op: Operator, facts: Fact.set);$/;"	c
AppBinding.CallClassMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallClassMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	c
AppBinding.CallClosure	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallClosure(t: Type);		\/\/ func(args)$/;"	c
AppBinding.CallComponentMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallComponentMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	c
AppBinding.CallObjectMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallObjectMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	c
AppBinding.ClassNew	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassNew(receiver: Type, member: VstNew);$/;"	c
AppBinding.None	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case None;$/;"	c
AppBinding.Partial	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Partial(indexMap: Array<int>);	\/\/ func(args, _, args)$/;"	c
AppBinding.PtrAtComponentField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtComponentField(receiver: Type, field: VstField, ptrType: Type);$/;"	c
AppBinding.PtrAtObjectField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtObjectField(receiver: Type, field: VstField, ptrType: Type);$/;"	c
AppBinding.PtrAtRefLayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtRefLayoutField(receiver: Type, field: VstLayoutField, ptrType: Type);$/;"	c
AppBinding.Void	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Void;$/;"	c
AppExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class AppExpr(func: Expr, var args: TupleExpr) extends Expr {$/;"	c
Apply	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Apply(dst: int, op: Operator, args: Array<int>, src: Source);$/;"	d
Apply	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Apply(op: Operator, facts: Fact.set);$/;"	d
ArchInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class ArchInstr(op: int, operands: Array<Operand>) {$/;"	c
ArchInstrBuffer	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class ArchInstrBuffer(codegen: SsaMachGen, prog: Program, regSet: MachRegSet) extends TerminalBuffer {$/;"	c
ArchInstrs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^component ArchInstrs {$/;"	n
Arguments	$VIRGIL/aeneas/src/core/Eval.v3	/^class Arguments {$/;"	c
ArityMismatch	$VIRGIL/aeneas/src/main/Error.v3	/^	def ArityMismatch(op: string, expect: int, found: int) {$/;"	m
Arm64Assembler	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^class Arm64Assembler(w: DataWriter) {$/;"	c
Arm64Backend	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^class Arm64Backend extends MachBackend {$/;"	c
Arm64Cond	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^class Arm64Cond(name: string, index: int) {$/;"	c
Arm64Conds	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^component Arm64Conds {$/;"	n
Arm64Gpr	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^class Arm64Gpr extends Arm64Reg {$/;"	c
Arm64MacroAssembler	$VIRGIL/aeneas/src/arm64/Arm64MacroAssembler.v3	/^class Arm64MacroAssembler extends Arm64Assembler {$/;"	c
Arm64Reg	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^class Arm64Reg(regnum: u5) {}$/;"	c
Arm64RegSet	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^component Arm64RegSet {$/;"	n
Arm64Regs	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^component Arm64Regs {$/;"	n
Arm64Sfr	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^class Arm64Sfr extends Arm64Reg {$/;"	c
Arm64Target	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^class Arm64Target extends Target {$/;"	c
Arm64Targets	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^component Arm64Targets {$/;"	n
Arm64VirgilCallConv	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^component Arm64VirgilCallConv {$/;"	n
ArmAllocator	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^class ArmAllocator {$/;"	c
ArmAssembler	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^class ArmAssembler(w: DataWriter) {$/;"	c
ArmBackend	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^class ArmBackend extends MachBackend {$/;"	c
ArmCodeGen	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^class ArmCodeGen extends SsaMachGen {$/;"	c
ArmCond	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmCond {$/;"	c
ArmCond.AL	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AL;    \/\/ Always (unconditional)$/;"	c
ArmCond.CC	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case CC;    \/\/ Carry clear\/unsigned lower$/;"	c
ArmCond.CS	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case CS;    \/\/ Carry set\/unsigned higher or same$/;"	c
ArmCond.EQ	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case EQ;    \/\/ Equal$/;"	c
ArmCond.GE	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case GE;    \/\/ Signed greater than or equal$/;"	c
ArmCond.GT	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case GT;    \/\/ Signed greater than$/;"	c
ArmCond.HI	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case HI;    \/\/ Unsigned higher$/;"	c
ArmCond.LE	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case LE;    \/\/ Signed less than or equal$/;"	c
ArmCond.LS	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case LS;    \/\/ Unsigned lower or same$/;"	c
ArmCond.LT	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case LT;    \/\/ Signed less than$/;"	c
ArmCond.MI	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case MI;    \/\/ Minus\/negative$/;"	c
ArmCond.NE	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case NE;    \/\/ Not equal$/;"	c
ArmCond.PL	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case PL;    \/\/ Plus\/positive or zero$/;"	c
ArmCond.VC	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case VC;    \/\/ No overflow$/;"	c
ArmCond.VS	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case VS;    \/\/ Overflow$/;"	c
ArmInstrBuffer	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^class ArmInstrBuffer extends ArchInstrBuffer {$/;"	c
ArmLinuxBackend	$VIRGIL/aeneas/src/arm/ArmLinux.v3	/^class ArmLinuxBackend extends ArmBackend {$/;"	c
ArmMachRegs	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^component ArmMachRegs {$/;"	n
ArmMacroAssembler	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^class ArmMacroAssembler extends ArmAssembler {$/;"	c
ArmOffset	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmOffset {$/;"	c
ArmOffset.AddImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddImm(off: u12);$/;"	c
ArmOffset.AddReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddReg(rm: ArmReg);$/;"	c
ArmOffset.SubImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubImm(off: u12);$/;"	c
ArmOffset.SubReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubReg(rm: ArmReg);$/;"	c
ArmOperand	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmOperand {$/;"	c
ArmOperand.Imm8	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case Imm8(val: u8, rot: u4);$/;"	c
ArmOperand.Reg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case Reg(rm: ArmReg);$/;"	c
ArmOperand.RegRorImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegRorImm(rm: ArmReg, shift: u5);$/;"	c
ArmOperand.RegRorReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegRorReg(rm: ArmReg, rs: ArmReg);$/;"	c
ArmOperand.RegSarImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegSarImm(rm: ArmReg, shift: u5);$/;"	c
ArmOperand.RegSarReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegSarReg(rm: ArmReg, rs: ArmReg);$/;"	c
ArmOperand.RegShlImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShlImm(rm: ArmReg, shift: u5);$/;"	c
ArmOperand.RegShlReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShlReg(rm: ArmReg, rs: ArmReg);$/;"	c
ArmOperand.RegShrImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShrImm(rm: ArmReg, shift: u5);$/;"	c
ArmOperand.RegShrReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShrReg(rm: ArmReg, rs: ArmReg);$/;"	c
ArmReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmReg {$/;"	c
ArmReg.R0	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
ArmReg.R1	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
ArmReg.R10	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
ArmReg.R11	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
ArmReg.R12	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
ArmReg.R13	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
ArmReg.R14	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
ArmReg.R15	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
ArmReg.R2	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
ArmReg.R3	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
ArmReg.R4	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
ArmReg.R5	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
ArmReg.R6	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
ArmReg.R7	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
ArmReg.R8	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
ArmReg.R9	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
ArmRuntime	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^class ArmRuntime extends MachRuntime {$/;"	c
ArmSmallOffset	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmSmallOffset {$/;"	c
ArmSmallOffset.AddImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddImm(off: u8);$/;"	c
ArmSmallOffset.AddReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case AddReg(rm: ArmReg);$/;"	c
ArmSmallOffset.SubImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubImm(off: u8);$/;"	c
ArmSmallOffset.SubReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubReg(rm: ArmReg);$/;"	c
ArmVirgilCallConv	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^component ArmVirgilCallConv {$/;"	n
ArrayAlloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayAlloc;$/;"	d
ArrayExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ArrayExpr(exprs: VstList<Expr>) extends Expr {$/;"	c
ArrayGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetElem;$/;"	d
ArrayGetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetElemElem(index: int);$/;"	d
ArrayGetLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetLength;$/;"	d
ArrayIndexType	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var ArrayIndexType: IntType;$/;"	d
ArrayInit	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayInit(length: int);$/;"	d
ArrayLengthType	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var ArrayLengthType: IntType;$/;"	d
ArrayNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class ArrayNorm extends TypeNorm {$/;"	c
ArrayRangeStart	$VIRGIL/aeneas/src/v3/V3Range.v3	/^class ArrayRangeStart(start: int, arrayType: Type) extends Val {$/;"	c
ArrayRangeVal	$VIRGIL/aeneas/src/v3/V3Range.v3	/^class ArrayRangeVal(array: Record, start: int, length: int) extends Val {$/;"	c
ArraySetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArraySetElem;$/;"	d
ArraySetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArraySetElemElem(index: int);$/;"	d
ArrayStack	$VIRGIL/lib/util/Stack.v3	/^class ArrayStack<T> {$/;"	c
ArrayTupleInit	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayTupleInit(elems: int, length: int);$/;"	d
ArrayType	$VIRGIL/aeneas/src/v3/V3Array.v3	/^class ArrayType extends Type {$/;"	c
Arrays	$VIRGIL/lib/util/Arrays.v3	/^component Arrays {$/;"	n
AssignError	$VIRGIL/aeneas/src/main/Error.v3	/^	def AssignError() {$/;"	m
AssignExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class AssignExpr(target: Expr, infix: InfixOp, assign: FilePoint, expr: Expr) extends Expr {$/;"	c
Assigned	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Assigned(ch: u8);	\/\/ . 		is already assigned (a bit of {ch})$/;"	d
AutoExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class AutoExpr(token: Token, expr: Expr, infix: V3Infix, post: bool) extends Expr {$/;"	c
BALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def BALOAD	= '\x33'; \/\/ 51$/;"	d
BASH_HEADER	$VIRGIL/aeneas/src/main/Compiler.v3	/^def BASH_HEADER = [$/;"	d
BASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def BASTORE	= '\x54'; \/\/ 84$/;"	d
BCE	$VIRGIL/rt/x86-64-darwin/System.v3	/^	private def BCE = "BoundsCheckException";$/;"	d
BIPUSH	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def BIPUSH	= '\x10'; \/\/ 16$/;"	d
BIT20	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^def BIT20 = 1u << 20;$/;"	d
BIT22	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^def BIT22 = 1u << 22;$/;"	d
BIT23	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^def BIT23 = 1u << 23;$/;"	d
BIT25	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^def BIT25 = 1u << 25;$/;"	d
BLACK	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def BLACK   = '\x02';$/;"	d
BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def BOOLEAN = JvmPrimitive.new("boolean", "Z", "Z", KIND_BOOLEAN);$/;"	d
BOTTOM	$VIRGIL/aeneas/src/core/Value.v3	/^	var BOTTOM: Val = null;$/;"	d
BUILTIN_TOKEN	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def BUILTIN_TOKEN = Token.new("<builtin>", "T", 0, 0);$/;"	d
BYTE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def BYTE    = JvmPrimitive.new("byte", "B", "B", KIND_BYTE);$/;"	d
BYTE	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def BYTE = '\x11';$/;"	d
BYTE_ARRAY	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def BYTE_ARRAY: JvmArray_Type   = BYTE.arrayType();$/;"	d
BasicOptions	$VIRGIL/lib/util/Option.v3	/^class BasicOptions extends Options {$/;"	c
BinLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^class BinLiteral extends IntLiteral {$/;"	c
BinOpExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class BinOpExpr(left: Expr, op: InfixOp, right: Expr) extends Expr {$/;"	c
BitMatrix	$VIRGIL/lib/util/BitMatrix.v3	/^class BitMatrix(var numrows: int, var numcols: int) {$/;"	c
BitMatrixRow	$VIRGIL/lib/util/BitMatrix.v3	/^type BitMatrixRow(matrix: BitMatrix, index: int) #unboxed {$/;"	c
BitPatternTooLong	$VIRGIL/aeneas/src/main/Error.v3	/^	def BitPatternTooLong(max: byte, got: int) {$/;"	m
Bits	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Bits(token: Token, rep: Array<(int, PackingBit)>);$/;"	d
BitwiseNegExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class BitwiseNegExpr(neg: FilePoint, expr: Expr) extends Expr {$/;"	c
Block	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Block(t: Type, bi: SsaBlockInfo);$/;"	d
BlockStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class BlockStmt(stmts: VstList<Stmt>) extends Stmt {$/;"	c
Body	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Body(bi: SsaBlockInfo);$/;"	d
Bool	$VIRGIL/aeneas/src/types/Bool.v3	/^component Bool {$/;"	n
BoolAnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolAnd;$/;"	d
BoolAndAnd	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case BoolAndAnd;	\/\/ desugared to if(a, b, false)$/;"	d
BoolEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolEq;$/;"	d
BoolNot	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolNot;$/;"	d
BoolOr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolOr;$/;"	d
BoolOrOr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case BoolOrOr;		\/\/ desugared to if(a, true, b)$/;"	d
BoolType	$VIRGIL/aeneas/src/types/Bool.v3	/^class BoolType extends Type {$/;"	c
BoundOp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^type BoundOp {$/;"	c
BoundOp.Gt	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Gt;$/;"	c
BoundOp.Gteq	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Gteq;$/;"	c
BoundOp.Lt	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Lt;$/;"	c
BoundOp.Lteq	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Lteq;$/;"	c
BoundsCheck	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoundsCheck;$/;"	d
BoundsCheck	$VIRGIL/aeneas/src/v3/V3.v3	/^	def BoundsCheck   = "BoundsCheckException";$/;"	d
Box	$VIRGIL/aeneas/src/core/Value.v3	/^class Box<T>(val: T) extends Val {$/;"	c
Boxed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Boxed;$/;"	d
BrIf	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case BrIf(split: SsaBlock, val: SsaInstr, bi: SsaBlockInfo, depth: int);$/;"	d
BrTable	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case BrTable(split: SsaBlock, val: SsaInstr, depths: Array<int>);$/;"	d
Branch	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Branch(always: bool, bval: bool, arg: int, target: int);$/;"	d
BreakStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class BreakStmt(src: FileRange) extends Stmt {$/;"	c
Breakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^class Breakpoint {$/;"	c
Bucket	$VIRGIL/lib/util/Map.v3	/^private class Bucket<K, V> {$/;"	c
Buffer	$VIRGIL/lib/util/IO.v3	/^class Buffer {$/;"	c
Byte	$VIRGIL/aeneas/src/types/Byte.v3	/^component Byte {$/;"	n
ByteArrayGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ByteArrayGetField(offset: int);$/;"	d
ByteArrayOffset	$VIRGIL/aeneas/src/v3/Ref.v3	/^class ByteArrayOffset(array: Record, offset: int) extends Val {$/;"	c
ByteArraySetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ByteArraySetField(offset: int);$/;"	d
CACHED_INT_IMMEDIATES	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^def CACHED_INT_IMMEDIATES = [$/;"	d
CACHE_SIZE	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def CACHE_SIZE = 7;$/;"	d
CALLEE_SPILL_START	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def CALLEE_SPILL_START = 200000000;$/;"	d
CALLEE_SPILL_START	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def CALLEE_SPILL_START = 200000000;$/;"	d
CALLEE_SPILL_START	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def CALLEE_SPILL_START = 200000000;$/;"	d
CALLEE_SPILL_START	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def CALLEE_SPILL_START = 200000000;$/;"	d
CALLER_SPILL_START	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def CALLER_SPILL_START = 100000000;$/;"	d
CALLER_SPILL_START	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def CALLER_SPILL_START = 100000000;$/;"	d
CALLER_SPILL_START	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def CALLER_SPILL_START = 100000000;$/;"	d
CALLER_SPILL_START	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def CALLER_SPILL_START = 100000000;$/;"	d
CALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def CALOAD	= '\x34'; \/\/ 52$/;"	d
CANNOT_USE_AS_TEMP	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^def CANNOT_USE_AS_TEMP = -2;$/;"	d
CASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def CASTORE	= '\x55'; \/\/ 85$/;"	d
CBAUD	$VIRGIL/lib/term/Termios.v3	/^	def CBAUD      = 0x100F;     \/\/ CBAUD Serial speed settings$/;"	d
CBAUDEX	$VIRGIL/lib/term/Termios.v3	/^	def CBAUDEX    = 0x1000;     \/\/ CBAUDX Serial speed settings$/;"	d
CHAR	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def CHAR    = JvmPrimitive.new("char", "C", "C", KIND_CHAR);$/;"	d
CHECKCAST	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def CHECKCAST		= '\xc0'; \/\/ 192$/;"	d
CLOSURE	$VIRGIL/aeneas/src/types/Function.v3	/^	def CLOSURE = Function_TypeCon.new(Kind.CLOSURE);$/;"	d
CLOptions	$VIRGIL/aeneas/src/main/CLOptions.v3	/^component CLOptions {$/;"	n
COALESCE	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def COALESCE = false;$/;"	d
CODE	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def CODE: byte = 10;	 \/\/ Function code$/;"	d
CODE_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def CODE_END              = addr("CODE_END");$/;"	d
CODE_POINTER_SIZE32	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def CODE_POINTER_SIZE32: u8 = 4;$/;"	d
CODE_POINTER_SIZE64	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def CODE_POINTER_SIZE64: u8 = 8;$/;"	d
CODE_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def CODE_START            = addr("CODE_START");$/;"	d
CODE_START_ADDR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def CODE_START_ADDR	= rtOpt.newAddrOption("code-start-addr", 0,$/;"	d
COLOR	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^def COLOR = false;$/;"	d
COMMA	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def COMMA     = ',';$/;"	d
COND_MASK	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def COND_MASK: u8 = 0xF;$/;"	d
COND_SHIFT	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def COND_SHIFT: u5 = 12;$/;"	d
COND_SHIFT	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def COND_SHIFT = u5.view(13);$/;"	d
COVERAGE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def COVERAGE		= runOpt.newMatcherOption("coverage",$/;"	d
CPU_SUBTYPE_X86_64	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_SUBTYPE_X86_64  = 0x00000003; \/\/ 3$/;"	d
CPU_TYPE_ARM	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_TYPE_ARM	= 0x0000000C; \/\/ 12$/;"	d
CPU_TYPE_POWERPC	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_TYPE_POWERPC	= 0x00000012; \/\/ 18$/;"	d
CPU_TYPE_POWERPC_64	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_TYPE_POWERPC_64	= 0x01000012;$/;"	d
CPU_TYPE_X86	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_TYPE_X86	= 0x00000007; \/\/ 7$/;"	d
CPU_TYPE_X86_64	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def CPU_TYPE_X86_64	= 0x01000007;$/;"	d
CRC	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^component CRC {$/;"	n
CTRL_BLACK	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BLACK        = "\x1B[0;30m";$/;"	d
CTRL_BLUE	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BLUE         = "\x1B[0;34m";$/;"	d
CTRL_BRIGHT_BLUE	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BRIGHT_BLUE  = "\x1B[1;34m";$/;"	d
CTRL_BRIGHT_CYAN	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BRIGHT_CYAN  = "\x1B[1;36m";$/;"	d
CTRL_BRIGHT_GREEN	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BRIGHT_GREEN = "\x1B[1;32m";$/;"	d
CTRL_BRIGHT_RED	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BRIGHT_RED   = "\x1B[1;31m";$/;"	d
CTRL_BROWN	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_BROWN        = "\x1B[0;33m";$/;"	d
CTRL_CYAN	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_CYAN         = "\x1B[0;36m";$/;"	d
CTRL_DARKGRAY	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_DARKGRAY     = "\x1B[1;30m";$/;"	d
CTRL_DEFAULT	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_DEFAULT      = "\x1B[1;00m";$/;"	d
CTRL_GREEN	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_GREEN        = "\x1B[0;32m";$/;"	d
CTRL_LIGHTGRAY	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_LIGHTGRAY    = "\x1B[0;37m";$/;"	d
CTRL_MAGENTA	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_MAGENTA      = "\x1B[1;35m";$/;"	d
CTRL_PURPLE	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_PURPLE       = "\x1B[0;35m";$/;"	d
CTRL_RED	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_RED          = "\x1B[0;31m";$/;"	d
CTRL_WHITE	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_WHITE        = "\x1B[1;37m";$/;"	d
CTRL_YELLOW	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def CTRL_YELLOW       = "\x1B[1;33m";$/;"	d
Call	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Call(dst: int, func: int, args: Array<int>, src: Source);$/;"	d
CallAddress	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallAddress(p: Mach_FuncRep);$/;"	d
CallClassMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassMethod(method: IrMethod);$/;"	d
CallClassMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallClassMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	d
CallClassSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassSelector(selector: IrSelector);$/;"	d
CallClassVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassVirtual(method: IrMethod);$/;"	d
CallClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClosure;$/;"	d
CallClosure	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallClosure(t: Type);		\/\/ func(args)$/;"	d
CallComponentMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallComponentMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	d
CallFunction	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallFunction;$/;"	d
CallKernel	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallKernel(kernel: Kernel);$/;"	d
CallMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallMethod(method: IrMethod);$/;"	d
CallObjectMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case CallObjectMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	d
CallVariantSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallVariantSelector(selector: IrSelector);$/;"	d
CallVariantVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallVariantVirtual(method: IrMethod);$/;"	d
CallerIp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallerIp;$/;"	d
CallerSp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallerSp;$/;"	d
CaseDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def CaseDeclError(msg: string) {$/;"	m
CaseField	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type CaseField(caseIdx: int, fieldIdx: int) {$/;"	c
CctNode	$VIRGIL/aeneas/src/main/Profiler.v3	/^class CctNode<F>(meth: IrMethod, parent: CctNode<F>) {$/;"	c
CfgContext	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^type CfgContext {$/;"	c
CfgContext.None	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case None;$/;"	c
CfgContext.Return	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Return(t: Type);$/;"	c
CfgContext.Val	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Val(t: Type);$/;"	c
CfgInstr	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^type CfgInstr {$/;"	c
CfgInstr.Block	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Block(t: Type, bi: SsaBlockInfo);$/;"	c
CfgInstr.Body	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Body(bi: SsaBlockInfo);$/;"	c
CfgInstr.Br	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Br(bi: SsaBlockInfo, depth: int);$/;"	c
CfgInstr.BrIf	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case BrIf(split: SsaBlock, val: SsaInstr, bi: SsaBlockInfo, depth: int);$/;"	c
CfgInstr.BrTable	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case BrTable(split: SsaBlock, val: SsaInstr, depths: Array<int>);$/;"	c
CfgInstr.Else	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Else;$/;"	c
CfgInstr.End	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case End;$/;"	c
CfgInstr.Fallthrough	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Fallthrough(bi: SsaBlockInfo, vals: Array<SsaInstr>);$/;"	c
CfgInstr.If	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case If(split: SsaBlock, val: SsaInstr, t: Type, join: SsaBlockInfo);$/;"	c
CfgInstr.Loop	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Loop(bi: SsaBlockInfo);$/;"	c
CfgInstr.Ret	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Ret(r: SsaReturn);$/;"	c
CfgInstr.Unreachable	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Unreachable;$/;"	c
CfgRestructurer	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^class CfgRestructurer {$/;"	c
ChaDevirtualize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var ChaDevirtualize		= flags.get("ChaDevirtualize", level >= 1);$/;"	d
Char	$VIRGIL/aeneas/src/util/Char.v3	/^component Char {$/;"	n
Chars	$VIRGIL/lib/util/Chars.v3	/^component Chars {$/;"	n
CiExEntry	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiExEntry #unboxed {$/;"	c
CiExEntry.Full	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Full(meth: u20, ex: u4, col: u8, line: u16)	#packing 0b_mmmmmmmm_mmmmmmmm_mmmmeeee_cccccccc_llllllll_llllllll; \/\/ TODO: meth != u20.max$/;"	c
CiExEntry.Repeated	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Repeated(ex: u4, count: u4, framewords: u20)	#packing 0b_11111111_11111111_1111eeee_ccccffff_ffffffff_ffffffff;$/;"	c
CiFrameEntry	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiFrameEntry(type_name: u32, file_name: u32) #unboxed$/;"	c
CiMethodEntry	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiMethodEntry(meth_name: u24, type_name: u16, framewords: u12, offset: u12) #unboxed$/;"	c
CiRuntimeModule	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^component CiRuntimeModule {$/;"	n
CiRuntime_Address	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^class CiRuntime_Address extends Addr {$/;"	c
CiRuntime_TypeCon	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^class CiRuntime_TypeCon extends Member_TypeCon {$/;"	c
CiSourceEntry	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiSourceEntry #unboxed {$/;"	c
CiSourceEntry.Ex	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Ex(extended: u18)			#packing 0b_10ee_eeeeeeee_eeeeeeee;$/;"	c
CiSourceEntry.LineCol	$VIRGIL/lib/packing/CiRuntime.v3	/^	case LineCol(line: u11, col: u8) 	#packing 0b_0lll_llllllll_cccccccc;$/;"	c
CiSourceEntry.Words	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Words(framewords: u18)		#packing 0b_11ff_ffffffff_ffffffff;$/;"	c
ClassAlloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassAlloc(method: IrMethod);$/;"	d
ClassField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassField(receiver: Type, member: VstField);$/;"	d
ClassGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetField(field: IrField);$/;"	d
ClassGetMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetMethod(method: IrMethod);$/;"	d
ClassGetSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetSelector(selector: IrSelector);$/;"	d
ClassGetVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetVirtual(method: IrMethod);$/;"	d
ClassInitField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassInitField(field: IrField);$/;"	d
ClassMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	d
ClassNew	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassNew(receiver: Type, member: VstNew, funcType: Type);$/;"	d
ClassSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassSetField(field: IrField);$/;"	d
ClassType	$VIRGIL/aeneas/src/v3/V3Class.v3	/^class ClassType extends Type {$/;"	c
ClientSocket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^class ClientSocket extends Socket {$/;"	c
Closure	$VIRGIL/aeneas/src/types/Function.v3	/^class Closure(val: Val, memberRef: IrSpec) extends Val {$/;"	c
Commute	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Commute(op: Operator);	\/\/ desugared to (y op x)$/;"	d
ComparisonError	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def ComparisonError(range: FileRange, t1: Type, t2: Type) {$/;"	m
Compilation	$VIRGIL/aeneas/src/main/Compiler.v3	/^class Compilation(compiler: Compiler, prog: Program) {$/;"	c
Compiler	$VIRGIL/aeneas/src/main/Compiler.v3	/^class Compiler(target: Target) {$/;"	c
ComponentField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ComponentField(member: VstField);$/;"	d
ComponentGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ComponentGetField(field: IrField);$/;"	d
ComponentMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ComponentMethod(member: VstMethod, typeArgs: TypeArgs);$/;"	d
ComponentSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ComponentSetField(field: IrField);$/;"	d
ComponentType	$VIRGIL/aeneas/src/v3/V3Component.v3	/^class ComponentType extends Type {$/;"	c
Concat	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Concat(l: VstList<VstPackingExpr>);			\/\/ #concat(_, ...)$/;"	d
ConditionalThrow	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ConditionalThrow(exception: string);$/;"	d
Conds	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^def Conds: Arm64Conds; \/\/ TODO$/;"	d
Conds	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def Conds: X86_64Conds;$/;"	d
Const	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Const(vtype: Type, val: Val);$/;"	d
ConstructorError	$VIRGIL/aeneas/src/main/Error.v3	/^	def ConstructorError(msg: string) {$/;"	m
ContinueStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ContinueStmt(src: FileRange) extends Stmt {$/;"	c
CreateClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CreateClosure(method: IrMethod);$/;"	d
D2F	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def D2F		= '\x90'; \/\/ 144$/;"	d
D2I	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def D2I		= '\x8e'; \/\/ 142$/;"	d
D2L	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def D2L		= '\x8f'; \/\/ 143$/;"	d
DADD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DADD	= '\x63'; \/\/ 99$/;"	d
DALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DALOAD	= '\x31'; \/\/ 49$/;"	d
DASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DASTORE	= '\x52'; \/\/ 82$/;"	d
DATA	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def DATA: byte = 11;	 \/\/ Data segments$/;"	d
DATA_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def DATA_END              = addr("DATA_END");$/;"	d
DATA_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def DATA_START            = addr("DATA_START");$/;"	d
DATA_START_ADDR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DATA_START_ADDR	= rtOpt.newAddrOption("data-start-addr", 0,$/;"	d
DCMPG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DCMPG	= '\x98'; \/\/ 152$/;"	d
DCMPL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DCMPL	= '\x97'; \/\/ 151$/;"	d
DCONST_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DCONST_0	= '\x0e'; \/\/ 14$/;"	d
DCONST_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DCONST_1	= '\x0f'; \/\/ 15$/;"	d
DDIV	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DDIV	= '\x6f'; \/\/ 111$/;"	d
DEAD	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def DEAD: i8 = -3;$/;"	d
DEAD	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def DEAD: i8 = -3;$/;"	d
DEBUG	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DEBUG   = actionOpt.newBoolOption("debug", false,$/;"	d
DEBUG_EXTENSION	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DEBUG_EXTENSION = runOpt.newBoolOption("debug-extension", false,$/;"	d
DEF	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def DEF	 = 0x1;$/;"	d
DEFAULT_VADDR_START	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def DEFAULT_VADDR_START: int = 0x08000000;$/;"	d
DEFAULT_VADDR_START	$VIRGIL/aeneas/src/os/Linux.v3	/^	def DEFAULT_VADDR_START = 0x08000000;$/;"	d
DEFAULT_VADDR_START	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def DEFAULT_VADDR_START: int = 0x08000000;$/;"	d
DLOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DLOAD	= '\x18'; \/\/ 24$/;"	d
DLOAD_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DLOAD_0	= '\x26'; \/\/ 38$/;"	d
DLOAD_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DLOAD_1	= '\x27'; \/\/ 39$/;"	d
DLOAD_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DLOAD_2	= '\x28'; \/\/ 40$/;"	d
DLOAD_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DLOAD_3	= '\x29'; \/\/ 41$/;"	d
DMUL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DMUL	= '\x6b'; \/\/ 107$/;"	d
DNEG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DNEG	= '\x77'; \/\/ 119$/;"	d
DONE	$VIRGIL/aeneas/src/ic/Ic.v3	/^def DONE = 4;$/;"	d
DONE	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^def DONE = -3;$/;"	d
DOUBLE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def DOUBLE  = JvmPrimitive.new("double", "D", "D", KIND_DOUBLE);$/;"	d
DREM	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DREM	= '\x73'; \/\/ 115$/;"	d
DRETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DRETURN		= '\xaf'; \/\/ 175$/;"	d
DSTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSTORE	= '\x39'; \/\/ 57$/;"	d
DSTORE_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSTORE_0	= '\x47'; \/\/ 71$/;"	d
DSTORE_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSTORE_1	= '\x48'; \/\/ 72$/;"	d
DSTORE_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSTORE_2	= '\x49'; \/\/ 73$/;"	d
DSTORE_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSTORE_3	= '\x4a'; \/\/ 74$/;"	d
DSUB	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DSUB	= '\x67'; \/\/ 103$/;"	d
DUMP	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def DUMP: Terminal;$/;"	d
DUP	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP		= '\x59'; \/\/ 89$/;"	d
DUP2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP2	= '\x5c'; \/\/ 92$/;"	d
DUP2_X1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP2_X1	= '\x5d'; \/\/ 93$/;"	d
DUP2_X2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP2_X2	= '\x5e'; \/\/ 94$/;"	d
DUP_X1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP_X1	= '\x5a'; \/\/ 90$/;"	d
DUP_X2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def DUP_X2	= '\x5b'; \/\/ 91$/;"	d
DWARF	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DWARF		= compileOpt.newBoolOption("dwarf", false,$/;"	d
DWARFLineBase	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARFLineBase: i8 = -5;$/;"	d
DWARFLineOpcodeBase	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARFLineOpcodeBase: u8 = 13;$/;"	d
DWARFLineRange	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARFLineRange: u8 = 14;$/;"	d
DWARF_CWD	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DWARF_CWD		= compileOpt.newPathOption("dwarf-cwd", ".",$/;"	d
DWARF_DEFAULT_IS_STMT	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_DEFAULT_IS_STMT = 1;$/;"	d
DWARF_FLAG_BASIC_BLOCK	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_FLAG_BASIC_BLOCK = (1 << 1);$/;"	d
DWARF_FLAG_EPILOGUE_BEGIN	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_FLAG_EPILOGUE_BEGIN = (1 << 3);$/;"	d
DWARF_FLAG_IS_STMT	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_FLAG_IS_STMT = 1;$/;"	d
DWARF_FLAG_PROLOGUE_END	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_FLAG_PROLOGUE_END = (1 << 2);$/;"	d
DWARF_LENGTH_SIZE	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_LENGTH_SIZE = 4; \/\/ 32-bit Dwarf format$/;"	d
DWARF_LINE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def DWARF_LINE		= compileOpt.newBoolOption("dwarf-line", false,$/;"	d
DWARF_VERSION	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DWARF_VERSION = 5;$/;"	d
DWRegMap	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DWRegMap(reg: X86_64Reg) -> int {$/;"	f
DW_ATE_UTF	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_UTF = 0x10;$/;"	d
DW_ATE_address	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_address = 0x1;$/;"	d
DW_ATE_boolean	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_boolean = 0x2;$/;"	d
DW_ATE_complex_float	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_complex_float = 0x3;$/;"	d
DW_ATE_decimal_float	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_decimal_float = 0xf;$/;"	d
DW_ATE_edited	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_edited = 0xc;$/;"	d
DW_ATE_float	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_float = 0x4;$/;"	d
DW_ATE_imaginary_float	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_imaginary_float = 0x9;$/;"	d
DW_ATE_numeric_string	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_numeric_string = 0xb;$/;"	d
DW_ATE_packed_decimal	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_packed_decimal = 0xa;$/;"	d
DW_ATE_signed	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_signed = 0x5;$/;"	d
DW_ATE_signed_char	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_signed_char = 0x6;$/;"	d
DW_ATE_signed_fixed	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_signed_fixed = 0xd;$/;"	d
DW_ATE_unsigned	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_unsigned = 0x7;$/;"	d
DW_ATE_unsigned_char	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_unsigned_char = 0x8;$/;"	d
DW_ATE_unsigned_fixed	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_ATE_unsigned_fixed = 0xe;$/;"	d
DW_AT_abstract_origin	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_abstract_origin: u32 = 0x31;$/;"	d
DW_AT_accessibility	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_accessibility: u32 = 0x32;$/;"	d
DW_AT_addr_base	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_addr_base: u32 = 0x73;$/;"	d
DW_AT_address_class	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_address_class: u32 = 0x33;$/;"	d
DW_AT_alignment	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_alignment: u32 = 0x88;$/;"	d
DW_AT_allocated	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_allocated: u32 = 0x4e;$/;"	d
DW_AT_artificial	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_artificial: u32 = 0x34;$/;"	d
DW_AT_associated	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_associated: u32 = 0x4f;$/;"	d
DW_AT_base_types	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_base_types: u32 = 0x35;$/;"	d
DW_AT_binary_scale	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_binary_scale: u32 = 0x5b;$/;"	d
DW_AT_bit_offset	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_bit_offset: u32 = 0x0c;$/;"	d
DW_AT_bit_size	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_bit_size: u32 = 0x0d;$/;"	d
DW_AT_bit_stride	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_bit_stride: u32 = 0x2e;$/;"	d
DW_AT_byte_size	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_byte_size: u32 = 0x0b;$/;"	d
DW_AT_byte_stride	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_byte_stride: u32 = 0x51;$/;"	d
DW_AT_call_all_calls	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_all_calls: u32 = 0x7a;$/;"	d
DW_AT_call_all_source_calls	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_all_source_calls: u32 = 0x7b;$/;"	d
DW_AT_call_all_tail_calls	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_all_tail_calls: u32 = 0x7c;$/;"	d
DW_AT_call_column	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_column: u32 = 0x57;$/;"	d
DW_AT_call_data_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_data_location: u32 = 0x85;$/;"	d
DW_AT_call_data_value	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_data_value: u32 = 0x86;$/;"	d
DW_AT_call_file	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_file: u32 = 0x58;$/;"	d
DW_AT_call_line	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_line: u32 = 0x59;$/;"	d
DW_AT_call_origin	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_origin: u32 = 0x7f;$/;"	d
DW_AT_call_parameter	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_parameter: u32 = 0x80;$/;"	d
DW_AT_call_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_pc: u32 = 0x81;$/;"	d
DW_AT_call_return_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_return_pc: u32 = 0x7d;$/;"	d
DW_AT_call_tail_call	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_tail_call: u32 = 0x82;$/;"	d
DW_AT_call_target	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_target: u32 = 0x83;$/;"	d
DW_AT_call_target_clobbered	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_target_clobbered: u32 = 0x84;$/;"	d
DW_AT_call_value	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_call_value: u32 = 0x7e;$/;"	d
DW_AT_calling_convention	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_calling_convention: u32 = 0x36;$/;"	d
DW_AT_common_reference	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_common_reference: u32 = 0x1a;$/;"	d
DW_AT_comp_dir	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_comp_dir: u32 = 0x1b;$/;"	d
DW_AT_const_expr	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_const_expr: u32 = 0x6c;$/;"	d
DW_AT_const_value	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_const_value: u32 = 0x1c;$/;"	d
DW_AT_containing_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_containing_type: u32 = 0x1d;$/;"	d
DW_AT_count	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_count: u32 = 0x37;$/;"	d
DW_AT_data_bit_offset	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_data_bit_offset: u32 = 0x6b;$/;"	d
DW_AT_data_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_data_location: u32 = 0x50;$/;"	d
DW_AT_data_member_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_data_member_location: u32 = 0x38;$/;"	d
DW_AT_decimal_scale	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_decimal_scale: u32 = 0x5c;$/;"	d
DW_AT_decimal_sign	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_decimal_sign: u32 = 0x5e;$/;"	d
DW_AT_decl_column	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_decl_column: u32 = 0x39;$/;"	d
DW_AT_decl_file	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_decl_file: u32 = 0x3a;$/;"	d
DW_AT_decl_line	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_decl_line: u32 = 0x3b;$/;"	d
DW_AT_declaration	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_declaration: u32 = 0x3c;$/;"	d
DW_AT_default_value	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_default_value: u32 = 0x1e;$/;"	d
DW_AT_defaulted	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_defaulted: u32 = 0x8b;$/;"	d
DW_AT_deleted	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_deleted: u32 = 0x8a;$/;"	d
DW_AT_description	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_description: u32 = 0x5a;$/;"	d
DW_AT_digit_count	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_digit_count: u32 = 0x5f;$/;"	d
DW_AT_discr	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_discr: u32 = 0x15;$/;"	d
DW_AT_discr_list	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_discr_list: u32 = 0x3d;$/;"	d
DW_AT_discr_value	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_discr_value: u32 = 0x16;$/;"	d
DW_AT_dwo_name	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_dwo_name: u32 = 0x76;$/;"	d
DW_AT_element_list	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_element_list: u32 = 0x0f;$/;"	d
DW_AT_elemental	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_elemental: u32 = 0x66;$/;"	d
DW_AT_encoding	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_encoding: u32 = 0x3e;$/;"	d
DW_AT_endianity	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_endianity: u32 = 0x65;$/;"	d
DW_AT_entry_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_entry_pc: u32 = 0x52;$/;"	d
DW_AT_enum_class	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_enum_class: u32 = 0x6d;$/;"	d
DW_AT_explicit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_explicit: u32 = 0x63;$/;"	d
DW_AT_export_symbols	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_export_symbols: u32 = 0x89;$/;"	d
DW_AT_extension	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_extension: u32 = 0x54;$/;"	d
DW_AT_external	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_external: u32 = 0x3f;$/;"	d
DW_AT_frame_base	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_frame_base: u32 = 0x40;$/;"	d
DW_AT_friend	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_friend: u32 = 0x41;$/;"	d
DW_AT_high_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_high_pc: u32 = 0x12;$/;"	d
DW_AT_identifier_case	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_identifier_case: u32 = 0x42;$/;"	d
DW_AT_import	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_import: u32 = 0x18;$/;"	d
DW_AT_inline	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_inline: u32 = 0x20;$/;"	d
DW_AT_is_optional	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_is_optional: u32 = 0x21;$/;"	d
DW_AT_language	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_language: u32 = 0x13;$/;"	d
DW_AT_linkage_name	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_linkage_name: u32 = 0x6e;$/;"	d
DW_AT_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_location: u32 = 0x02;$/;"	d
DW_AT_loclists_base	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_loclists_base: u32 = 0x8c;$/;"	d
DW_AT_low_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_low_pc: u32 = 0x11;$/;"	d
DW_AT_lower_bound	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_lower_bound: u32 = 0x22;$/;"	d
DW_AT_macro_info	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_macro_info: u32 = 0x43;$/;"	d
DW_AT_macros	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_macros: u32 = 0x79;$/;"	d
DW_AT_main_subprogram	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_main_subprogram: u32 = 0x6a;$/;"	d
DW_AT_member	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_member: u32 = 0x14;$/;"	d
DW_AT_mutable	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_mutable: u32 = 0x61;$/;"	d
DW_AT_name	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_name: u32 = 0x03;$/;"	d
DW_AT_namelist_item	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_namelist_item: u32 = 0x44;$/;"	d
DW_AT_noreturn	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_noreturn: u32 = 0x87;$/;"	d
DW_AT_object_pointer	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_object_pointer: u32 = 0x64;$/;"	d
DW_AT_ordering	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_ordering: u32 = 0x09;$/;"	d
DW_AT_picture_string	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_picture_string: u32 = 0x60;$/;"	d
DW_AT_priority	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_priority: u32 = 0x45;$/;"	d
DW_AT_producer	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_producer: u32 = 0x25;$/;"	d
DW_AT_prototyped	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_prototyped: u32 = 0x27;$/;"	d
DW_AT_pure	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_pure: u32 = 0x67;$/;"	d
DW_AT_ranges	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_ranges: u32 = 0x55;$/;"	d
DW_AT_rank	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_rank: u32 = 0x71;$/;"	d
DW_AT_recursive	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_recursive: u32 = 0x68;$/;"	d
DW_AT_reference	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_reference: u32 = 0x77;$/;"	d
DW_AT_return_addr	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_return_addr: u32 = 0x2a;$/;"	d
DW_AT_rnglists_base	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_rnglists_base: u32 = 0x74;$/;"	d
DW_AT_rvalue_reference	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_rvalue_reference: u32 = 0x78;$/;"	d
DW_AT_segment	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_segment: u32 = 0x46;$/;"	d
DW_AT_sibling	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_sibling: u32 = 0x01;$/;"	d
DW_AT_signature	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_signature: u32 = 0x69;$/;"	d
DW_AT_small	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_small: u32 = 0x5d;$/;"	d
DW_AT_specification	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_specification: u32 = 0x47;$/;"	d
DW_AT_start_scope	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_start_scope: u32 = 0x2c;$/;"	d
DW_AT_static_link	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_static_link: u32 = 0x48;$/;"	d
DW_AT_stmt_list	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_stmt_list: u32 = 0x10;$/;"	d
DW_AT_str_offsets_base	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_str_offsets_base: u32 = 0x72;$/;"	d
DW_AT_string_length	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_string_length: u32 = 0x19;$/;"	d
DW_AT_string_length_bit_size	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_string_length_bit_size: u32 = 0x6f;$/;"	d
DW_AT_string_length_byte_size	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_string_length_byte_size: u32 = 0x70;$/;"	d
DW_AT_subscr_data	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_subscr_data: u32 = 0x0a;$/;"	d
DW_AT_threads_scaled	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_threads_scaled: u32 = 0x62;$/;"	d
DW_AT_trampoline	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_trampoline: u32 = 0x56;$/;"	d
DW_AT_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_type: u32 = 0x49;$/;"	d
DW_AT_upper_bound	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_upper_bound: u32 = 0x2f;$/;"	d
DW_AT_use_UTF8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_use_UTF8: u32 = 0x53;$/;"	d
DW_AT_use_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_use_location: u32 = 0x4a;$/;"	d
DW_AT_variable_parameter	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_variable_parameter: u32 = 0x4b;$/;"	d
DW_AT_virtuality	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_virtuality: u32 = 0x4c;$/;"	d
DW_AT_visibility	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_visibility: u32 = 0x17;$/;"	d
DW_AT_vtable_elem_location	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_AT_vtable_elem_location: u32 = 0x4d;$/;"	d
DW_FORM_addr	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addr: u32 = 0x01;$/;"	d
DW_FORM_addrx	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addrx: u32 = 0x1b;$/;"	d
DW_FORM_addrx1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addrx1: u32 = 0x29;$/;"	d
DW_FORM_addrx2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addrx2: u32 = 0x2a;$/;"	d
DW_FORM_addrx3	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addrx3: u32 = 0x2b;$/;"	d
DW_FORM_addrx4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_addrx4: u32 = 0x2c;$/;"	d
DW_FORM_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_block: u32 = 0x09;$/;"	d
DW_FORM_block1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_block1: u32 = 0x0a;$/;"	d
DW_FORM_block2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_block2: u32 = 0x03;$/;"	d
DW_FORM_block4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_block4: u32 = 0x04;$/;"	d
DW_FORM_data1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_data1: u32 = 0x0b;$/;"	d
DW_FORM_data16	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_data16: u32 = 0x1e;$/;"	d
DW_FORM_data2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_data2: u32 = 0x05;$/;"	d
DW_FORM_data4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_data4: u32 = 0x06;$/;"	d
DW_FORM_data8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_data8: u32 = 0x07;$/;"	d
DW_FORM_exprloc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_exprloc: u32 = 0x18;$/;"	d
DW_FORM_flag	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_flag: u32 = 0x0c;$/;"	d
DW_FORM_flag_present	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_flag_present: u32 = 0x19;$/;"	d
DW_FORM_implicit_const	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_implicit_const: u32 = 0x21;$/;"	d
DW_FORM_indirect	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_indirect: u32 = 0x16;$/;"	d
DW_FORM_line_strp	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_line_strp: u32 = 0x1f;$/;"	d
DW_FORM_loclistx	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_loclistx: u32 = 0x22;$/;"	d
DW_FORM_ref1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref1: u32 = 0x11;$/;"	d
DW_FORM_ref2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref2: u32 = 0x12;$/;"	d
DW_FORM_ref4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref4: u32 = 0x13;$/;"	d
DW_FORM_ref8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref8: u32 = 0x14;$/;"	d
DW_FORM_ref_addr	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref_addr: u32 = 0x10;$/;"	d
DW_FORM_ref_sig8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref_sig8: u32 = 0x20;$/;"	d
DW_FORM_ref_sup4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref_sup4: u32 = 0x1c;$/;"	d
DW_FORM_ref_sup8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref_sup8: u32 = 0x24;$/;"	d
DW_FORM_ref_udata	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_ref_udata: u32 = 0x15;$/;"	d
DW_FORM_rnglistx	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_rnglistx: u32 = 0x23;$/;"	d
DW_FORM_sdata	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_sdata: u32 = 0x0d;$/;"	d
DW_FORM_sec_offset	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_sec_offset: u32 = 0x17;$/;"	d
DW_FORM_string	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_string: u32 = 0x08;$/;"	d
DW_FORM_strp	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strp: u32 = 0x0e;$/;"	d
DW_FORM_strp_sup	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strp_sup: u32 = 0x1d;$/;"	d
DW_FORM_strx	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strx: u32 = 0x1a;$/;"	d
DW_FORM_strx1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strx1: u32 = 0x25;$/;"	d
DW_FORM_strx2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strx2: u32 = 0x26;$/;"	d
DW_FORM_strx3	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strx3: u32 = 0x27;$/;"	d
DW_FORM_strx4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_strx4: u32 = 0x28;$/;"	d
DW_FORM_udata	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_FORM_udata: u32 = 0x0f;$/;"	d
DW_LLE_end_of_list	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LLE_end_of_list = 0x0;$/;"	d
DW_LLE_offset_pair	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LLE_offset_pair = 0x4;$/;"	d
DW_LNCT_directory_index	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNCT_directory_index: u32 = 2;$/;"	d
DW_LNCT_path	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNCT_path: u32 = 1;$/;"	d
DW_LNE_define_file	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNE_define_file = 3;$/;"	d
DW_LNE_end_sequence	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNE_end_sequence = 1;$/;"	d
DW_LNE_set_address	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNE_set_address = 2;$/;"	d
DW_LNE_set_discriminator	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNE_set_discriminator = 4;$/;"	d
DW_LNS_advance_line	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_advance_line = 3;$/;"	d
DW_LNS_advance_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_advance_pc = 2;$/;"	d
DW_LNS_const_add_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_const_add_pc = 8;$/;"	d
DW_LNS_copy	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_copy = 1;$/;"	d
DW_LNS_extended_op	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_extended_op = 0;$/;"	d
DW_LNS_fixed_advance_pc	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_fixed_advance_pc = 9;$/;"	d
DW_LNS_negate_stmt	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_negate_stmt = 6;$/;"	d
DW_LNS_set_basic_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_basic_block = 7;$/;"	d
DW_LNS_set_column	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_column = 5;$/;"	d
DW_LNS_set_epilogue_begin	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_epilogue_begin = 11;$/;"	d
DW_LNS_set_file	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_file = 4;$/;"	d
DW_LNS_set_isa	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_isa = 12;$/;"	d
DW_LNS_set_prologue_end	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_LNS_set_prologue_end = 10;$/;"	d
DW_OP_deref	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_deref = 0x06;$/;"	d
DW_OP_fbreg	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_fbreg = 0x91;$/;"	d
DW_OP_lit0	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit0 = 0x30;$/;"	d
DW_OP_lit1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit1 = 0x31;$/;"	d
DW_OP_lit2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit2 = 0x32;$/;"	d
DW_OP_lit3	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit3 = 0x33;$/;"	d
DW_OP_lit4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit4 = 0x34;$/;"	d
DW_OP_lit5	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit5 = 0x35;$/;"	d
DW_OP_lit6	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit6 = 0x36;$/;"	d
DW_OP_lit7	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit7 = 0x37;$/;"	d
DW_OP_lit8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_lit8 = 0x38;$/;"	d
DW_OP_minus	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_minus = 0x1c;$/;"	d
DW_OP_plus	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_plus = 0x22;$/;"	d
DW_OP_push_object_address	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_push_object_address = 0x97;$/;"	d
DW_OP_reg0	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg0 = 0x50;$/;"	d
DW_OP_reg1	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg1 = 0x51;$/;"	d
DW_OP_reg10	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg10 = 0x5a;$/;"	d
DW_OP_reg11	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg11 = 0x5b;$/;"	d
DW_OP_reg12	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg12 = 0x5c;$/;"	d
DW_OP_reg13	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg13 = 0x5d;$/;"	d
DW_OP_reg14	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg14 = 0x5e;$/;"	d
DW_OP_reg15	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg15 = 0x5f;$/;"	d
DW_OP_reg16	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg16 = 0x60;$/;"	d
DW_OP_reg17	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg17 = 0x61;$/;"	d
DW_OP_reg18	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg18 = 0x62;$/;"	d
DW_OP_reg19	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg19 = 0x63;$/;"	d
DW_OP_reg2	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg2 = 0x52;$/;"	d
DW_OP_reg20	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg20 = 0x64;$/;"	d
DW_OP_reg21	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg21 = 0x65;$/;"	d
DW_OP_reg22	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg22 = 0x66;$/;"	d
DW_OP_reg23	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg23 = 0x67;$/;"	d
DW_OP_reg24	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg24 = 0x68;$/;"	d
DW_OP_reg25	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg25 = 0x69;$/;"	d
DW_OP_reg26	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg26 = 0x6a;$/;"	d
DW_OP_reg27	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg27 = 0x6b;$/;"	d
DW_OP_reg28	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg28 = 0x6c;$/;"	d
DW_OP_reg29	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg29 = 0x6d;$/;"	d
DW_OP_reg3	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg3 = 0x53;$/;"	d
DW_OP_reg30	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg30 = 0x6e;$/;"	d
DW_OP_reg31	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg31 = 0x6f;$/;"	d
DW_OP_reg4	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg4 = 0x54;$/;"	d
DW_OP_reg5	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg5 = 0x55;$/;"	d
DW_OP_reg6	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg6 = 0x56;$/;"	d
DW_OP_reg7	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg7 = 0x57;$/;"	d
DW_OP_reg8	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg8 = 0x58;$/;"	d
DW_OP_reg9	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_OP_reg9 = 0x59;$/;"	d
DW_TAG_access_declaration	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_access_declaration: u32 = 0x23;$/;"	d
DW_TAG_array_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_array_type: u32 = 0x01;$/;"	d
DW_TAG_atomic_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_atomic_type: u32 = 0x47;$/;"	d
DW_TAG_base_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_base_type: u32 = 0x24;$/;"	d
DW_TAG_call_site	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_call_site: u32 = 0x48;$/;"	d
DW_TAG_call_site_parameter	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_call_site_parameter: u32 = 0x49;$/;"	d
DW_TAG_catch_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_catch_block: u32 = 0x25;$/;"	d
DW_TAG_class_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_class_type: u32 = 0x02;$/;"	d
DW_TAG_coarray_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_coarray_type: u32 = 0x44;$/;"	d
DW_TAG_common_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_common_block: u32 = 0x1a;$/;"	d
DW_TAG_common_inclusion	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_common_inclusion: u32 = 0x1b;$/;"	d
DW_TAG_compile_unit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_compile_unit: u32 = 0x11;$/;"	d
DW_TAG_condition	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_condition: u32 = 0x3f;$/;"	d
DW_TAG_const_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_const_type: u32 = 0x26;$/;"	d
DW_TAG_constant	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_constant: u32 = 0x27;$/;"	d
DW_TAG_dwarf_procedure	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_dwarf_procedure: u32 = 0x36;$/;"	d
DW_TAG_dynamic_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_dynamic_type: u32 = 0x46;$/;"	d
DW_TAG_entry_point	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_entry_point: u32 = 0x03;$/;"	d
DW_TAG_enumeration_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_enumeration_type: u32 = 0x04;$/;"	d
DW_TAG_enumerator	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_enumerator: u32 = 0x28;$/;"	d
DW_TAG_file_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_file_type: u32 = 0x29;$/;"	d
DW_TAG_formal_parameter	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_formal_parameter: u32 = 0x05;$/;"	d
DW_TAG_friend	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_friend: u32 = 0x2a;$/;"	d
DW_TAG_generic_subrange	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_generic_subrange: u32 = 0x45;$/;"	d
DW_TAG_immutable_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_immutable_type: u32 = 0x4b;$/;"	d
DW_TAG_imported_declaration	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_imported_declaration: u32 = 0x08;$/;"	d
DW_TAG_imported_module	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_imported_module: u32 = 0x3a;$/;"	d
DW_TAG_imported_unit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_imported_unit: u32 = 0x3d;$/;"	d
DW_TAG_inheritance	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_inheritance: u32 = 0x1c;$/;"	d
DW_TAG_inlined_subroutine	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_inlined_subroutine: u32 = 0x1d;$/;"	d
DW_TAG_interface_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_interface_type: u32 = 0x38;$/;"	d
DW_TAG_label	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_label: u32 = 0x0a;$/;"	d
DW_TAG_lexical_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_lexical_block: u32 = 0x0b;$/;"	d
DW_TAG_member	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_member: u32 = 0x0d;$/;"	d
DW_TAG_module	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_module: u32 = 0x1e;$/;"	d
DW_TAG_namelist	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_namelist: u32 = 0x2b;$/;"	d
DW_TAG_namelist_item	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_namelist_item: u32 = 0x2c;$/;"	d
DW_TAG_namespace	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_namespace: u32 = 0x39;$/;"	d
DW_TAG_packed_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_packed_type: u32 = 0x2d;$/;"	d
DW_TAG_partial_unit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_partial_unit: u32 = 0x3c;$/;"	d
DW_TAG_pointer_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_pointer_type: u32 = 0x0f;$/;"	d
DW_TAG_ptr_to_member_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_ptr_to_member_type: u32 = 0x1f;$/;"	d
DW_TAG_reference_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_reference_type: u32 = 0x10;$/;"	d
DW_TAG_restrict_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_restrict_type: u32 = 0x37;$/;"	d
DW_TAG_rvalue_reference_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_rvalue_reference_type: u32 = 0x42;$/;"	d
DW_TAG_set_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_set_type: u32 = 0x20;$/;"	d
DW_TAG_shared_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_shared_type: u32 = 0x40;$/;"	d
DW_TAG_skeleton_unit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_skeleton_unit: u32 = 0x4a;$/;"	d
DW_TAG_string_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_string_type: u32 = 0x12;$/;"	d
DW_TAG_structure_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_structure_type: u32 = 0x13;$/;"	d
DW_TAG_subprogram	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_subprogram: u32 = 0x2e;$/;"	d
DW_TAG_subrange_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_subrange_type: u32 = 0x21;$/;"	d
DW_TAG_subroutine_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_subroutine_type: u32 = 0x15;$/;"	d
DW_TAG_template_alias	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_template_alias: u32 = 0x43;$/;"	d
DW_TAG_template_type_param	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_template_type_param: u32 = 0x2f;$/;"	d
DW_TAG_template_value_param	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_template_value_param: u32 = 0x30;$/;"	d
DW_TAG_thrown_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_thrown_type: u32 = 0x31;$/;"	d
DW_TAG_try_block	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_try_block: u32 = 0x32;$/;"	d
DW_TAG_type_unit	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_type_unit: u32 = 0x41;$/;"	d
DW_TAG_typedef	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_typedef: u32 = 0x16;$/;"	d
DW_TAG_union_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_union_type: u32 = 0x17;$/;"	d
DW_TAG_unspecified_parameters	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_unspecified_parameters: u32 = 0x18;$/;"	d
DW_TAG_unspecified_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_unspecified_type: u32 = 0x3b;$/;"	d
DW_TAG_variable	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_variable: u32 = 0x34;$/;"	d
DW_TAG_variant	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_variant: u32 = 0x19;$/;"	d
DW_TAG_variant_part	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_variant_part: u32 = 0x33;$/;"	d
DW_TAG_volatile_type	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_volatile_type: u32 = 0x35;$/;"	d
DW_TAG_with_stmt	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_TAG_with_stmt: u32 = 0x22;$/;"	d
DW_UT_compile	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_UT_compile = 1;$/;"	d
DW_children_no	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_children_no = 0;$/;"	d
DW_children_yes	$VIRGIL/aeneas/src/debug/DwarfConst.v3	/^	def DW_children_yes = 1;$/;"	d
DarwinConst	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^component DarwinConst {$/;"	n
DarwinModule	$VIRGIL/aeneas/src/x86/DarwinModule.v3	/^component DarwinModule {$/;"	n
DataReader	$VIRGIL/lib/util/DataReader.v3	/^class DataReader {$/;"	c
DataReaders	$VIRGIL/lib/util/DataReader.v3	/^component DataReaders {$/;"	n
DataWriter	$VIRGIL/lib/util/DataWriter.v3	/^class DataWriter {$/;"	c
DataWriters	$VIRGIL/lib/util/DataWriter.v3	/^component DataWriters {$/;"	n
DeadCodeAnalyzer	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class DeadCodeAnalyzer(ra: ReachabilityAnalyzer) {$/;"	c
Debug	$VIRGIL/aeneas/src/main/Debug.v3	/^component Debug {$/;"	n
DebugSectionCount	$VIRGIL/aeneas/src/os/Linux.v3	/^def DebugSectionCount = 6;$/;"	d
DebugSymbol	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def DebugSymbol = CLOptions.DEBUG.get() || ((CLOptions.DWARF.get() || CLOptions.DWARF_LINE.get()) && LinuxTarget.?(target));$/;"	d
DebuggerParser	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^class DebuggerParser {$/;"	c
DecLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^class DecLiteral extends IntLiteral {$/;"	c
Decl	$VIRGIL/aeneas/src/vst/Vst.v3	/^class Decl(token: Token) {$/;"	c
Def	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Def(vreg: VReg, constraint: int);$/;"	d
DisableBoundsChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var DisableBoundsChecks		= flags.getUnsafe("DisableBoundsChecks");$/;"	d
DisableLengthChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var DisableLengthChecks		= flags.getUnsafe("DisableLengthChecks");$/;"	d
DisableNullChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var DisableNullChecks		= flags.getUnsafe("DisableNullChecks");$/;"	d
DisableTypeChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var DisableTypeChecks		= flags.getUnsafe("DisableTypeChecks");$/;"	d
DivideByZero	$VIRGIL/aeneas/src/v3/V3.v3	/^	def DivideByZero  = "DivideByZeroException";$/;"	d
Dwarf	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class Dwarf {$/;"	c
DwarfAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfAbbrev {$/;"	c
DwarfAbbrevSection	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfAbbrevSection {$/;"	c
DwarfArrayTypeAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfArrayTypeAbbrev extends DwarfAbbrev {$/;"	c
DwarfBaseTypeTag	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DwarfBaseTypeTag = 2u;$/;"	d
DwarfClassTypeAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfClassTypeAbbrev extends DwarfAbbrev {$/;"	c
DwarfCompileUnitTag	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DwarfCompileUnitTag = 1u;$/;"	d
DwarfDie	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfDie {$/;"	c
DwarfDir	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfDir {$/;"	c
DwarfDirFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfDirFile {$/;"	c
DwarfEnumuratorAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfEnumuratorAbbrev extends DwarfAbbrev {$/;"	c
DwarfEnumutationTypeAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfEnumutationTypeAbbrev extends DwarfAbbrev {$/;"	c
DwarfFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfFile {$/;"	c
DwarfInfoSection	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfInfoSection(abbrev: DwarfAbbrevSection) {$/;"	c
DwarfLexicalBlock	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLexicalBlock extends DwarfDie {$/;"	c
DwarfLexicalBlockAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLexicalBlockAbbrev extends DwarfAbbrev {$/;"	c
DwarfLineEntry	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLineEntry {$/;"	c
DwarfLineSection	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLineSection(dirFile: DwarfDirFile) {$/;"	c
DwarfLocList	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLocList(v: DwarfVariable) {$/;"	c
DwarfLocListEntry	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^type DwarfLocListEntry(start: u32, reg: X86_64Reg, location: int) #unboxed { }$/;"	c
DwarfLocListsSection	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfLocListsSection {$/;"	c
DwarfMemberAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfMemberAbbrev extends DwarfAbbrev {$/;"	c
DwarfSubprogram	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfSubprogram extends DwarfDie {$/;"	c
DwarfSubprogramAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfSubprogramAbbrev(hasFile: bool, hasRet: bool) extends DwarfAbbrev {$/;"	c
DwarfSubrangeTypeAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfSubrangeTypeAbbrev extends DwarfAbbrev {$/;"	c
DwarfUnspecifiedTypeAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfUnspecifiedTypeAbbrev extends DwarfAbbrev {$/;"	c
DwarfVariable	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^class DwarfVariable extends DwarfDie {$/;"	c
DwarfVariableExprTag	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DwarfVariableExprTag = 3u;$/;"	d
DwarfVariableLocListTag	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def DwarfVariableLocListTag = 4u;$/;"	d
EAX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EAX = '\x01';$/;"	d
EAX	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def EAX = X86Reg.new("al", "ax", "eax", 0);$/;"	d
EAX_EDX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EAX_EDX = '\x12';$/;"	d
EBP	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EBP = '\x0f';$/;"	d
EBP	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def EBP = X86Reg.new(null, "bp", "ebp", 5);$/;"	d
EBX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EBX = '\x04';$/;"	d
EBX	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def EBX = X86Reg.new("bl", "bx", "ebx", 3);$/;"	d
ECX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def ECX = '\x02';$/;"	d
ECX	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ECX = X86Reg.new("cl", "cx", "ecx", 1);$/;"	d
EDI	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EDI = '\x06';$/;"	d
EDI	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def EDI = X86Reg.new(null, "di", "edi", 7);$/;"	d
EDX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def EDX = '\x03';$/;"	d
EDX	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def EDX = X86Reg.new("dl", "dx", "edx", 2);$/;"	d
ELEMENT	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def ELEMENT: byte = 9;	 \/\/ Elements section$/;"	d
ELFCLASS32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def ELFCLASS32 = 1;$/;"	d
ELFCLASS64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def ELFCLASS64 = 2;$/;"	d
ELIM	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def ELIM = TypeVarEliminator.new(null, null);$/;"	d
EMPTY	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def EMPTY = "";$/;"	d
EMPTY	$VIRGIL/rt/x86-64-darwin/System.v3	/^	private def EMPTY = "";$/;"	d
EMPTY_BYTES	$VIRGIL/lib/util/DataReader.v3	/^def EMPTY_BYTES: Array<byte> = []; \/\/ used instead of null$/;"	d
EMPTY_FIELD	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def EMPTY_FIELD = VariantField.new(null, []);$/;"	d
EMPTY_INTERVAL	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^def EMPTY_INTERVAL = Interval(0, 0);$/;"	d
EMPTY_INTERVAL	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def EMPTY_INTERVAL = Interval(0, 0);$/;"	d
EM_386	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_386 = 3;$/;"	d
EM_AARCH64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_AARCH64 = 183;$/;"	d
EM_ARM	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_ARM = 40;$/;"	d
EM_MIPS	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_MIPS = 8;$/;"	d
EM_NONE	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_NONE = 0;$/;"	d
EM_PPC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_PPC = 20;$/;"	d
EM_PPC64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_PPC64 = 21;$/;"	d
EM_RISCV	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_RISCV = 243;$/;"	d
EM_X86_64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def EM_X86_64 = 62;$/;"	d
END	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def END       = '\x00';$/;"	d
ENTRY_EXPORT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def ENTRY_EXPORT	= wasmOpt.newStringOption("entry-export", "entry",$/;"	d
EQUAL	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^def EQUAL = '\xFD';$/;"	d
EQUALS_METHOD_INDEX	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def EQUALS_METHOD_INDEX = 1;$/;"	d
EQUALS_VST_METHOD	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def EQUALS_VST_METHOD = VstMethod.new(false, Token.new(null, "==", 0, 0), null, null, ReturnType.Void, null);$/;"	d
ERROR	$VIRGIL/aeneas/src/core/Program.v3	/^	def ERROR = ErrorGen.new(15);		\/\/ error generator$/;"	d
ERROR	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def ERROR: ErrorGen;			\/\/ the error generator$/;"	d
ERROR	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var ERROR: ErrorGen;$/;"	d
ERROR	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def ERROR = "X86_64AssemblerError";$/;"	d
ERROR_TYPE	$VIRGIL/aeneas/src/types/Void.v3	/^	def ERROR_TYPE = TypeUtil.singleType("#error", Kind.VOID, ErrorType.new);$/;"	d
ESC	$VIRGIL/lib/term/Vt100.v3	/^def ESC = '\x1b';$/;"	d
ESI	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def ESI = '\x05';$/;"	d
ESI	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ESI = X86Reg.new(null, "si", "esi", 6);$/;"	d
ESP	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ESP = X86Reg.new(null, "sp", "esp", 4);$/;"	d
EVERYLPS	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^def EVERYLPS = false; \/\/ only available if useShadowStack$/;"	d
EVERYUSE	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^def EVERYUSE = false;$/;"	d
EXCEPTION	$VIRGIL/aeneas/src/ic/Ic.v3	/^def EXCEPTION = 2;$/;"	d
EXPECT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def EXPECT		= testOpt.newPathOption("expect", null,$/;"	d
EXPORT	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def EXPORT: byte = 7;	 \/\/ Exports$/;"	d
EX_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def EX_END                = addr("EX_END");$/;"	d
EX_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def EX_START              = addr("EX_START");$/;"	d
EX_STRINGS	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def EX_STRINGS            = addr("EX_STRINGS");$/;"	d
EX_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def EX_TABLE              = addr("EX_TABLE");$/;"	d
E_EHSIZE32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_EHSIZE32 = 52;    \/\/ size of ELF header$/;"	d
E_EHSIZE64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_EHSIZE64 = 64;    \/\/ size of ELF header$/;"	d
E_PHENTSIZE32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_PHENTSIZE32 = 32; \/\/ size of program header entry$/;"	d
E_PHENTSIZE64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_PHENTSIZE64 = 56; \/\/ size of program header entry$/;"	d
E_SHENTSIZE32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_SHENTSIZE32 = 40; \/\/ size of section header entry$/;"	d
E_SHENTSIZE64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def E_SHENTSIZE64 = 64; \/\/ size of section header entry$/;"	d
Edge	$VIRGIL/lib/util/Edge.v3	/^class Edge<T> {$/;"	c
ElfConst	$VIRGIL/aeneas/src/exe/ELF.v3	/^component ElfConst {$/;"	n
ElfHeader	$VIRGIL/aeneas/src/exe/ELF.v3	/^class ElfHeader {$/;"	c
ElfProgramHeader	$VIRGIL/aeneas/src/exe/ELF.v3	/^class ElfProgramHeader {$/;"	c
ElfSectionHeader	$VIRGIL/aeneas/src/exe/ELF.v3	/^class ElfSectionHeader {$/;"	c
ElfSections	$VIRGIL/aeneas/src/os/Linux.v3	/^class ElfSections(elf: ElfHeader, debugSymbol: bool) {$/;"	c
ElfSymbol	$VIRGIL/aeneas/src/exe/ELF.v3	/^class ElfSymbol {$/;"	c
Else	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Else;$/;"	d
EmitSwitch	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var EmitSwitch			= flags.get("EmitSwitch", level >= 1);$/;"	d
EmptyStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class EmptyStmt(point: FilePoint) extends Stmt {$/;"	c
End	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case End;$/;"	d
EnumConst	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumConst(member: VstEnumCase);$/;"	d
EnumGetParam	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumGetParam(field: VstField);	\/\/ desugared to ArrayGetElem(#field, x)$/;"	d
EnumSetHas	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetHas(vcase: VstEnumCase);	\/\/ desugared to (1 << k) & x != 0$/;"	d
EnumSetIntersect	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetIntersect;			\/\/ desugared to x & y$/;"	d
EnumSetStrictSubset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetStrictSubset;$/;"	d
EnumSetStrictSuperset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetStrictSuperset;$/;"	d
EnumSetSubset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSubset;			\/\/ desugared to x & y == x$/;"	d
EnumSetSubtract	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSubtract;			\/\/ desugared to x & ~(x & y)$/;"	d
EnumSetSuperset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSuperset;$/;"	d
EnumSetTooLarge	$VIRGIL/aeneas/src/main/Error.v3	/^	def EnumSetTooLarge(t: Type, tref: TypeRef, size: int) {$/;"	m
EnumSetType	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^class EnumSetType extends Type {$/;"	c
EnumSetUnion	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetUnion;			\/\/ desugared to x | y$/;"	d
EnumType	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^class EnumType extends Type {$/;"	c
Error	$VIRGIL/aeneas/src/main/Error.v3	/^class Error {$/;"	c
Error	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Error(e: NetError);$/;"	d
ErrorGen	$VIRGIL/aeneas/src/main/Error.v3	/^class ErrorGen(maxErrors: int) {$/;"	c
ErrorType	$VIRGIL/aeneas/src/types/Void.v3	/^class ErrorType extends Type {$/;"	c
Eval	$VIRGIL/aeneas/src/core/Eval.v3	/^component Eval {$/;"	n
ExSource	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case ExSource(ex: string, source: Source);$/;"	d
Exception	$VIRGIL/aeneas/src/core/Value.v3	/^class Exception(error: string, msg: string, trace: List<Source>) extends Result { }$/;"	c
ExceptionInInitialization	$VIRGIL/aeneas/src/main/Error.v3	/^	def ExceptionInInitialization(meth: VstMethod, except: Exception) {$/;"	m
Explicit	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Explicit(tref: TypeRef);	\/\/ -> typeref$/;"	d
ExplicitDivChecks	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var ExplicitDivChecks = false;	 \/\/ insert explicit maxint \/ -1 checks$/;"	d
ExplicitModChecks	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var ExplicitModChecks = false;	 \/\/ insert explicit maxint % -1 checks$/;"	d
ExportDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ExportDecl extends Decl {$/;"	c
ExportDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def ExportDeclError(msg: string) {$/;"	m
Expr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class Expr {$/;"	c
ExprStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ExprStmt(src: FileRange, expr: Expr) extends Stmt {$/;"	c
ExternRef	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case ExternRef;$/;"	d
ExtraPackingBit	$VIRGIL/aeneas/src/main/Error.v3	/^	def ExtraPackingBit(name: string, max: byte) {$/;"	m
F2D	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def F2D		= '\x8d'; \/\/ 141$/;"	d
F2I	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def F2I		= '\x8b'; \/\/ 139$/;"	d
F2L	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def F2L		= '\x8c'; \/\/ 140$/;"	d
F32	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case F32;$/;"	d
F32_INFINITY	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_INFINITY = Float32Val.new(0x7f800000u);$/;"	d
F32_MINUS_INFINITY	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_MINUS_INFINITY = Float32Val.new(0xff800000u);$/;"	d
F32_MINUS_ZERO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_MINUS_ZERO = Float32Val.new(0x80000000u);$/;"	d
F32_NAN	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_NAN = Float32Val.new(0x7fc00000);$/;"	d
F32_ONE	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_ONE = Float32Val.new(0x3f800000);$/;"	d
F32_TWO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_TWO = Float32Val.new(0x40000000);$/;"	d
F32_ZERO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F32_ZERO = Float32Val.new(0);$/;"	d
F64	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case F64;$/;"	d
F64_INFINITY	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_INFINITY = Float64Val.new(0x7ff0000000000000ul);$/;"	d
F64_MANTISSA_MASK	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_MANTISSA_MASK = 0x7FFFFFFFFFFFFu;$/;"	d
F64_MINUS_INFINITY	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_MINUS_INFINITY = Float64Val.new(0xfff0000000000000ul);$/;"	d
F64_MINUS_ZERO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_MINUS_ZERO = Float64Val.new(0x8000000000000000ul);$/;"	d
F64_NAN	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_NAN = Float64Val.new(0x7ff8000000000000);$/;"	d
F64_NAN_BITS	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_NAN_BITS = 0x7ff8000000000000u;$/;"	d
F64_ONE	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_ONE = Float64Val.new(0x3ff0000000000000);$/;"	d
F64_TWO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_TWO = Float64Val.new(0x4000000000000000);$/;"	d
F64_ZERO	$VIRGIL/aeneas/src/types/Float.v3	/^	def F64_ZERO = Float64Val.new(0);$/;"	d
FADD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FADD	= '\x62'; \/\/ 98$/;"	d
FALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FALOAD	= '\x30'; \/\/ 48$/;"	d
FALSE	$VIRGIL/aeneas/src/types/Bool.v3	/^	def FALSE = Box.new(false);$/;"	d
FALSE_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def FALSE_ENTRY = SsaConstCacheEntry.new(2, Bool.TYPE, Bool.FALSE, Fact.V_ZERO);$/;"	d
FAST	$VIRGIL/aeneas/src/ic/Ic.v3	/^def FAST = 0;$/;"	d
FASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FASTORE	= '\x51'; \/\/ 81$/;"	d
FATAL	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def FATAL		= debugOpt.newBoolOption("fatal", false,$/;"	d
FATAL_CALLS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def FATAL_CALLS		= runOpt.newMatcherOption("fatal-calls",$/;"	d
FCMPG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FCMPG	= '\x96'; \/\/ 150$/;"	d
FCMPL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FCMPL	= '\x95'; \/\/ 149$/;"	d
FCONST_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FCONST_0	= '\x0b'; \/\/ 11$/;"	d
FCONST_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FCONST_1	= '\x0c'; \/\/ 12$/;"	d
FCONST_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FCONST_2	= '\x0d'; \/\/ 13$/;"	d
FDIV	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FDIV	= '\x6e'; \/\/ 110$/;"	d
FLAG_LOAD	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def FLAG_LOAD	= 0x20000000;	\/\/ instruction reads mutable state$/;"	d
FLAG_NO_GAP	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def FLAG_NO_GAP = 0x80000000;	\/\/ cannot insert instructions before this instruction$/;"	d
FLAG_REMAT	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def FLAG_REMAT	= 0x40000000;	\/\/ instruction can be copied for rematerialization$/;"	d
FLAG_STORE	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def FLAG_STORE	= 0x10000000;	\/\/ instruction writes mutable state$/;"	d
FLOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FLOAD	= '\x17'; \/\/ 23$/;"	d
FLOAD_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FLOAD_0	= '\x22'; \/\/ 34$/;"	d
FLOAD_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FLOAD_1	= '\x23'; \/\/ 35$/;"	d
FLOAD_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FLOAD_2	= '\x24'; \/\/ 36$/;"	d
FLOAD_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FLOAD_3	= '\x25'; \/\/ 37$/;"	d
FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def FLOAT   = JvmPrimitive.new("float", "F", "F", KIND_FLOAT);$/;"	d
FLOAT32	$VIRGIL/aeneas/src/types/Float.v3	/^	def FLOAT32 = FloatType.!(FLOAT32_TYPECON.create0());$/;"	d
FLOAT32_TYPECON	$VIRGIL/aeneas/src/types/Float.v3	/^	def FLOAT32_TYPECON = Float_TypeCon.new(8, 23, "float");$/;"	d
FLOAT64	$VIRGIL/aeneas/src/types/Float.v3	/^	def FLOAT64 = FloatType.!(FLOAT64_TYPECON.create0());$/;"	d
FLOAT64_TYPECON	$VIRGIL/aeneas/src/types/Float.v3	/^	def FLOAT64_TYPECON = Float_TypeCon.new(11, 52, "double");$/;"	d
FLOW_END	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def FLOW_END  = 1;$/;"	d
FLOW_NONE	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def FLOW_NONE = 3;$/;"	d
FLOW_RET	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def FLOW_RET  = 2;$/;"	d
FLOW_THRU	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def FLOW_THRU = 0;$/;"	d
FMUL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FMUL	= '\x6a'; \/\/ 106$/;"	d
FNEG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FNEG	= '\x76'; \/\/ 118$/;"	d
FOUR	$VIRGIL/aeneas/src/types/Int.v3	/^	def FOUR      = Box.new(4);$/;"	d
FOUR_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def FOUR_ENTRY = SsaConstCacheEntry.new(6, Int.TYPE, Int.FOUR, Facts.intFacts(4));$/;"	d
FREM	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FREM	= '\x72'; \/\/ 114$/;"	d
FRETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FRETURN		= '\xae'; \/\/ 174$/;"	d
FSTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSTORE	= '\x38'; \/\/ 56$/;"	d
FSTORE_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSTORE_0	= '\x43'; \/\/ 67$/;"	d
FSTORE_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSTORE_1	= '\x44'; \/\/ 68$/;"	d
FSTORE_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSTORE_2	= '\x45'; \/\/ 69$/;"	d
FSTORE_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSTORE_3	= '\x46'; \/\/ 70$/;"	d
FSUB	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def FSUB	= '\x66'; \/\/ 102$/;"	d
FUNCREF	$VIRGIL/aeneas/src/types/Function.v3	/^	def FUNCREF  = Function_TypeCon.new(Kind.FUNCREF);$/;"	d
FUNCTION	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def FUNCTION: byte = 3;	 \/\/ Function declarations$/;"	d
Facts	$VIRGIL/aeneas/src/ir/Facts.v3	/^component Facts {$/;"	n
Fallthrough	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Fallthrough(bi: SsaBlockInfo, vals: Array<SsaInstr>);$/;"	d
FastOp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case FastOp(dst: int, x: int, y: int, op: Operator, opcode: Opcode, src: Source);$/;"	d
FatalCall	$VIRGIL/aeneas/src/v3/V3.v3	/^	def FatalCall     = "FatalCall";$/;"	d
Field	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Field(f: VarExpr);$/;"	d
FieldDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def FieldDeclError(msg: string) {$/;"	m
FileNotFound	$VIRGIL/aeneas/src/main/Error.v3	/^	def FileNotFound(fname: string) {$/;"	m
FilePoint	$VIRGIL/lib/util/Token.v3	/^class FilePoint(fileName: string, beginLine: int, beginColumn: int) {$/;"	c
FileRange	$VIRGIL/lib/util/Token.v3	/^class FileRange extends FilePoint  {$/;"	c
FileRanges	$VIRGIL/aeneas/src/vst/Vst.v3	/^component FileRanges {$/;"	n
FileStream	$VIRGIL/lib/util/IO.v3	/^class FileStream(file: int) extends Stream {$/;"	c
Fixed	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Fixed(v: u1);	\/\/ 0 or 1	is fixed to the given value$/;"	d
Float	$VIRGIL/aeneas/src/types/Float.v3	/^component Float {$/;"	n
Float32Val	$VIRGIL/aeneas/src/types/Float.v3	/^class Float32Val(bits: u32) extends Val {$/;"	c
Float64Val	$VIRGIL/aeneas/src/types/Float.v3	/^class Float64Val(bits: u64) extends Val {$/;"	c
FloatAbs	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatAbs(isDouble: bool);$/;"	d
FloatAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatAdd(isDouble: bool);$/;"	d
FloatBitEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatBitEq(isDouble: bool);$/;"	d
FloatCastD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCastD;$/;"	d
FloatCastI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCastI(isDouble: bool);$/;"	d
FloatCeil	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCeil(isDouble: bool);$/;"	d
FloatConvertIUnsigned	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var FloatConvertIUnsigned = true; \/\/ native support for unsigned int conversions$/;"	d
FloatDiv	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatDiv(isDouble: bool);$/;"	d
FloatEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatEq(isDouble: bool);$/;"	d
FloatExponent	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatExponent;     \/\/ desugared to (u32|u64.view(float|double) >> 23|52) & (0xFF|0x7FF)$/;"	d
FloatFloor	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatFloor(isDouble: bool);$/;"	d
FloatFraction	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatFraction;	\/\/ desugared to (u23|u52).!(u32|u64.view(float|double))$/;"	d
FloatLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^class FloatLiteral extends Literal {$/;"	c
FloatLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatLt(isDouble: bool);$/;"	d
FloatLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatLteq(isDouble: bool);$/;"	d
FloatMul	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatMul(isDouble: bool);$/;"	d
FloatNe	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatNe(isDouble: bool);$/;"	d
FloatOpCache	$VIRGIL/aeneas/src/types/Float.v3	/^class FloatOpCache(ft: FloatType) {$/;"	c
FloatPromoteF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatPromoteF;$/;"	d
FloatPromoteI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatPromoteI(isDouble: bool);$/;"	d
FloatPromoteU64	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var FloatPromoteU64 = true;$/;"	d
FloatQueryD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatQueryD;$/;"	d
FloatQueryI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatQueryI(isDouble: bool);$/;"	d
FloatRound	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRound(isDouble: bool);$/;"	d
FloatRoundD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRoundD;$/;"	d
FloatRoundI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRoundI(isDouble: bool);$/;"	d
FloatSign	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatSign;		\/\/ desugared to u32|u64.view(float|double) >> 31|63$/;"	d
FloatSqrt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatSqrt(isDouble: bool);$/;"	d
FloatSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatSub(isDouble: bool);$/;"	d
FloatType	$VIRGIL/aeneas/src/types/Float.v3	/^class FloatType extends Type {$/;"	c
FloatViewI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatViewI(isDouble: bool);$/;"	d
Float_TypeCon	$VIRGIL/aeneas/src/types/Float.v3	/^class Float_TypeCon extends TypeCon {$/;"	c
ForLessStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ForLessStmt(start: FilePoint, varDecl: VarDecl, lt: Token, expr: Expr, body: Stmt) extends Stmt {$/;"	c
ForStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ForStmt(start: FilePoint, varDecl: VarDecl, cond: Expr, update: Expr, body: Stmt) extends Stmt {$/;"	c
ForeachStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ForeachStmt(start: FilePoint, varDecl: VarDecl, expr: Expr, body: Stmt) extends Stmt {$/;"	c
ForgeClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ForgeClosure;$/;"	d
ForgeRange	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ForgeRange;$/;"	d
FpSketch	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^class FpSketch {$/;"	c
Full	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Full(meth: u20, ex: u4, col: u8, line: u16)	#packing 0b_mmmmmmmm_mmmmmmmm_mmmmeeee_cccccccc_llllllll_llllllll; \/\/ TODO: meth != u20.max$/;"	d
FuncExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class FuncExpr(start: FilePoint, name: Token, params: VstList<ParamDecl>, rettype: ReturnType, body: Stmt) extends Expr {$/;"	c
FuncNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class FuncNorm extends TypeNorm {$/;"	c
FuncRef	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case FuncRef;$/;"	d
FuncType	$VIRGIL/aeneas/src/types/Function.v3	/^class FuncType extends Type {$/;"	c
FuncTypeRef	$VIRGIL/aeneas/src/vst/Vst.v3	/^class FuncTypeRef(paramType: TypeRef, returnType: TypeRef) extends TypeRef {$/;"	c
FuncVal	$VIRGIL/aeneas/src/types/Function.v3	/^class FuncVal(memberRef: IrSpec) extends Val {$/;"	c
Function	$VIRGIL/aeneas/src/types/Function.v3	/^component Function {$/;"	n
Function_TypeCon	$VIRGIL/aeneas/src/types/Function.v3	/^class Function_TypeCon extends TypeCon {$/;"	c
Functions	$VIRGIL/lib/util/Functions.v3	/^component Functions {$/;"	n
GC_EXTMAPS	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_EXTMAPS            = addr("GC_EXTMAPS");$/;"	d
GC_ROOTS_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_ROOTS_END          = addr("GC_ROOTS_END");$/;"	d
GC_ROOTS_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_ROOTS_START        = addr("GC_ROOTS_START");$/;"	d
GC_STACKMAP_PAGES	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_STACKMAP_PAGES     = addr("GC_STACKMAP_PAGES");$/;"	d
GC_STACKMAP_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_STACKMAP_TABLE     = addr("GC_STACKMAP_TABLE");$/;"	d
GC_TYPE_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def GC_TYPE_TABLE         = addr("GC_TYPE_TABLE");$/;"	d
GETFIELD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def GETFIELD		= '\xb4'; \/\/ 180$/;"	d
GETSTATIC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def GETSTATIC		= '\xb2'; \/\/ 178$/;"	d
GLOBAL	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def GLOBAL: byte = 6;	 \/\/ Global declarations$/;"	d
GOTO	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def GOTO	= '\xa7'; \/\/ 167$/;"	d
GOTO_W	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def GOTO_W		= '\xc8'; \/\/ 200$/;"	d
GPR	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def GPR = '\x0e';$/;"	d
GPR	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def GPR = '\x10';$/;"	d
GPRS	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def GPRS = [$/;"	d
GPR_ARRAY	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def GPR_ARRAY = Array<byte>.new(GPR_COUNT);$/;"	d
GPR_CLASS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def GPR_CLASS = set("{gpr}", GPR_ARRAY);$/;"	d
GPR_CLASS	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def GPR_CLASS = '\x15';$/;"	d
GPR_COUNT	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def GPR_COUNT = 14;$/;"	d
GPR_REGS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def GPR_REGS = Array<X86_64Gpr>.new(GPR_COUNT + 1 \/*one unallocatable*\/);$/;"	d
GPRs	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def GPRs = [$/;"	d
GRAY	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def GRAY    = '\x01';$/;"	d
GenVariantEqual	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var GenVariantEqual		= false;$/;"	d
GetBitWidth	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var GetBitWidth: (Compiler, Program, Type) -> byte = defaultGetBitWidth;$/;"	d
GetScalar	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var GetScalar: (Compiler, Program, Type) -> Scalar.set = defaultGetScalar;$/;"	d
GlobMatcher	$VIRGIL/lib/util/GlobMatcher.v3	/^class GlobMatcher(pattern: string) {$/;"	c
GlobalMoveSet	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^class GlobalMoveSet(regSet: MachRegSet) {$/;"	c
GlobalRegAlloc	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^class GlobalRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {$/;"	c
Graph	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^class Graph(varsCnt: int, regSet: MachRegSet) {$/;"	c
Gteq	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Gteq;$/;"	d
Gvn	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^class Gvn(graph: SsaGraph) {$/;"	c
HEAP_CUR_LOC	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def HEAP_CUR_LOC          = addr("heapCurLoc");$/;"	d
HEAP_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def HEAP_END              = addr("HEAP_END");$/;"	d
HEAP_END_LOC	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def HEAP_END_LOC          = addr("heapEndLoc");$/;"	d
HEAP_SIZE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def HEAP_SIZE		= rtOpt.newSizeOption("heap-size", 0,$/;"	d
HEAP_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def HEAP_START            = addr("HEAP_START");$/;"	d
HEAP_START_ADDR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def HEAP_START_ADDR	= rtOpt.newAddrOption("heap-start-addr", 0,$/;"	d
HELP	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def HELP		= actionOpt.newBoolOption("help", false,$/;"	d
HELP2	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def HELP2		= actionOpt.newBoolOption("-help", false,$/;"	d
HashMap	$VIRGIL/lib/util/Map.v3	/^class HashMap<K, V> extends PartialMap<K, V> {$/;"	c
HeapOverflow	$VIRGIL/aeneas/src/v3/V3.v3	/^	def HeapOverflow  = "HeapOverflow";$/;"	d
HexLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^class HexLiteral extends IntLiteral {$/;"	c
I2B	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2B		= '\x91'; \/\/ 145$/;"	d
I2C	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2C		= '\x92'; \/\/ 146$/;"	d
I2D	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2D		= '\x87'; \/\/ 135$/;"	d
I2F	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2F		= '\x86'; \/\/ 134$/;"	d
I2L	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2L		= '\x85'; \/\/ 133$/;"	d
I2S	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def I2S		= '\x93'; \/\/ 147$/;"	d
I32	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case I32;$/;"	d
I32LE	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def I32LE = IntNormalizer.new(32, false);$/;"	d
I32_TYPE	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def I32_TYPE = Int.getType(true, 32);$/;"	d
I64	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case I64;$/;"	d
I64LE	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def I64LE = IntNormalizer.new(64, false);$/;"	d
I64_TYPE	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def I64_TYPE = Int.getType(true, 64);$/;"	d
IADD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IADD	= '\x60'; \/\/ 96$/;"	d
IALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IALOAD	= '\x2e'; \/\/ 46$/;"	d
IAND	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IAND	= '\x7e'; \/\/ 126$/;"	d
IASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IASTORE	= '\x4f'; \/\/ 79$/;"	d
ICONST_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_0	= '\x03'; \/\/ 3$/;"	d
ICONST_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_1	= '\x04'; \/\/ 4$/;"	d
ICONST_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_2	= '\x05'; \/\/ 5$/;"	d
ICONST_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_3	= '\x06'; \/\/ 6$/;"	d
ICONST_4	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_4	= '\x07'; \/\/ 7$/;"	d
ICONST_5	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_5	= '\x08'; \/\/ 8$/;"	d
ICONST_M1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ICONST_M1	= '\x02'; \/\/ 2$/;"	d
IDIV	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IDIV	= '\x6c'; \/\/ 108$/;"	d
IFEQ	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFEQ	= '\x99'; \/\/ 153$/;"	d
IFGE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFGE	= '\x9c'; \/\/ 156$/;"	d
IFGT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFGT	= '\x9d'; \/\/ 157$/;"	d
IFLE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFLE	= '\x9e'; \/\/ 158$/;"	d
IFLT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFLT	= '\x9b'; \/\/ 155$/;"	d
IFNE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFNE	= '\x9a'; \/\/ 154$/;"	d
IFNONNULL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFNONNULL		= '\xc7'; \/\/ 199$/;"	d
IFNULL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IFNULL		= '\xc6'; \/\/ 198$/;"	d
IF_ACMPEQ	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ACMPEQ	= '\xa5'; \/\/ 165$/;"	d
IF_ACMPNE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ACMPNE	= '\xa6'; \/\/ 166$/;"	d
IF_ICMPEQ	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPEQ	= '\x9f'; \/\/ 159$/;"	d
IF_ICMPGE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPGE	= '\xa2'; \/\/ 162$/;"	d
IF_ICMPGT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPGT	= '\xa3'; \/\/ 163$/;"	d
IF_ICMPLE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPLE	= '\xa4'; \/\/ 164$/;"	d
IF_ICMPLT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPLT	= '\xa1'; \/\/ 161$/;"	d
IF_ICMPNE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IF_ICMPNE	= '\xa0'; \/\/ 160$/;"	d
IINC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IINC	= '\x84'; \/\/ 132$/;"	d
ILOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ILOAD	= '\x15'; \/\/ 21$/;"	d
ILOAD_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ILOAD_0	= '\x1a'; \/\/ 26$/;"	d
ILOAD_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ILOAD_1	= '\x1b'; \/\/ 27$/;"	d
ILOAD_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ILOAD_2	= '\x1c'; \/\/ 28$/;"	d
ILOAD_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ILOAD_3	= '\x1d'; \/\/ 29$/;"	d
IMPORT	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def IMPORT: byte = 2;	 \/\/ Import declarations$/;"	d
IMUL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IMUL	= '\x68'; \/\/ 104$/;"	d
INDEX_0	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^def INDEX_0 = [0];$/;"	d
INDEX_00	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^def INDEX_00 = [0];$/;"	d
INEG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INEG	= '\x74'; \/\/ 116$/;"	d
INITIAL	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^def INITIAL = 8;$/;"	d
INITIAL_MSIZE	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^def INITIAL_MSIZE = 16;$/;"	d
INITIAL_VALUES	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^def INITIAL_VALUES = 128;$/;"	d
INLINE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def INLINE		= sharedOpt.newMatcherOption("inline",$/;"	d
INSTANCEOF	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INSTANCEOF		= '\xc1'; \/\/ 193$/;"	d
INSTR_COVERAGE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def INSTR_COVERAGE	= runOpt.newBoolOption("icoverage", false,$/;"	d
INSTR_PROFILE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def INSTR_PROFILE	= runOpt.newMatcherOption("iprofile",$/;"	d
INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def INT     = JvmPrimitive.new("int", "I", "I", KIND_INT);$/;"	d
INT_INT	$VIRGIL/aeneas/src/ic/Ic.v3	/^def INT_INT = Tuple.newType(List.new(Int.TYPE, List.new(Type.!(Int.TYPE), null)));$/;"	d
INVALID	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def INVALID = -1;$/;"	d
INVOKEINTERFACE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INVOKEINTERFACE	= '\xb9'; \/\/ 185$/;"	d
INVOKESPECIAL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INVOKESPECIAL	= '\xb7'; \/\/ 183$/;"	d
INVOKESTATIC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INVOKESTATIC	= '\xb8'; \/\/ 184$/;"	d
INVOKEVIRTUAL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def INVOKEVIRTUAL	= '\xb6'; \/\/ 182$/;"	d
IN_CYCLE	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def IN_CYCLE: i8 = -2;$/;"	d
IN_CYCLE	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def IN_CYCLE: i8 = -2;$/;"	d
IN_CYCLE	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^def IN_CYCLE = -2;$/;"	d
IOR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IOR		= '\x80'; \/\/ 128$/;"	d
IREM	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IREM	= '\x70'; \/\/ 112$/;"	d
IRETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IRETURN		= '\xac'; \/\/ 172$/;"	d
IR_ALLOC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def IR_ALLOC		= rtOpt.newBoolOption("ir-alloc", false,$/;"	d
ISHL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISHL	= '\x78'; \/\/ 120$/;"	d
ISHR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISHR	= '\x7a'; \/\/ 122$/;"	d
ISTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISTORE	= '\x36'; \/\/ 54$/;"	d
ISTORE_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISTORE_0	= '\x3b'; \/\/ 59$/;"	d
ISTORE_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISTORE_1	= '\x3c'; \/\/ 60$/;"	d
ISTORE_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISTORE_2	= '\x3d'; \/\/ 61$/;"	d
ISTORE_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISTORE_3	= '\x3e'; \/\/ 62$/;"	d
ISUB	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def ISUB	= '\x64'; \/\/ 100$/;"	d
IS_64	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def IS_64: int = 0x40000000;$/;"	d
IS_DECIMAL	$VIRGIL/aeneas/src/util/Char.v3	/^	def IS_DECIMAL      = '\x20';$/;"	d
IS_HEX	$VIRGIL/aeneas/src/util/Char.v3	/^	def IS_HEX          = '\x10';$/;"	d
IS_IDENT_MIDDLE	$VIRGIL/aeneas/src/util/Char.v3	/^	def IS_IDENT_MIDDLE = '\x80';$/;"	d
IS_IDENT_START	$VIRGIL/aeneas/src/util/Char.v3	/^	def IS_IDENT_START  = '\x40';$/;"	d
IUSHR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IUSHR	= '\x7c'; \/\/ 124$/;"	d
IXOR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def IXOR	= '\x82'; \/\/ 130$/;"	d
I_ADCD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADCD	= 0x03;		def I_ADCQ	= 0x13;$/;"	d
I_ADCQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADCD	= 0x03;		def I_ADCQ	= 0x13;$/;"	d
I_ADDD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADDD	= 0x01;		def I_ADDQ	= 0x11;$/;"	d
I_ADDQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADDD	= 0x01;		def I_ADDQ	= 0x11;$/;"	d
I_ADDSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADDSS	= 0x26;		def I_ADDSD	= 0x36;$/;"	d
I_ADDSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ADDSS	= 0x26;		def I_ADDSD	= 0x36;$/;"	d
I_ANDD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ANDD	= 0x04;		def I_ANDQ	= 0x14;$/;"	d
I_ANDQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ANDD	= 0x04;		def I_ANDQ	= 0x14;$/;"	d
I_CALL	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CALL		= 0x69;$/;"	d
I_CALLER_IP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CALLER_IP		= 0x6A;$/;"	d
I_CALLER_SP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CALLER_SP		= 0x6B;$/;"	d
I_CDQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CDQ	= 0x24;		def I_CQO	= 0x34;$/;"	d
I_CMPB	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPB		= 0x6F;$/;"	d
I_CMPD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPD	= 0x07;		def I_CMPQ	= 0x17;$/;"	d
I_CMPQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPD	= 0x07;		def I_CMPQ	= 0x17;$/;"	d
I_CMPXCHG16	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPXCHG16		= 0x73;$/;"	d
I_CMPXCHG32	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPXCHG32		= 0x74;$/;"	d
I_CMPXCHG64	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPXCHG64		= 0x75;$/;"	d
I_CMPXCHG8	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CMPXCHG8		= 0x72;$/;"	d
I_CQO	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CDQ	= 0x24;		def I_CQO	= 0x34;$/;"	d
I_CVTSD2SID	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSD2SID	= 0x41;		def I_CVTSD2SIQ = 0x51;$/;"	d
I_CVTSD2SIQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSD2SID	= 0x41;		def I_CVTSD2SIQ = 0x51;$/;"	d
I_CVTSD2SS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSS2SD	= 0x2C;		def I_CVTSD2SS	= 0x3C;$/;"	d
I_CVTSI2SDD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSI2SDD	= 0x43;		def I_CVTSI2SDQ = 0x53;$/;"	d
I_CVTSI2SDQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSI2SDD	= 0x43;		def I_CVTSI2SDQ = 0x53;$/;"	d
I_CVTSI2SSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSI2SSD	= 0x42;		def I_CVTSI2SSQ = 0x52;$/;"	d
I_CVTSI2SSQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSI2SSD	= 0x42;		def I_CVTSI2SSQ = 0x52;$/;"	d
I_CVTSS2SD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSS2SD	= 0x2C;		def I_CVTSD2SS	= 0x3C;$/;"	d
I_CVTSS2SID	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSS2SID	= 0x40;		def I_CVTSS2SIQ = 0x50;$/;"	d
I_CVTSS2SIQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_CVTSS2SID	= 0x40;		def I_CVTSS2SIQ = 0x50;$/;"	d
I_DECD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DECD	= 0x20;		def I_DECQ	= 0x30;$/;"	d
I_DECQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DECD	= 0x20;		def I_DECQ	= 0x30;$/;"	d
I_DIVD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DIVD	= 0x0D;		def I_DIVQ	= 0x1D;$/;"	d
I_DIVQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DIVD	= 0x0D;		def I_DIVQ	= 0x1D;$/;"	d
I_DIVSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DIVSS	= 0x29;		def I_DIVSD	= 0x39;$/;"	d
I_DIVSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_DIVSS	= 0x29;		def I_DIVSD	= 0x39;$/;"	d
I_IDIVD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_IDIVD	= 0x0E;		def I_IDIVQ	= 0x1E;$/;"	d
I_IDIVQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_IDIVD	= 0x0E;		def I_IDIVQ	= 0x1E;$/;"	d
I_INCD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_INCD	= 0x0F;		def I_INCQ	= 0x1F;$/;"	d
I_INCQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_INCD	= 0x0F;		def I_INCQ	= 0x1F;$/;"	d
I_JC	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_JC		= 0x67;$/;"	d
I_JMP	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_JMP		= 0x66;$/;"	d
I_LEAD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_LEAD	= 0x0C;		def I_LEAQ	= 0x1C;$/;"	d
I_LEAQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_LEAD	= 0x0C;		def I_LEAQ	= 0x1C;$/;"	d
I_MOVB	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVB		= 0x60;$/;"	d
I_MOVBSX	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVBSX		= 0x61;$/;"	d
I_MOVBZX	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVBZX		= 0x62;$/;"	d
I_MOVD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVD		= 0x76;$/;"	d
I_MOVQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVQ		= 0x77;$/;"	d
I_MOVSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVSS	= 0x2B;		def I_MOVSD	= 0x3B;$/;"	d
I_MOVSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVSS	= 0x2B;		def I_MOVSD	= 0x3B;$/;"	d
I_MOVW	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVW		= 0x63;$/;"	d
I_MOVWSX	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVWSX		= 0x64;$/;"	d
I_MOVWZX	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MOVWZX		= 0x65;$/;"	d
I_MULD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MULD	= 0x08;		def I_MULQ	= 0x18;$/;"	d
I_MULQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MULD	= 0x08;		def I_MULQ	= 0x18;$/;"	d
I_MULSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MULSS	= 0x28;		def I_MULSD	= 0x38;$/;"	d
I_MULSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_MULSS	= 0x28;		def I_MULSD	= 0x38;$/;"	d
I_NEGD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_NEGD	= 0x09;		def I_NEGQ	= 0x19;$/;"	d
I_NEGQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_NEGD	= 0x09;		def I_NEGQ	= 0x19;$/;"	d
I_NOTD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_NOTD	= 0x0A;		def I_NOTQ	= 0x1A;$/;"	d
I_NOTQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_NOTD	= 0x0A;		def I_NOTQ	= 0x1A;$/;"	d
I_ORD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ORD	= 0x02;		def I_ORQ	= 0x12;$/;"	d
I_ORQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ORD	= 0x02;		def I_ORQ	= 0x12;$/;"	d
I_PCMPEQD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PCMPEQD	= 0x2D;		def I_PCMPEQQ	= 0x3D;$/;"	d
I_PCMPEQQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PCMPEQD	= 0x2D;		def I_PCMPEQQ	= 0x3D;$/;"	d
I_PSLLD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PSLLD	= 0x46;		def I_PSLLQ	= 0x56;$/;"	d
I_PSLLQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PSLLD	= 0x46;		def I_PSLLQ	= 0x56;$/;"	d
I_PSRLD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PSRLD	= 0x47;		def I_PSRLQ	= 0x57;$/;"	d
I_PSRLQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_PSRLD	= 0x47;		def I_PSRLQ	= 0x57;$/;"	d
I_QD_DIFF	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_QD_DIFF = I_ADDQ - I_ADDD; \/\/ Used to compute 64-bit opcode from 32-bit opcode$/;"	d
I_ROUNDSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ROUNDSS	= 0x45;		def I_ROUNDSD	= 0x55;$/;"	d
I_ROUNDSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_ROUNDSS	= 0x45;		def I_ROUNDSD	= 0x55;$/;"	d
I_SARD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SARD	= 0x22;		def I_SARQ	= 0x32;$/;"	d
I_SARQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SARD	= 0x22;		def I_SARQ	= 0x32;$/;"	d
I_SETC	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SETC		= 0x68;$/;"	d
I_SHLD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SHLD	= 0x21;		def I_SHLQ	= 0x31;$/;"	d
I_SHLQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SHLD	= 0x21;		def I_SHLQ	= 0x31;$/;"	d
I_SHRD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SHRD	= 0x23;		def I_SHRQ	= 0x33;$/;"	d
I_SHRQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SHRD	= 0x23;		def I_SHRQ	= 0x33;$/;"	d
I_SQRTSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SQRTSS	= 0x2A;		def I_SQRTSD	= 0x3A;$/;"	d
I_SQRTSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SQRTSS	= 0x2A;		def I_SQRTSD	= 0x3A;$/;"	d
I_SUBD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SUBD	= 0x05;		def I_SUBQ	= 0x15;$/;"	d
I_SUBQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SUBD	= 0x05;		def I_SUBQ	= 0x15;$/;"	d
I_SUBSD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SUBSS	= 0x27;		def I_SUBSD	= 0x37;$/;"	d
I_SUBSS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SUBSS	= 0x27;		def I_SUBSD	= 0x37;$/;"	d
I_SWITCHD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SWITCHD	= 0x25;		def I_SWITCHQ	= 0x35;$/;"	d
I_SWITCHQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SWITCHD	= 0x25;		def I_SWITCHQ	= 0x35;$/;"	d
I_SYSCALL	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_SYSCALL		= 0x78;$/;"	d
I_TESTD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_TESTD	= 0x0B;		def I_TESTQ	= 0x1B;$/;"	d
I_TESTQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_TESTD	= 0x0B;		def I_TESTQ	= 0x1B;$/;"	d
I_TEST_ALLOC	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_TEST_ALLOC	= 0x6C;$/;"	d
I_THROW	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_THROW		= 0x70;$/;"	d
I_THROWC	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_THROWC		= 0x71;$/;"	d
I_TRUNCD_U64	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_TRUNCS_U64 = 0x48;	def I_TRUNCD_U64 = 0x58;$/;"	d
I_TRUNCS_U64	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_TRUNCS_U64 = 0x48;	def I_TRUNCD_U64 = 0x58;$/;"	d
I_UCOMISD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_UCOMISS	= 0x2F;		def I_UCOMISD	= 0x3F;$/;"	d
I_UCOMISS	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_UCOMISS	= 0x2F;		def I_UCOMISD	= 0x3F;$/;"	d
I_XORD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_XORD	= 0x06;		def I_XORQ	= 0x16;$/;"	d
I_XORQ	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def I_XORD	= 0x06;		def I_XORQ	= 0x16;$/;"	d
IcAssembler	$VIRGIL/aeneas/src/ic/Ic.v3	/^class IcAssembler(code: Vector<IcInstr>) {$/;"	c
IcCallTracer	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^class IcCallTracer(matcher: VstMatcher, traceParent: bool) {$/;"	c
IcCoverage	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^class IcCoverage(compiler: Compiler, prog: Program, instr: bool) {$/;"	c
IcFrame	$VIRGIL/aeneas/src/ic/Ic.v3	/^class IcFrame {$/;"	c
IcInstr	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IcInstr {$/;"	c
IcInstr.Apply	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Apply(dst: int, op: Operator, args: Array<int>, src: Source);$/;"	c
IcInstr.Branch	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Branch(always: bool, bval: bool, arg: int, target: int);$/;"	c
IcInstr.Call	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Call(dst: int, func: int, args: Array<int>, src: Source);$/;"	c
IcInstr.FastOp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case FastOp(dst: int, x: int, y: int, op: Operator, opcode: Opcode, src: Source);$/;"	c
IcInstr.Int32Binop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Binop(dst: int, x: int, y: int, opcode: IntBinop, src: Source);$/;"	c
IcInstr.Int32Compare	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Compare(dst: int, x: int, y: int, opcode: IntCompare, src: Source);$/;"	c
IcInstr.Int32Unop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Unop(dst: int, x: int, shift: u5, opcode: IntUnop, src: Source);$/;"	c
IcInstr.Int64Binop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Binop(dst: int, x: int, y: int, lsigned: bool, rsigned: bool, opcode: IntBinop, src: Source);$/;"	c
IcInstr.Int64Compare	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Compare(dst: int, x: int, y: int, lsigned: bool, rsigned: bool, opcode: IntCompare, src: Source);$/;"	c
IcInstr.Int64Unop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Unop(dst: int, x: int, shift: u6, signed: bool, opcode: IntUnop, src: Source);$/;"	c
IcInstr.Move	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Move(dst: int, src: int);$/;"	c
IcInstr.Probe	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Probe(orig: IcInstr, probes: IcProbes);$/;"	c
IcInstr.Ret	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Ret(arg: int);$/;"	c
IcInstr.Switch	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Switch(arg: int, targets: Array<int>);$/;"	c
IcInstr.Throw	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Throw(exception: string, src: Source);$/;"	c
IcInstrProfiler	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^class IcInstrProfiler {$/;"	c
IcInterpreter	$VIRGIL/aeneas/src/ic/Ic.v3	/^class IcInterpreter(prog: Program, compile: IrSpec -> IcMethod) extends Arguments {$/;"	c
IcMethod	$VIRGIL/aeneas/src/ic/Ic.v3	/^class IcMethod(memberRef: IrSpec, iccode: Array<IcInstr>, numParams: int, consts: (int, Array<Val>), numRegs: int) {$/;"	c
IcMethodProf	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^class IcMethodProf(icm: IcMethod) {$/;"	c
IcPrinter	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^class IcPrinter(interp: IcInterpreter) {$/;"	c
IcProbes	$VIRGIL/aeneas/src/ic/Ic.v3	/^class IcProbes {$/;"	c
IcTracer	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^class IcTracer {$/;"	c
IcTreeProfiler	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^class IcTreeProfiler extends TreeProfiler<IcFrame> {$/;"	c
IfExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class IfExpr(start: FilePoint, exprs: VstList<Expr>) extends Expr {$/;"	c
IfStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class IfStmt(start: FilePoint, cond: Expr, tbranch: Stmt, fbranch: Stmt) extends Stmt {$/;"	c
Imm8	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case Imm8(val: u8, rot: u4);$/;"	d
Immediate	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Immediate(val: Val);$/;"	d
Implicit	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Implicit(expr: Expr);	\/\/ => expr$/;"	d
ImplicitNullChecks	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var ImplicitNullChecks = true;	 \/\/ nullchecks implicit with loads+stores$/;"	d
ImportError	$VIRGIL/aeneas/src/main/Error.v3	/^	def ImportError(msg: string) {$/;"	m
IndexDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def IndexDeclError(msg: string) {$/;"	m
IndexExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class IndexExpr(expr: Expr, exprs: VstList<Expr>) extends Expr {$/;"	c
InetAddress	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^type InetAddress {$/;"	c
InetAddress.Ipv4	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Ipv4(oct0: u8, oct1: u8, oct2: u8, oct3: u8);$/;"	c
InetAddress.Ipv6	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Ipv6(word0: u32, word1: u32, word2: u32, word3: u32);$/;"	c
InfixOp	$VIRGIL/aeneas/src/vst/Vst.v3	/^class InfixOp(token: Token, infix: V3Infix, prec: byte, assign: bool) {$/;"	c
InheritanceError	$VIRGIL/aeneas/src/main/Error.v3	/^	def InheritanceError(msg: string) {$/;"	m
InheritanceError2	$VIRGIL/aeneas/src/main/Error.v3	/^	def InheritanceError2(msg: string, t1: Type, t2: Type) {$/;"	m
Init	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case Init(method: IrMethod);$/;"	d
InlineEarly	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var InlineEarly			= flags.get("InlineEarly", level >= 3);$/;"	d
Inst	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Inst(op: Operator, typeParams: List<TypeParamType>);$/;"	d
Int	$VIRGIL/aeneas/src/types/Int.v3	/^component Int {$/;"	n
Int16Arith	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int16Arith = false;		 \/\/ native support for int16 arithmetic$/;"	d
Int16LoadSignExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int16LoadSignExtend = true;	 \/\/ loading 16 bits can sign extend$/;"	d
Int16LoadZeroExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int16LoadZeroExtend = true;	 \/\/ loading 16 bits can zero extend$/;"	d
Int16StoreNarrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int16StoreNarrow = true;	 \/\/ storing > 16 bits can narrow$/;"	d
Int32Arith	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int32Arith = true;		 \/\/ native support for int32 arithmetic$/;"	d
Int32Binop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Binop(dst: int, x: int, y: int, opcode: IntBinop, src: Source);$/;"	d
Int32Compare	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Compare(dst: int, x: int, y: int, opcode: IntCompare, src: Source);$/;"	d
Int32LoadSignExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int32LoadSignExtend = true;	 \/\/ loading 32 bits can sign extend to 64$/;"	d
Int32LoadZeroExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int32LoadZeroExtend = true;	 \/\/ loading 32 bits can zero extend to 64$/;"	d
Int32ShiftSaturate	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int32ShiftSaturate = false;	 \/\/ shift saturates on overflow$/;"	d
Int32StoreNarrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int32StoreNarrow = true;	 \/\/ storing > 32 bits can narrow$/;"	d
Int32Unop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int32Unop(dst: int, x: int, shift: u5, opcode: IntUnop, src: Source);$/;"	d
Int64Arith	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int64Arith = false;		 \/\/ native support for int64 arithmetic$/;"	d
Int64Binop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Binop(dst: int, x: int, y: int, lsigned: bool, rsigned: bool, opcode: IntBinop, src: Source);$/;"	d
Int64Compare	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Compare(dst: int, x: int, y: int, lsigned: bool, rsigned: bool, opcode: IntCompare, src: Source);$/;"	d
Int64Unop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Int64Unop(dst: int, x: int, shift: u6, signed: bool, opcode: IntUnop, src: Source);$/;"	d
Int8Arith	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int8Arith = false;		 \/\/ native support for int8 arithmetic$/;"	d
Int8LoadSignExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int8LoadSignExtend = true;	 \/\/ loading 8 bits can sign extend$/;"	d
Int8LoadZeroExtend	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int8LoadZeroExtend = true;	 \/\/ loading 8 bits can zero extend$/;"	d
Int8StoreNarrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var Int8StoreNarrow = true;	 \/\/ storing > 8 bits can narrow$/;"	d
IntAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntAdd;$/;"	d
IntAdd	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntAdd;$/;"	d
IntAnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntAnd;$/;"	d
IntAnd	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntAnd;$/;"	d
IntBinop	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IntBinop {$/;"	c
IntBinop.IntAdd	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntAdd;$/;"	c
IntBinop.IntAnd	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntAnd;$/;"	c
IntBinop.IntDivS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntDivS;$/;"	c
IntBinop.IntDivU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntDivU;$/;"	c
IntBinop.IntModS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntModS;$/;"	c
IntBinop.IntModU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntModU;$/;"	c
IntBinop.IntMul	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntMul;$/;"	c
IntBinop.IntOr	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntOr;$/;"	c
IntBinop.IntSar	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntSar;$/;"	c
IntBinop.IntShl	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntShl;$/;"	c
IntBinop.IntShr	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntShr;$/;"	c
IntBinop.IntSub	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntSub;$/;"	c
IntBinop.IntXor	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntXor;$/;"	c
IntBitwiseNeg	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntBitwiseNeg;	\/\/ desugared to (-1 ^ a)$/;"	d
IntCastF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntCastF(isDouble: bool);$/;"	d
IntCastFTraps	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntCastFTraps = false;	\/\/ IntCastF machine instruction traps$/;"	d
IntCompare	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IntCompare {$/;"	c
IntCompare.IntEq	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntEq;$/;"	c
IntCompare.IntLtS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLtS;$/;"	c
IntCompare.IntLtU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLtU;$/;"	c
IntCompare.IntLteqS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLteqS;$/;"	c
IntCompare.IntLteqU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLteqU;$/;"	c
IntConvertFMapsNanToZero	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntConvertFMapsNanToZero = true;$/;"	d
IntConvertFNegSaturates	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntConvertFNegSaturates = true; \/\/ proper negative saturation$/;"	d
IntConvertFPosSaturates	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntConvertFPosSaturates = true; \/\/ proper positive saturation$/;"	d
IntConvertFUnsigned	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntConvertFUnsigned = true;	 \/\/ native support for unsigned float conversions$/;"	d
IntDiv	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntDiv;$/;"	d
IntDivOverflowMinint	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntDivOverflowMinint = true; \/\/ int division overflow is minint$/;"	d
IntDivS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntDivS;$/;"	d
IntDivU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntDivU;$/;"	d
IntDivZeroTraps	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var IntDivZeroTraps = true;	 \/\/ int division traps on zero$/;"	d
IntEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntEq;$/;"	d
IntEq	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntEq;$/;"	d
IntLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^class IntLiteral extends Literal {$/;"	c
IntLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntLt;$/;"	d
IntLtS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLtS;$/;"	d
IntLtU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLtU;$/;"	d
IntLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntLteq;$/;"	d
IntLteqS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLteqS;$/;"	d
IntLteqU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntLteqU;$/;"	d
IntMixedEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedEqual;	\/\/ desugared to multiple comparisons$/;"	d
IntMixedLt	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedLt;	\/\/ desugared to multiple comparisons$/;"	d
IntMixedLteq	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedLteq;	\/\/ desugared to multiple comparisons$/;"	d
IntMixedNotEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedNotEqual;	\/\/ desugared to multiple comparisons$/;"	d
IntMod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntMod;$/;"	d
IntModS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntModS;$/;"	d
IntModU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntModU;$/;"	d
IntMul	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntMul;$/;"	d
IntMul	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntMul;$/;"	d
IntNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class IntNorm extends TypeNorm {$/;"	c
IntNormalizer	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^class IntNormalizer(width: byte, bigEndian: bool) {$/;"	c
IntNormalizers	$VIRGIL/aeneas/src/ir/Reachability.v3	/^component IntNormalizers {$/;"	n
IntOpCache	$VIRGIL/aeneas/src/types/Int.v3	/^class IntOpCache(it: IntType) {$/;"	c
IntOr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntOr;$/;"	d
IntOr	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntOr;$/;"	d
IntQueryF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntQueryF(isDouble: bool);$/;"	d
IntRep	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^component IntRep {$/;"	n
IntRepCreate	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntRepCreate;$/;"	d
IntRepType	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^class IntRepType extends IntType {$/;"	c
IntRepView	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntRepView;$/;"	d
IntRep_TypeCon	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^class IntRep_TypeCon extends TypeCon {$/;"	c
IntSar	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntSar;$/;"	d
IntSar	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntSar;$/;"	d
IntShl	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntShl;$/;"	d
IntShl	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntShl;$/;"	d
IntShr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntShr;$/;"	d
IntShr	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntShr;$/;"	d
IntSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntSub;$/;"	d
IntSub	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntSub;$/;"	d
IntToLongS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntToLongS;$/;"	d
IntToLongU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntToLongU;$/;"	d
IntTruncF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntTruncF(isDouble: bool);$/;"	d
IntType	$VIRGIL/aeneas/src/types/Int.v3	/^class IntType extends Type {$/;"	c
IntUnop	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IntUnop {$/;"	c
IntUnop.IntToLongS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntToLongS;$/;"	c
IntUnop.IntToLongU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntToLongU;$/;"	c
IntUnop.IntWrapS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntWrapS;$/;"	c
IntUnop.IntWrapU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntWrapU;$/;"	c
IntUnop.LongToInt	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case LongToInt;$/;"	c
IntView	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntView;		\/\/ desugared to IntConvert or FloatToBits$/;"	d
IntViewF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntViewF(isDouble: bool);$/;"	d
IntViewI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntViewI;$/;"	d
IntWide	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntWide(op: Operator);$/;"	d
IntWrapS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntWrapS;$/;"	d
IntWrapU	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntWrapU;$/;"	d
IntXor	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntXor;$/;"	d
IntXor	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case IntXor;$/;"	d
Int_TypeCon	$VIRGIL/aeneas/src/types/Int.v3	/^class Int_TypeCon extends TypeCon {$/;"	c
InternalError	$VIRGIL/aeneas/src/v3/V3.v3	/^	def InternalError = "InternalError";$/;"	d
Interval	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type Interval(start: byte, end: byte) #unboxed {$/;"	c
IntervalBuilder	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class IntervalBuilder(gen: OldCodeGen, regSet: MachRegSet) {$/;"	c
IntervalPrinter	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class IntervalPrinter($/;"	c
Ints	$VIRGIL/lib/util/Ints.v3	/^component Ints {$/;"	n
InvalidThisUse	$VIRGIL/aeneas/src/main/Error.v3	/^	def InvalidThisUse() {$/;"	m
Ipv4	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Ipv4(oct0: u8, oct1: u8, oct2: u8, oct3: u8);$/;"	d
Ipv6	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Ipv6(word0: u32, word1: u32, word2: u32, word3: u32);$/;"	d
IrAlloc	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var IrAlloc			= CLOptions.IR_ALLOC.get();$/;"	d
IrBuilder	$VIRGIL/aeneas/src/ir/VstIr.v3	/^class IrBuilder(ctype: Type, parent: IrClass) {$/;"	c
IrClass	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrClass extends IrItem {$/;"	c
IrField	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrField extends IrMember {$/;"	c
IrItem	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrItem {$/;"	c
IrMember	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrMember(receiver: Type) extends IrItem {$/;"	c
IrMethod	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrMethod extends IrMember {$/;"	c
IrModule	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrModule {$/;"	c
IrMtable	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrMtable(root: IrMethod, rootId: int, table: Array<IrMethod>) extends IrItem {$/;"	c
IrOpMethodBuilder	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^class IrOpMethodBuilder(prog: Program) {$/;"	c
IrPrinter	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^class IrPrinter(prog: Program) {$/;"	c
IrRoot	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrRoot(name: string, spec: IrSpec) { }$/;"	c
IrSelector	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrSelector extends IrMember {$/;"	c
IrSpec	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrSpec(receiver: Type, typeArgs: Array<Type>, member: IrMember) {$/;"	c
IrSpecTypes	$VIRGIL/aeneas/src/ir/Ir.v3	/^class IrSpecTypes(typeArgsList: List<TypeArgs>, methodTypeArgs: TypeArgs) {$/;"	c
IrUtil	$VIRGIL/aeneas/src/ir/Ir.v3	/^component IrUtil {$/;"	n
JARFile	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^class JARFile(fileName: string) {$/;"	c
JARFileFile	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^class JARFileFile(name: string) extends Stream {$/;"	c
JSR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def JSR		= '\xa8'; \/\/ 168$/;"	d
JSR_W	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def JSR_W		= '\xc9'; \/\/ 201$/;"	d
JVM_ARGS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def JVM_ARGS		= jvmOpt.newStringOption("jvm.args", null,$/;"	d
JVM_GEN_SCRIPT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def JVM_GEN_SCRIPT	= jvmOpt.newBoolOption("jvm.script", false,$/;"	d
JVM_RT_PATH	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def JVM_RT_PATH		= jvmOpt.newStringOption("jvm.rt-path", null,$/;"	d
JvmArray_Type	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmArray_Type extends JvmType {$/;"	c
JvmAttribute	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmAttribute extends JvmClassItem {$/;"	c
JvmBytecode	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^component JvmBytecode {$/;"	n
JvmClass	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmClass extends JvmType {$/;"	c
JvmClassGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmClassGen(builder: JvmClassfileBuilder) {$/;"	c
JvmClassItem	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmClassItem {$/;"	c
JvmClassfile	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmClassfile(className: string, superName: string) {$/;"	c
JvmClassfileBuilder	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^class JvmClassfileBuilder(jprog: JvmProgram, jclass: JvmClass) {$/;"	c
JvmCodeAttribute	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCodeAttribute extends JvmAttribute {$/;"	c
JvmCodeBuilder	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^class JvmCodeBuilder(builder: JvmClassfileBuilder) {$/;"	c
JvmComponent	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^component JvmComponent {$/;"	n
JvmConstant	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^component JvmConstant {$/;"	n
JvmCpe	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe extends JvmClassItem {$/;"	c
JvmCpe_Class	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Class(name_index: int) extends JvmCpe {$/;"	c
JvmCpe_Double	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Double(bytes: u64) extends JvmCpe {$/;"	c
JvmCpe_Empty	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Empty() extends JvmCpe {$/;"	c
JvmCpe_Fieldref	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Fieldref(class_index: int, name_and_type_index: int) extends JvmCpe {$/;"	c
JvmCpe_Float	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Float(bytes: u32) extends JvmCpe {$/;"	c
JvmCpe_Integer	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Integer(bytes: int) extends JvmCpe {$/;"	c
JvmCpe_InterfaceMethodref	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_InterfaceMethodref(class_index: int, name_and_type_index: int) extends JvmCpe {$/;"	c
JvmCpe_Long	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Long(bytes: long) extends JvmCpe {$/;"	c
JvmCpe_Methodref	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Methodref(class_index: int, name_and_type_index: int) extends JvmCpe {$/;"	c
JvmCpe_NameAndType	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_NameAndType(name_index: int, descriptor_index: int) extends JvmCpe {$/;"	c
JvmCpe_String	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_String(string_index: int) extends JvmCpe {$/;"	c
JvmCpe_Utf8	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmCpe_Utf8 extends JvmCpe {$/;"	c
JvmField	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmField extends JvmMember {$/;"	c
JvmHI	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI {$/;"	c
JvmHI_ArrayIndex	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_ArrayIndex(index: int) extends JvmHI {$/;"	c
JvmHI_ArrayStore	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_ArrayStore(jtype: JvmType) extends JvmHI {$/;"	c
JvmHI_CycleRef	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_CycleRef(instr: JvmHI_Ref, index: int) { }$/;"	c
JvmHI_InitObject	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_InitObject(rec: JvmHI_Record, mname: string, sig: JvmSig) extends JvmHI {$/;"	c
JvmHI_Load	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_Load(rval: Record, jtype: JvmType) extends JvmHI {$/;"	c
JvmHI_NewArray	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_NewArray extends JvmHI_Ref {$/;"	c
JvmHI_Record	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_Record extends JvmHI_Ref {$/;"	c
JvmHI_Ref	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_Ref(jtype: JvmType) extends JvmHI {$/;"	c
JvmHI_String	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_String(rec: JvmHI_Record, str: Array<byte>) extends JvmHI_Ref(JvmTypes.CHAR) {$/;"	c
JvmHI_UselessArray	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_UselessArray(rec: JvmHI_Record, length: int) extends JvmHI {$/;"	c
JvmHI_Value	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHI_Value(val: Val, vtype: Type) extends JvmHI {$/;"	c
JvmHeap	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^class JvmHeap(jprog: JvmProgram) {$/;"	c
JvmKind	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmKind($/;"	c
JvmMember	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmMember(name_index: int, descriptor_index: int) extends JvmClassItem {$/;"	c
JvmMethod	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^class JvmMethod extends JvmMember {$/;"	c
JvmPrimitive	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmPrimitive extends JvmType {$/;"	c
JvmProgram	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmProgram(compiler: Compiler, prog: Program) {$/;"	c
JvmSig	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmSig(paramTypes: Array<JvmType>, returnType: JvmType) {$/;"	c
JvmTarget	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^class JvmTarget extends Target {$/;"	c
JvmType	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^class JvmType(name: string, kind: JvmKind) {$/;"	c
JvmTypeReps	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^class JvmTypeReps(jprog: JvmProgram) {$/;"	c
JvmTypes	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^component JvmTypes {$/;"	n
JvmV3AbstractClosureGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3AbstractClosureGen extends JvmClassGen {$/;"	c
JvmV3ClassGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3ClassGen extends JvmClassGen {$/;"	c
JvmV3ClosureAdapterGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3ClosureAdapterGen extends JvmClassGen {$/;"	c
JvmV3ClosureGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3ClosureGen extends JvmClassGen {$/;"	c
JvmV3ComponentGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3ComponentGen extends JvmClassGen {$/;"	c
JvmV3TupleGen	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^class JvmV3TupleGen extends JvmClassGen {$/;"	c
KC_FALSE	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_FALSE = '\x03';$/;"	d
KC_NULL	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_NULL  = '\x04';$/;"	d
KC_OTHER	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_OTHER = '\x01';$/;"	d
KC_PACKING	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_PACKING = '\x06';$/;"	d
KC_TRUE	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_TRUE  = '\x02';$/;"	d
KC_VAR	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def KC_VAR   = '\x05';$/;"	d
KERNEL_CALL_RETURN	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def KERNEL_CALL_RETURN = Tuple.newType(Lists.cons2(Long.TYPE, Long.TYPE));$/;"	d
KERNEL_CALL_RETURN	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^def KERNEL_CALL_RETURN = Tuple.newType(Lists.cons2(Int.TYPE, Int.TYPE));$/;"	d
KERNEL_PARAM_REGS	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def KERNEL_PARAM_REGS = [$/;"	d
KERNEL_RETURN_REGS	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def KERNEL_RETURN_REGS = [$/;"	d
KILL	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def KILL = 0x3;$/;"	d
KIND_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_BOOLEAN= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,$/;"	d
KIND_BYTE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_BYTE	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,$/;"	d
KIND_CHAR	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_CHAR	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,$/;"	d
KIND_DOUBLE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_DOUBLE	= JvmKind.new(JvmBytecode.DLOAD, JvmBytecode.DLOAD_0,$/;"	d
KIND_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_FLOAT	= JvmKind.new(JvmBytecode.FLOAD, JvmBytecode.FLOAD_0,$/;"	d
KIND_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_INT	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,$/;"	d
KIND_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_LONG	= JvmKind.new(JvmBytecode.LLOAD, JvmBytecode.LLOAD_0,$/;"	d
KIND_OBJECT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_OBJECT	= JvmKind.new(JvmBytecode.ALOAD, JvmBytecode.ALOAD_0,$/;"	d
KIND_SHORT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_SHORT	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,$/;"	d
KIND_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def KIND_VOID	= JvmKind.new(none, none, none, none, none, none, JvmBytecode.RETURN, none, 0);$/;"	d
KWMAP_HASH	$VIRGIL/aeneas/src/vst/Parser.v3	/^	private def KWMAP_HASH = 11; \/\/ hash parameter of perfect hashmap for keywords$/;"	d
KWMAP_SIZE	$VIRGIL/aeneas/src/vst/Parser.v3	/^	private def KWMAP_SIZE = 103; \/\/ size of perfect hashmap for keywords$/;"	d
Kernel_TypeCon	$VIRGIL/aeneas/src/os/Kernel.v3	/^class Kernel_TypeCon(kernel: Kernel, retType: Type) extends Member_TypeCon {$/;"	c
Keywords	$VIRGIL/aeneas/src/vst/Parser.v3	/^component Keywords {$/;"	n
Kill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Kill(constraint: int);$/;"	d
L2D	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def L2D		= '\x8a'; \/\/ 138$/;"	d
L2F	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def L2F		= '\x89'; \/\/ 137$/;"	d
L2I	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def L2I		= '\x88'; \/\/ 136$/;"	d
LADD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LADD	= '\x61'; \/\/ 97$/;"	d
LALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LALOAD	= '\x2f'; \/\/ 47$/;"	d
LAND	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LAND	= '\x7f'; \/\/ 127$/;"	d
LASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LASTORE	= '\x50'; \/\/ 80$/;"	d
LAYOUT_TYPE_PARAM	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def LAYOUT_TYPE_PARAM = List.new(newTypeParamWithConstraint(BUILTIN_TOKEN, globalCache,$/;"	d
LCMP	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LCMP	= '\x94'; \/\/ 148$/;"	d
LCONST_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LCONST_0	= '\x09'; \/\/ 9$/;"	d
LCONST_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LCONST_1	= '\x0a'; \/\/ 10$/;"	d
LDC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LDC		= '\x12'; \/\/ 18$/;"	d
LDC2_W	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LDC2_W	= '\x14'; \/\/ 20$/;"	d
LDC_W	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LDC_W	= '\x13'; \/\/ 19$/;"	d
LDIV	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LDIV	= '\x6d'; \/\/ 109$/;"	d
LEGACY_INFER	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def LEGACY_INFER	= langOpt.newBoolOption("legacy-infer", true,$/;"	d
LIVE	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def LIVE: i8 = 0;$/;"	d
LIVE	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def LIVE: i8 = 0;$/;"	d
LIVE	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def LIVE = 0x2;$/;"	d
LLOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LLOAD	= '\x16'; \/\/ 22$/;"	d
LLOAD_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LLOAD_0	= '\x1e'; \/\/ 30$/;"	d
LLOAD_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LLOAD_1	= '\x1f'; \/\/ 31$/;"	d
LLOAD_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LLOAD_2	= '\x20'; \/\/ 32$/;"	d
LLOAD_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LLOAD_3	= '\x21'; \/\/ 33$/;"	d
LMUL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LMUL	= '\x69'; \/\/ 105$/;"	d
LNEG	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LNEG	= '\x75'; \/\/ 117$/;"	d
LOCALHOST_V4	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def LOCALHOST_V4 = InetAddress.Ipv4(127, 0, 0, 1);$/;"	d
LOCALHOST_V6	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def LOCALHOST_V6 = InetAddress.Ipv6(0, 0, 0, 1);$/;"	d
LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def LONG    = JvmPrimitive.new("long", "J", "J", KIND_LONG);$/;"	d
LOOKUPSWITCH	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LOOKUPSWITCH	= '\xab'; \/\/ 171$/;"	d
LOR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LOR		= '\x81'; \/\/ 129$/;"	d
LOWERING	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def LOWERING = makeMachLoweringConfig();$/;"	d
LOWERING	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^def LOWERING = MachLoweringConfig.new();$/;"	d
LREM	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LREM	= '\x71'; \/\/ 113$/;"	d
LRETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LRETURN		= '\xad'; \/\/ 173$/;"	d
LSHL	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSHL	= '\x79'; \/\/ 121$/;"	d
LSHR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSHR	= '\x7b'; \/\/ 123$/;"	d
LSTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSTORE	= '\x37'; \/\/ 55$/;"	d
LSTORE_0	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSTORE_0	= '\x3f'; \/\/ 63$/;"	d
LSTORE_1	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSTORE_1	= '\x40'; \/\/ 64$/;"	d
LSTORE_2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSTORE_2	= '\x41'; \/\/ 65$/;"	d
LSTORE_3	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSTORE_3	= '\x42'; \/\/ 66$/;"	d
LSUB	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LSUB	= '\x65'; \/\/ 101$/;"	d
LUSHR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LUSHR	= '\x7d'; \/\/ 125$/;"	d
LXOR	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def LXOR	= '\x83'; \/\/ 131$/;"	d
Label	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Label(block: SsaBlock, label: Label);$/;"	d
Label	$VIRGIL/aeneas/src/util/Label.v3	/^class Label {$/;"	c
LayoutDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutDecl(decl: VstLayout);$/;"	d
LayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutField(receiver: RefType, member: VstLayoutField);$/;"	d
LayoutFieldDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutFieldDecl(decl: VstLayoutField);$/;"	d
LayoutNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutNested(receiver: RefType, member: VstLayoutField);$/;"	d
LayoutRepeatedField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutRepeatedField(receiver: RefType, member: VstLayoutField);$/;"	d
LayoutRepeatedNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutRepeatedNested(receiver: RefType, member: VstLayoutField);$/;"	d
LazyMap	$VIRGIL/lib/util/Map.v3	/^class LazyMap<K, V> extends PartialMap<K, V> {$/;"	c
LengthCheck	$VIRGIL/aeneas/src/v3/V3.v3	/^	def LengthCheck   = "LengthCheckException";$/;"	d
Lg1	$VIRGIL/lib/math/Math.v3	/^def Lg1 = 6.666666666666735130e-1;		\/* 3FE55555 55555593 *\/$/;"	d
Lg2	$VIRGIL/lib/math/Math.v3	/^def Lg2 = 3.999999999940941908e-1;		\/* 3FD99999 9997FA04 *\/$/;"	d
Lg3	$VIRGIL/lib/math/Math.v3	/^def Lg3 = 2.857142874366239149e-1;		\/* 3FD24924 94229359 *\/$/;"	d
Lg4	$VIRGIL/lib/math/Math.v3	/^def Lg4 = 2.222219843214978396e-1;		\/* 3FCC71C5 1D8E78AF *\/$/;"	d
Lg5	$VIRGIL/lib/math/Math.v3	/^def Lg5 = 1.818357216161805012e-1;		\/* 3FC74664 96CB03DE *\/$/;"	d
Lg6	$VIRGIL/lib/math/Math.v3	/^def Lg6 = 1.531383769920937332e-1;		\/* 3FC39A09 D078C69F *\/$/;"	d
Lg7	$VIRGIL/lib/math/Math.v3	/^def Lg7 = 1.479819860511658591e-1;		\/* 3FC2F112 DF3E5244 *\/$/;"	d
LineCol	$VIRGIL/lib/packing/CiRuntime.v3	/^	case LineCol(line: u11, col: u8) 	#packing 0b_0lll_llllllll_cccccccc;$/;"	d
LinearScanRegAlloc	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LinearScanRegAlloc {$/;"	c
LinuxTarget	$VIRGIL/aeneas/src/os/Linux.v3	/^class LinuxTarget extends Target {$/;"	c
List	$VIRGIL/lib/util/List.v3	/^class List<T>(head: T, tail: List<T>) { }$/;"	c
ListStack	$VIRGIL/lib/util/Stack.v3	/^class ListStack<T> extends Stack<T> {$/;"	c
Lists	$VIRGIL/lib/util/List.v3	/^component Lists {$/;"	n
Literal	$VIRGIL/aeneas/src/vst/Vst.v3	/^class Literal extends Expr {$/;"	c
LoadOptimize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var LoadOptimize		= flags.get("LoadOptimize", level >= 1);$/;"	d
Local	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Local(decl: VarDecl);$/;"	d
LocalRegAlloc	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^class LocalRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {$/;"	c
LocalRegAlloc	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var LocalRegAlloc		= flags.get("LocalRegAlloc", level >= 1) && !CLOptions.DWARF.get();$/;"	d
LocalStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class LocalStmt(start: FilePoint, vars: List<VarDecl>) extends Stmt {$/;"	c
Long	$VIRGIL/aeneas/src/types/Int.v3	/^component Long {$/;"	n
LongToInt	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case LongToInt;$/;"	d
Longs	$VIRGIL/lib/util/Longs.v3	/^component Longs {$/;"	n
LookupResult	$VIRGIL/aeneas/src/vst/Vst.v3	/^type LookupResult {$/;"	c
LookupResult.Const	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Const(vtype: Type, val: Val);$/;"	c
LookupResult.Inst	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Inst(op: Operator, typeParams: List<TypeParamType>);$/;"	c
LookupResult.None	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case None;$/;"	c
Loop	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Loop(bi: SsaBlockInfo);$/;"	d
LoopError	$VIRGIL/aeneas/src/main/Error.v3	/^	def LoopError(msg: string) {$/;"	m
LsraDef	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraDef extends LsraPoint {$/;"	c
LsraEnd	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraEnd extends LsraPoint {$/;"	c
LsraKill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraKill extends LsraPoint {$/;"	c
LsraLive	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraLive extends LsraPoint {$/;"	c
LsraPoint	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraPoint {$/;"	c
LsraStart	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraStart extends LsraPoint {$/;"	c
LsraUse	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class LsraUse extends LsraPoint {$/;"	c
Lteq	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	case Lteq;$/;"	d
MAIN_EXPORT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MAIN_EXPORT		= wasmOpt.newStringOption("main-export", "main",$/;"	d
MATCH_ADDR_ADD	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def MATCH_ADDR_ADD = true;$/;"	d
MATCH_NEG	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def MATCH_NEG = true;$/;"	d
MATCH_NEG	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def MATCH_NEG = true;$/;"	d
MATCH_OP_I	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def MATCH_OP_I = true;$/;"	d
MATCH_OP_I	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def MATCH_OP_I = true;$/;"	d
MATCH_SCALE	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def MATCH_SCALE = true;$/;"	d
MAXD	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MAXD		= sharedOpt.newIntOption("maxd", 0,$/;"	d
MAXP	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MAXP		= sharedOpt.newIntOption("maxp", 100000,$/;"	d
MAXPATHLEN	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def MAXPATHLEN = 1024;$/;"	d
MAXR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MAXR		= sharedOpt.newIntOption("maxr", 100000,$/;"	d
MAXV	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MAXV		= sharedOpt.newIntOption("maxv", 0,$/;"	d
MAX_OP_PER_INSTR	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def MAX_OP_PER_INSTR = 1;$/;"	d
MAX_PACKING_WIDTH	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def MAX_PACKING_WIDTH = byte.!(Int.MAX_WIDTH);$/;"	d
MAX_VALUE	$VIRGIL/aeneas/src/types/Int.v3	/^	def MAX_VALUE = 2147483647;$/;"	d
MAX_WIDTH	$VIRGIL/aeneas/src/types/Int.v3	/^	def MAX_WIDTH = 64;$/;"	d
MEMORY	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def MEMORY: byte = 5;	 \/\/ Memory attributes$/;"	d
MH_BUNDLE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_BUNDLE		= 0x8; \/\/ dynamically bound bundle file$/;"	d
MH_CORE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_CORE		= 0x4; \/\/ core file$/;"	d
MH_DSYM	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_DSYM		= 0xa; \/\/ companion file with only debug$/;"	d
MH_DYLIB	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_DYLIB		= 0x6; \/\/ dynamically bound shared library$/;"	d
MH_DYLIB_STUB	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_DYLIB_STUB	= 0x9; \/\/ shared library stub for static$/;"	d
MH_DYLINKER	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_DYLINKER		= 0x7; \/\/ dynamic link editor$/;"	d
MH_EXECUTE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_EXECUTE		= 0x2; \/\/ demand paged executable file$/;"	d
MH_FVMLIB	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_FVMLIB		= 0x3; \/\/ fixed VM shared library file$/;"	d
MH_KEXT_BUNDLE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_KEXT_BUNDLE	= 0xb; \/\/ x86_64 kexts$/;"	d
MH_MAGIC_32	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_MAGIC_32 = 0xFEEDFACE;$/;"	d
MH_MAGIC_64	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_MAGIC_64 = 0xFEEDFACF;$/;"	d
MH_OBJECT	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_OBJECT		= 0x1; \/\/ relocatable object file$/;"	d
MH_PRELOAD	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def MH_PRELOAD		= 0x5; \/\/ preloaded executable file$/;"	d
MINUS_1	$VIRGIL/aeneas/src/types/Int.v3	/^	def MINUS_1   = Box.new(-1);$/;"	d
MIN_INSTR_LEN	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def MIN_INSTR_LEN = 1;$/;"	d
MIN_VALUE	$VIRGIL/aeneas/src/types/Int.v3	/^	def MIN_VALUE = -2147483648;$/;"	d
MIXED_ARRAY_TAG	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def MIXED_ARRAY_TAG = 2;$/;"	d
MOD_BITS	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def MOD_BITS: byte	= 0b11000000;$/;"	d
MOD_BITS	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def MOD_BITS = 0b11000000;$/;"	d
MOD_DISP0	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def MOD_DISP0: byte	= 0b00000000;$/;"	d
MOD_DISP0	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def MOD_DISP0  = 0b00000000;$/;"	d
MOD_DISP32	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def MOD_DISP32: byte	= 0b10000000;$/;"	d
MOD_DISP32	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def MOD_DISP32 = 0b10000000;$/;"	d
MOD_DISP8	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def MOD_DISP8: byte	= 0b01000000;$/;"	d
MOD_DISP8	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def MOD_DISP8  = 0b01000000;$/;"	d
MOD_REG	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def MOD_REG: byte	= 0b11000000;$/;"	d
MOD_REG	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def MOD_REG  = 0b11000000;$/;"	d
MONITORENTER	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def MONITORENTER	= '\xc2'; \/\/ 194$/;"	d
MONITOREXIT	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def MONITOREXIT		= '\xc3'; \/\/ 195$/;"	d
MONO_TYPEARGS	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def MONO_TYPEARGS: Array<Type> = [AnyRef.TYPE];$/;"	d
MRegs	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def MRegs: X86_64RegSet;$/;"	d
MRegs	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def MRegs: X86_64RegSet;$/;"	d
MULTIANEWARRAY	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def MULTIANEWARRAY	= '\xc5'; \/\/ 197$/;"	d
MULTIPLE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def MULTIPLE		= compileOpt.newBoolOption("multiple", false,$/;"	d
MachBackend	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachBackend(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter) {$/;"	c
MachCallConv	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachCallConv {$/;"	c
MachDataWriter	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^class MachDataWriter extends DataWriter {$/;"	c
MachFrame	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachFrame(conv: MachCallConv, align: Alignment, refSize: int) {$/;"	c
MachInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachInstr(name: string) {$/;"	c
MachLayout	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class MachLayout(mach: MachProgram) {$/;"	c
MachLowering	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^class MachLowering(mach: MachProgram, compiler: Compiler, config: MachLoweringConfig) extends SsaGraphNormalizer(SsaContext.new(compiler, mach.prog)) {$/;"	c
MachLoweringConfig	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^class MachLoweringConfig {$/;"	c
MachModule	$VIRGIL/aeneas/src/mach/Pointer.v3	/^component MachModule {$/;"	n
MachMoves	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachMoves {$/;"	c
MachO	$VIRGIL/aeneas/src/exe/MachO.v3	/^component MachO {$/;"	n
MachO_Header	$VIRGIL/aeneas/src/exe/MachO.v3	/^class MachO_Header(is64: bool) {$/;"	c
MachO_Section	$VIRGIL/aeneas/src/exe/MachO.v3	/^class MachO_Section(sectname: string, segname: string) {$/;"	c
MachO_SegmentLoad	$VIRGIL/aeneas/src/exe/MachO.v3	/^class MachO_SegmentLoad(segname: string) extends MachO_LoadCmd {$/;"	c
MachO_X86ThreadState	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^class MachO_X86ThreadState extends MachO_LoadCmd {$/;"	c
MachO_X86_64ThreadState	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^class MachO_X86_64ThreadState extends MachO_LoadCmd {$/;"	c
MachObjectTags	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^component MachObjectTags {$/;"	n
MachOptimize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var MachOptimize		= flags.get("MachOptimize", level >= 2);$/;"	d
MachProgram	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class MachProgram extends TargetProgram {$/;"	c
MachRefMapBuilder	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^class MachRefMapBuilder {$/;"	c
MachRegSet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class MachRegSet {$/;"	c
MachRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class MachRep(origType: Type, machType: Type) { }$/;"	c
MachRtGcTables	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^class MachRtGcTables(mach: MachProgram, rt: MachRuntime) {$/;"	c
MachRtPageTable	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class MachRtPageTable($/;"	c
MachRtSrcTables	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^class MachRtSrcTables(mach: MachProgram, rt: MachRuntime) {$/;"	c
MachRuntime	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^class MachRuntime(mach: MachProgram) {$/;"	c
MachStackifier	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^class MachStackifier(gen: SsaMachGen) {$/;"	c
Mach_FuncRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class Mach_FuncRep extends MachRep {$/;"	c
Mach_V3Array	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^class Mach_V3Array extends MachRep {$/;"	c
MainMethodError	$VIRGIL/aeneas/src/main/Error.v3	/^	def MainMethodError(msg: string) {$/;"	m
MainMethodError	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def MainMethodError(range: FileRange, msg: string) {$/;"	m
MainNotFound	$VIRGIL/aeneas/src/main/Error.v3	/^	def MainNotFound() {$/;"	m
Mangle	$VIRGIL/aeneas/src/v3/Mangle.v3	/^component Mangle {$/;"	n
Map	$VIRGIL/lib/util/Map.v3	/^class Map<K, V> {$/;"	c
MapKeyListGatherer	$VIRGIL/lib/util/Map.v3	/^private class MapKeyListGatherer<K, V> {$/;"	c
MapValueListGatherer	$VIRGIL/lib/util/Map.v3	/^private class MapValueListGatherer<K, V> {$/;"	c
Maps	$VIRGIL/lib/util/Map.v3	/^component Maps {$/;"	n
MatchCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^class MatchCase(default: FilePoint, patterns: VstList<MatchPattern>, stmt: Stmt) {$/;"	c
MatchError	$VIRGIL/aeneas/src/main/Error.v3	/^	def MatchError( msg: string) {$/;"	m
MatchError	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def MatchError(range: FileRange, msg: string, prev: FilePoint) {$/;"	m
MatchPattern	$VIRGIL/aeneas/src/vst/Vst.v3	/^class MatchPattern(expr: Expr, params: VstList<VarDecl>) {$/;"	c
MatchStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class MatchStmt(src: FilePoint, expr: Expr, cases: VstList<MatchCase>) extends Stmt {$/;"	c
MatchStmtVerifier	$VIRGIL/aeneas/src/vst/Verifier.v3	/^class MatchStmtVerifier(etype: Type, tc: TypeChecker) {$/;"	c
Math	$VIRGIL/lib/math/Math.v3	/^component Math {$/;"	n
MaxFlatDataValues	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MaxFlatDataValues: int;$/;"	d
MaxFlatVariantValues	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MaxFlatVariantValues: int;$/;"	d
MaxParams	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MaxParams: int;$/;"	d
MaxReturnValues	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MaxReturnValues: int;$/;"	d
MaxScalarWidth	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MaxScalarWidth: byte = 64;$/;"	d
MemberNotInitialized	$VIRGIL/aeneas/src/main/Error.v3	/^	def MemberNotInitialized(msg: string) {$/;"	m
MemberRedefined	$VIRGIL/aeneas/src/main/Error.v3	/^	def MemberRedefined(decl: Token) {$/;"	m
Member_TypeCon	$VIRGIL/aeneas/src/core/Member.v3	/^class Member_TypeCon extends TypeCon {$/;"	c
MemoryTypeRef	$VIRGIL/aeneas/src/vst/Vst.v3	/^class MemoryTypeRef(tname: VstIdent<void>, repeat: Literal) {$/;"	c
MethodEnv	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^class MethodEnv {$/;"	c
MipsAssembler	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^class MipsAssembler(w: DataWriter) {$/;"	c
MipsReg	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^type MipsReg {$/;"	c
MipsReg.R0	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
MipsReg.R1	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
MipsReg.R10	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
MipsReg.R11	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
MipsReg.R12	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
MipsReg.R13	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
MipsReg.R14	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
MipsReg.R15	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	c
MipsReg.R16	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	c
MipsReg.R17	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	c
MipsReg.R18	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	c
MipsReg.R19	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	c
MipsReg.R2	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
MipsReg.R20	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	c
MipsReg.R21	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	c
MipsReg.R22	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	c
MipsReg.R23	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	c
MipsReg.R24	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	c
MipsReg.R25	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	c
MipsReg.R26	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	c
MipsReg.R27	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	c
MipsReg.R28	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	c
MipsReg.R29	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	c
MipsReg.R3	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R0;  case R1;  case R2;  case R3;$/;"	c
MipsReg.R30	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	c
MipsReg.R31	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	c
MipsReg.R4	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
MipsReg.R5	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
MipsReg.R6	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
MipsReg.R7	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R4;  case R5;  case R6;  case R7;$/;"	c
MipsReg.R8	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
MipsReg.R9	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	c
MissingReturn	$VIRGIL/aeneas/src/main/Error.v3	/^	def MissingReturn() {$/;"	m
MixedArrays	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var MixedArrays: bool;$/;"	d
Move	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Move(dst: int, src: int);$/;"	d
MoveNode	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^class MoveNode {$/;"	c
MoveResolver	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^class MoveResolver(ERROR: ErrorGen) {$/;"	c
MoveSet	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^class MoveSet(regSet: MachRegSet) {$/;"	c
NAME	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def NAME: byte = 12;	 \/\/ Name section (encoded as a string)$/;"	d
NEQ	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def NEQ = Arm64Cond.new("neq", 1);$/;"	d
NEQ	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def NEQ = SSECmp.new("neq", 4);$/;"	d
NEW	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def NEW			= '\xbb'; \/\/ 187$/;"	d
NEWARRAY	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def NEWARRAY		= '\xbc'; \/\/ 188$/;"	d
NEW_OPTIMIZER	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^def NEW_OPTIMIZER = false;$/;"	d
NLE	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def NLE = SSECmp.new("nle", 6);$/;"	d
NLT	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def NLT = SSECmp.new("nlt", 5);$/;"	d
NONE	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def NONE: Fact.set;$/;"	d
NONE	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def NONE: RaFact.set;$/;"	d
NONE	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def NONE: RaFact.set;$/;"	d
NONE	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def NONE      = '\x00';$/;"	d
NON_VARIANT	$VIRGIL/aeneas/src/vst/Vst.v3	/^def NON_VARIANT = -2;$/;"	d
NOP	$VIRGIL/aeneas/src/ic/Ic.v3	/^def NOP = IcInstr.Move(0, 0);$/;"	d
NOP	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def NOP		= '\x00'; \/\/ 0$/;"	d
NOT_ECX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def NOT_ECX = '\x14';$/;"	d
NOT_EDX	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def NOT_EDX = '\x13';$/;"	d
NOT_PARAM	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def NOT_PARAM = set("~{param}", [RAX, RBX, R10, R11, R12, R13, R14, R15]);$/;"	d
NOT_RAX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def NOT_RAX = set("~{rax}", [RBX, RCX, RDX, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15]);$/;"	d
NOT_RAX_RDX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def NOT_RAX_RDX = set("~{rax,rdx}", [RBX, RCX, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15]);$/;"	d
NOT_RCX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def NOT_RCX = set("~{rcx}", [RAX, RBX, RDX, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15]);$/;"	d
NOT_RDX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def NOT_RDX = set("~{rdx}", [RAX, RBX, RCX, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15]);$/;"	d
NO_BLOCKS	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def NO_BLOCKS: Array<SsaBlock> = [];$/;"	d
NO_CF_EDGES	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def NO_CF_EDGES: Array<SsaCfEdge> = [];$/;"	d
NO_DF_EDGES	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def NO_DF_EDGES: Array<SsaDfEdge> = [];$/;"	d
NO_FIELDS	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def NO_FIELDS = Array<IrField>.new(0);$/;"	d
NO_FIELDS	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def NO_FIELDS = Array<VariantField>.new(0);$/;"	d
NO_INSTRS	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def NO_INSTRS: Array<SsaInstr> = [];$/;"	d
NO_OPERANDS	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def NO_OPERANDS: Array<Operand> = [];$/;"	d
NO_RANGES	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def NO_RANGES = Array<(int, int)>.new(0);$/;"	d
NO_REX	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def NO_REX: byte	= 0b00000000;$/;"	d
NO_TRUNCATE	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^def NO_TRUNCATE = false;$/;"	d
NO_TYPES	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def NO_TYPES: Array<Type> = [];$/;"	d
NO_VALUES	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def NO_VALUES = Array<Val>.new(0);$/;"	d
NULL_PTR	$VIRGIL/aeneas/src/core/Eval.v3	/^def NULL_PTR = Addr.new(null, null, 0).setAbsolute(0);$/;"	d
NUM_FLAGS	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def NUM_FLAGS: u5 = 4;$/;"	d
NamedTypeRef	$VIRGIL/aeneas/src/vst/Vst.v3	/^class NamedTypeRef(left: NamedTypeRef, name: Token, nested: VstList<TypeRef>) extends TypeRef {$/;"	c
NativeCmpSwp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var NativeCmpSwp = true;	\/\/ target platform supports native compare+swap$/;"	d
NegExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class NegExpr(not: FilePoint, expr: Expr) extends Expr {$/;"	c
Net	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^component Net {$/;"	n
NetResult	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^type NetResult<T> {$/;"	c
NetResult.Error	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Error(e: NetError);$/;"	c
NetResult.Result	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Result(v: T);$/;"	c
NewVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case NewVar(vname: string, vtype: Type);$/;"	d
Node	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^class Node(var alias: int, var defBlock: SsaBlock) {$/;"	c
NonRefClosureReceiver	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var NonRefClosureReceiver: bool;$/;"	d
None	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case None;$/;"	d
None	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case None;$/;"	d
None	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case None;$/;"	d
Nonref	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Nonref(size: byte);$/;"	d
Nop	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Nop;		\/\/ desugar op(x) to x$/;"	d
NormConfig	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def NormConfig			= NormalizerConfig.new();$/;"	d
NormOptimize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var NormOptimize		= flags.get("NormOptimize", level >= 2);$/;"	d
NormRangeGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeGetElem;$/;"	d
NormRangeGetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeGetElemElem(index: int);$/;"	d
NormRangeSetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeSetElem;$/;"	d
NormRangeSetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeSetElemElem(index: int);$/;"	d
NormalizeRange	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var NormalizeRange: bool;$/;"	d
NormalizerConfig	$VIRGIL/aeneas/src/ir/Normalization.v3	/^class NormalizerConfig {$/;"	c
NotEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case NotEqual;		\/\/ desugared to !(a == b)$/;"	d
NotExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class NotExpr(not: FilePoint, expr: Expr) extends Expr {$/;"	c
Null	$VIRGIL/aeneas/src/types/Void.v3	/^component Null {$/;"	n
NullCheck	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NullCheck;$/;"	d
NullCheck	$VIRGIL/aeneas/src/v3/V3.v3	/^	def NullCheck     = "NullCheckException";$/;"	d
NullType	$VIRGIL/aeneas/src/types/Void.v3	/^class NullType extends Type {$/;"	c
NullcheckAreaSize	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var NullcheckAreaSize = 0;	 \/\/ hardware reserved null check area size$/;"	d
NumberParser	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^class NumberParser(input: Range<byte>) {$/;"	c
OBJECT_TAG	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def OBJECT_TAG = 0;$/;"	d
ONE	$VIRGIL/aeneas/src/types/Int.v3	/^	def ONE       = Box.new(1);$/;"	d
ONE_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def ONE_ENTRY = SsaConstCacheEntry.new(4, Int.TYPE, Int.ONE, Facts.intFacts(1));$/;"	d
ONE_TYPE_PARAM	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def ONE_TYPE_PARAM = List.new(TYPE_PARAM, null);$/;"	d
ON_STACK	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def ON_STACK = -1;$/;"	d
ON_STACK	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def ON_STACK = -1;$/;"	d
ON_STACK	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def ON_STACK: i8 = -1;$/;"	d
ON_STACK	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def ON_STACK: i8 = -1;$/;"	d
ON_STACK	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^def ON_STACK = -1;$/;"	d
ON_STACK	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^def ON_STACK = -2;$/;"	d
OPCODE_MASK	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def OPCODE_MASK = 0xFF;$/;"	d
OPEN_MASK	$VIRGIL/aeneas/src/types/Type.v3	/^	def OPEN_MASK      = 0x60000000;$/;"	d
OPT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def OPT			= sharedOpt.newStringOption("opt", null,$/;"	d
ORD	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ORD = SSECmp.new("ord", 7);$/;"	d
OROR	$VIRGIL/aeneas/src/types/Bool.v3	/^	def OROR = V3Op.newVstSugar(VstOperator.BoolOrOr, TypeUtil.NO_TYPES, ARRAY_TT, TYPE);$/;"	d
OUTPUT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def OUTPUT		= compileOpt.newPathOption("output", null,$/;"	d
O_APPEND	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_APPEND	= 0x0008;  \/\/ set append mode$/;"	d
O_ASYNC	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_ASYNC	= 0x0040;  \/\/ signal pgrp when data ready$/;"	d
O_CREAT	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_CREAT	= 0x0200;  \/\/ create if nonexistant$/;"	d
O_EVTONLY	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_EVTONLY	= 0x8000;  \/\/ descriptor requested for event notifications only$/;"	d
O_EXCL	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_EXCL	= 0x0800;  \/\/ error if already exists$/;"	d
O_EXLOCK	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_EXLOCK	= 0x0020;  \/\/ open with exclusive file lock$/;"	d
O_NOCTTY	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_NOCTTY	= 0x20000; \/\/ don't assign controlling terminal$/;"	d
O_NOFOLLOW	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_NOFOLLOW	= 0x0100;  \/\/ don't follow symlinks$/;"	d
O_NONBLOCK	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_NONBLOCK	= 0x0004;  \/\/ no delay$/;"	d
O_NO_NAN_CHECK	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def O_NO_NAN_CHECK = Fact.O_NO_NULL_CHECK;$/;"	d
O_RDONLY	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_RDONLY	= 0;       \/\/ open read-only$/;"	d
O_RDWR	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_RDWR	= 2;       \/\/ open read-write$/;"	d
O_SAFE_BOUNDS	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def O_SAFE_BOUNDS = Fact.O_NO_NULL_CHECK | Fact.O_NO_BOUNDS_CHECK;$/;"	d
O_SAFE_DIVIDE	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def O_SAFE_DIVIDE = Fact.O_NO_ZERO_CHECK | Fact.O_PURE;$/;"	d
O_SAFE_SHIFT	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def O_SAFE_SHIFT = Fact.O_NO_SHIFT_CHECK | Fact.O_PURE;$/;"	d
O_SHLOCK	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_SHLOCK	= 0x0010;  \/\/ open with shared file lock$/;"	d
O_SYNC	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_SYNC	= 0x0080;  \/\/ synch I\/O file integrity$/;"	d
O_TRUNC	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_TRUNC	= 0x0400;  \/\/ truncate to zero length$/;"	d
O_WRONLY	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def O_WRONLY	= 1;       \/\/ open write-only$/;"	d
ObjectField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ObjectField(receiver: Type, member: VstField);$/;"	d
ObjectMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ObjectMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	d
ObjectSystem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var ObjectSystem = false;	\/\/ target platform has an object system$/;"	d
OldCodeGen	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^class OldCodeGen(mach: MachProgram, context: SsaContext) {$/;"	c
Opcode	$VIRGIL/aeneas/src/core/Opcode.v3	/^type Opcode {$/;"	c
Opcode.Alloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case Alloc;$/;"	c
Opcode.ArrayAlloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayAlloc;$/;"	c
Opcode.ArrayGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetElem;$/;"	c
Opcode.ArrayGetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetElemElem(index: int);$/;"	c
Opcode.ArrayGetLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayGetLength;$/;"	c
Opcode.ArrayInit	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayInit(length: int);$/;"	c
Opcode.ArraySetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArraySetElem;$/;"	c
Opcode.ArraySetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArraySetElemElem(index: int);$/;"	c
Opcode.ArrayTupleInit	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ArrayTupleInit(elems: int, length: int);$/;"	c
Opcode.BoolAnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolAnd;$/;"	c
Opcode.BoolEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolEq;$/;"	c
Opcode.BoolNot	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolNot;$/;"	c
Opcode.BoolOr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoolOr;$/;"	c
Opcode.BoundsCheck	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case BoundsCheck;$/;"	c
Opcode.ByteArrayGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ByteArrayGetField(offset: int);$/;"	c
Opcode.ByteArraySetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ByteArraySetField(offset: int);$/;"	c
Opcode.CallAddress	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallAddress(p: Mach_FuncRep);$/;"	c
Opcode.CallClassMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassMethod(method: IrMethod);$/;"	c
Opcode.CallClassSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassSelector(selector: IrSelector);$/;"	c
Opcode.CallClassVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClassVirtual(method: IrMethod);$/;"	c
Opcode.CallClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallClosure;$/;"	c
Opcode.CallFunction	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallFunction;$/;"	c
Opcode.CallKernel	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallKernel(kernel: Kernel);$/;"	c
Opcode.CallMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallMethod(method: IrMethod);$/;"	c
Opcode.CallVariantSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallVariantSelector(selector: IrSelector);$/;"	c
Opcode.CallVariantVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallVariantVirtual(method: IrMethod);$/;"	c
Opcode.CallerIp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallerIp;$/;"	c
Opcode.CallerSp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CallerSp;$/;"	c
Opcode.ClassAlloc	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassAlloc(method: IrMethod);$/;"	c
Opcode.ClassGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetField(field: IrField);$/;"	c
Opcode.ClassGetMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetMethod(method: IrMethod);$/;"	c
Opcode.ClassGetSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetSelector(selector: IrSelector);$/;"	c
Opcode.ClassGetVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassGetVirtual(method: IrMethod);$/;"	c
Opcode.ClassInitField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassInitField(field: IrField);$/;"	c
Opcode.ClassSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ClassSetField(field: IrField);$/;"	c
Opcode.ComponentGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ComponentGetField(field: IrField);$/;"	c
Opcode.ComponentSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ComponentSetField(field: IrField);$/;"	c
Opcode.ConditionalThrow	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ConditionalThrow(exception: string);$/;"	c
Opcode.CreateClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case CreateClosure(method: IrMethod);$/;"	c
Opcode.FloatAbs	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatAbs(isDouble: bool);$/;"	c
Opcode.FloatAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatAdd(isDouble: bool);$/;"	c
Opcode.FloatBitEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatBitEq(isDouble: bool);$/;"	c
Opcode.FloatCastD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCastD;$/;"	c
Opcode.FloatCastI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCastI(isDouble: bool);$/;"	c
Opcode.FloatCeil	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatCeil(isDouble: bool);$/;"	c
Opcode.FloatDiv	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatDiv(isDouble: bool);$/;"	c
Opcode.FloatEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatEq(isDouble: bool);$/;"	c
Opcode.FloatFloor	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatFloor(isDouble: bool);$/;"	c
Opcode.FloatLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatLt(isDouble: bool);$/;"	c
Opcode.FloatLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatLteq(isDouble: bool);$/;"	c
Opcode.FloatMul	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatMul(isDouble: bool);$/;"	c
Opcode.FloatNe	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatNe(isDouble: bool);$/;"	c
Opcode.FloatPromoteF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatPromoteF;$/;"	c
Opcode.FloatPromoteI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatPromoteI(isDouble: bool);$/;"	c
Opcode.FloatQueryD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatQueryD;$/;"	c
Opcode.FloatQueryI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatQueryI(isDouble: bool);$/;"	c
Opcode.FloatRound	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRound(isDouble: bool);$/;"	c
Opcode.FloatRoundD	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRoundD;$/;"	c
Opcode.FloatRoundI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatRoundI(isDouble: bool);$/;"	c
Opcode.FloatSqrt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatSqrt(isDouble: bool);$/;"	c
Opcode.FloatSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatSub(isDouble: bool);$/;"	c
Opcode.FloatViewI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case FloatViewI(isDouble: bool);$/;"	c
Opcode.ForgeClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ForgeClosure;$/;"	c
Opcode.ForgeRange	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case ForgeRange;$/;"	c
Opcode.Init	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case Init(method: IrMethod);$/;"	c
Opcode.IntAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntAdd;$/;"	c
Opcode.IntAnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntAnd;$/;"	c
Opcode.IntCastF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntCastF(isDouble: bool);$/;"	c
Opcode.IntDiv	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntDiv;$/;"	c
Opcode.IntEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntEq;$/;"	c
Opcode.IntLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntLt;$/;"	c
Opcode.IntLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntLteq;$/;"	c
Opcode.IntMod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntMod;$/;"	c
Opcode.IntMul	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntMul;$/;"	c
Opcode.IntOr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntOr;$/;"	c
Opcode.IntQueryF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntQueryF(isDouble: bool);$/;"	c
Opcode.IntRepCreate	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntRepCreate;$/;"	c
Opcode.IntRepView	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntRepView;$/;"	c
Opcode.IntSar	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntSar;$/;"	c
Opcode.IntShl	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntShl;$/;"	c
Opcode.IntShr	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntShr;$/;"	c
Opcode.IntSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntSub;$/;"	c
Opcode.IntTruncF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntTruncF(isDouble: bool);$/;"	c
Opcode.IntViewF	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntViewF(isDouble: bool);$/;"	c
Opcode.IntViewI	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntViewI;$/;"	c
Opcode.IntWide	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntWide(op: Operator);$/;"	c
Opcode.IntXor	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case IntXor;$/;"	c
Opcode.NormRangeGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeGetElem;$/;"	c
Opcode.NormRangeGetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeGetElemElem(index: int);$/;"	c
Opcode.NormRangeSetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeSetElem;$/;"	c
Opcode.NormRangeSetElemElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NormRangeSetElemElem(index: int);$/;"	c
Opcode.NullCheck	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case NullCheck;$/;"	c
Opcode.OverloadedEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case OverloadedEq;$/;"	c
Opcode.PtrAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAdd;$/;"	c
Opcode.PtrAddRangeStart	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAddRangeStart;$/;"	c
Opcode.PtrAtArrayElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtArrayElem;$/;"	c
Opcode.PtrAtComponentField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtComponentField(field: IrField);$/;"	c
Opcode.PtrAtContents	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtContents;$/;"	c
Opcode.PtrAtEnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtEnd;$/;"	c
Opcode.PtrAtLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtLength;$/;"	c
Opcode.PtrAtObject	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtObject;$/;"	c
Opcode.PtrAtObjectField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtObjectField(field: IrField);$/;"	c
Opcode.PtrAtRangeElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRangeElem;$/;"	c
Opcode.PtrAtRef	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRef;$/;"	c
Opcode.PtrAtRefLayoutField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRefLayoutField(offset: int);$/;"	c
Opcode.PtrCmpSwp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrCmpSwp;$/;"	c
Opcode.PtrLoad	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLoad;$/;"	c
Opcode.PtrLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLt;$/;"	c
Opcode.PtrLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLteq;$/;"	c
Opcode.PtrStore	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrStore;$/;"	c
Opcode.PtrSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrSub;$/;"	c
Opcode.RangeFromPlus	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeFromPlus;$/;"	c
Opcode.RangeFromTo	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeFromTo;$/;"	c
Opcode.RangeGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeGetElem;$/;"	c
Opcode.RangeGetLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeGetLength;$/;"	c
Opcode.RangeSetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeSetElem;$/;"	c
Opcode.RangeStartFromPointer	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeStartFromPointer;$/;"	c
Opcode.RangeStartPlusIndex	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeStartPlusIndex;$/;"	c
Opcode.RefEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefEq;$/;"	c
Opcode.RefLayoutAt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutAt;$/;"	c
Opcode.RefLayoutAtRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutAtRepeatedField(offset: int, scale: int, max: int);$/;"	c
Opcode.RefLayoutGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutGetField(offset: int);$/;"	c
Opcode.RefLayoutGetRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutGetRepeatedField(offset: int, scale: int, max: int);$/;"	c
Opcode.RefLayoutIn	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutIn(offset: int);$/;"	c
Opcode.RefLayoutOf	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutOf;$/;"	c
Opcode.RefLayoutSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutSetField(offset: int);$/;"	c
Opcode.RefLayoutSetRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutSetRepeatedField(offset: int, scale: int, max: int);$/;"	c
Opcode.SystemCall	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case SystemCall(syscall: SystemCall);$/;"	c
Opcode.TupleCreate	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TupleCreate(length: int);$/;"	c
Opcode.TupleGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TupleGetElem(index: int);$/;"	c
Opcode.TypeCast	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeCast(cast: TypeCast);$/;"	c
Opcode.TypeQuery	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeQuery(query: TypeQuery);$/;"	c
Opcode.TypeSubsume	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeSubsume;$/;"	c
Opcode.UnpackClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case UnpackClosure;$/;"	c
Opcode.VariantEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantEq;$/;"	c
Opcode.VariantGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetField(field: IrField);$/;"	c
Opcode.VariantGetMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetMethod(method: IrMethod);$/;"	c
Opcode.VariantGetSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetSelector(selector: IrSelector);$/;"	c
Opcode.VariantGetTag	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetTag;$/;"	c
Opcode.VariantGetVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetVirtual(method: IrMethod);$/;"	c
Opcode.VariantReplaceNull	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantReplaceNull;$/;"	c
Opcode.VstSugar	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VstSugar(op: VstOperator);$/;"	c
Opcodes	$VIRGIL/aeneas/src/core/Opcode.v3	/^component Opcodes {$/;"	n
Operand	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^type Operand {$/;"	c
Operand.Def	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Def(vreg: VReg, constraint: int);$/;"	c
Operand.ExSource	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case ExSource(ex: string, source: Source);$/;"	c
Operand.Immediate	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Immediate(val: Val);$/;"	c
Operand.Kill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Kill(constraint: int);$/;"	c
Operand.Label	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Label(block: SsaBlock, label: Label);$/;"	c
Operand.NewVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case NewVar(vname: string, vtype: Type);$/;"	c
Operand.Overwrite	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Overwrite(dst: VReg, src: VReg, constraint: int);$/;"	c
Operand.RefMap	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case RefMap(livepoint: int, outgoing: MachCallConv);$/;"	c
Operand.Scratch	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Scratch(regClass: RegClass);$/;"	c
Operand.Use	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Use(vreg: VReg, constraint: int);$/;"	c
Operator	$VIRGIL/aeneas/src/core/Operator.v3	/^class Operator(opcode: Opcode, typeArgs: Array<Type>, sig: Signature) {$/;"	c
Opt	$VIRGIL/lib/util/Option.v3	/^class Opt(name: string) {$/;"	c
OptimizationFlags	$VIRGIL/aeneas/src/main/Compiler.v3	/^class OptimizationFlags {$/;"	c
Option	$VIRGIL/lib/util/Option.v3	/^class Option<T> extends Opt {$/;"	c
OptionGroup	$VIRGIL/aeneas/src/main/CLOptions.v3	/^class OptionGroup(name: string, o: BasicOptions) {$/;"	c
Options	$VIRGIL/lib/util/Option.v3	/^class Options(prefix: string) {$/;"	c
Other	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Other(hint: string);$/;"	d
OutputError	$VIRGIL/aeneas/src/main/Error.v3	/^	def OutputError(fileName: string) {$/;"	m
OverflowFieldAllocator	$VIRGIL/aeneas/src/ir/Normalization.v3	/^class OverflowFieldAllocator(decl: VstComponent, receiver: Type, anyref: bool) {$/;"	c
OverflowTypeEntry	$VIRGIL/aeneas/src/ir/Normalization.v3	/^class OverflowTypeEntry(var group: int, var index: int) {$/;"	c
OverloadedEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case OverloadedEq;$/;"	d
Overwrite	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Overwrite(dst: VReg, src: VReg, constraint: int);$/;"	d
PAGE_SIZE	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def PAGE_SIZE = 4096;$/;"	d
PARAM0	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM0 = Regs.RDI;$/;"	d
PARAM0	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM0 = Regs.RDI;$/;"	d
PARAM1	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM1 = Regs.RSI;$/;"	d
PARAM1	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM1 = Regs.RSI;$/;"	d
PARAM2	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM2 = Regs.RDX;$/;"	d
PARAM2	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM2 = Regs.RDX;$/;"	d
PARAM3	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM3 = Regs.R10;$/;"	d
PARAM3	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM3 = Regs.R10;$/;"	d
PARAM4	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM4 = Regs.R8;$/;"	d
PARAM4	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM4 = Regs.R8;$/;"	d
PARAM5	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^        def PARAM5 = Regs.R9;$/;"	d
PARAM5	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def PARAM5 = Regs.R9;$/;"	d
PARAM_GPRS	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def PARAM_GPRS = [R.R0, R.R1, R.R2, R.R3, R.R4, R.R5, R.R6, R.R7];$/;"	d
PARAM_GPRS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def PARAM_GPRS = [R.RDI, R.RSI, R.RDX, R.RCX, R.R8, R.R9]; 			\/\/ System-V$/;"	d
PARAM_XMMS	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def PARAM_XMMS: Array<byte> = [];	\/\/ System-V - 1$/;"	d
PARAM_XMMS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def PARAM_XMMS = [R.XMM0, R.XMM1, R.XMM2, R.XMM3, R.XMM4, R.XMM5, R.XMM6];	\/\/ System-V - 1$/;"	d
PARANOID	$VIRGIL/aeneas/src/main/Debug.v3	/^	def PARANOID = false;$/;"	d
PARSE_FUNCEXPRS	$VIRGIL/aeneas/src/vst/Parser.v3	/^def PARSE_FUNCEXPRS = false;$/;"	d
PAUSE	$VIRGIL/aeneas/src/ic/Ic.v3	/^def PAUSE = 3;$/;"	d
PF_R	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PF_R = 0x4;$/;"	d
PF_RW	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PF_RW = 0x6;$/;"	d
PF_RX	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PF_RX = 0x5;$/;"	d
PF_W	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PF_W = 0x2;$/;"	d
PF_X	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PF_X = 0x1;$/;"	d
PHYS_COUNT	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def PHYS_COUNT = cursor;$/;"	d
POP	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def POP		= '\x57'; \/\/ 87$/;"	d
POP2	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def POP2	= '\x58'; \/\/ 88$/;"	d
PREFIX_W	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def PREFIX_W: byte	= 0x66;$/;"	d
PRIM_ARRAY_TAG	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def PRIM_ARRAY_TAG = 1;$/;"	d
PRINT_BIN	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_BIN		= debugOpt.newBoolOption("print-bin", false,$/;"	d
PRINT_CFG	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_CFG		= debugOpt.newBoolOption("print-cfg", false,$/;"	d
PRINT_DEAD_CODE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_DEAD_CODE	= debugOpt.newBoolOption("print-dead-code", false,$/;"	d
PRINT_IC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_IC		= debugOpt.newMatcherOption("print-ic",$/;"	d
PRINT_ID	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_ID		= debugOpt.newBoolOption("print-id", false,$/;"	d
PRINT_INLINING	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_INLINING	= debugOpt.newBoolOption("print-inlining", false,$/;"	d
PRINT_LIMIT	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def PRINT_LIMIT = 30;$/;"	d
PRINT_MACH	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_MACH		= debugOpt.newMatcherOption("print-mach",$/;"	d
PRINT_MACH_DATA	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_MACH_DATA	= debugOpt.newBoolOption("print-mach-data", false,$/;"	d
PRINT_OPT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_OPT		= debugOpt.newMatcherOption("print-opt",$/;"	d
PRINT_PACKING	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def PRINT_PACKING = CLOptions.PRINT_PACKING.get();$/;"	d
PRINT_PACKING	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_PACKING	= debugOpt.newBoolOption("print-packing", false,$/;"	d
PRINT_PATCH	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_PATCH		= debugOpt.newBoolOption("print-patch", false,$/;"	d
PRINT_RA	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_RA		= debugOpt.newBoolOption("print-ra", false,$/;"	d
PRINT_REGALLOC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_REGALLOC	= debugOpt.newBoolOption("print-regalloc", false,$/;"	d
PRINT_SIZE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_SIZE		= debugOpt.newBoolOption("print-size", false,$/;"	d
PRINT_SSA	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_SSA		= debugOpt.newMatcherOption("print-ssa",$/;"	d
PRINT_SSA_STATS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_SSA_STATS	= debugOpt.newMatcherOption("print-ssa-stats",$/;"	d
PRINT_STACKIFY	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_STACKIFY	= debugOpt.newBoolOption("print-stackify", false,$/;"	d
PRINT_STACKMAP	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_STACKMAP	= debugOpt.newBoolOption("print-stackmap", false,$/;"	d
PRINT_VST	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PRINT_VST		= debugOpt.newBoolOption("print-vst", false,$/;"	d
PRIVATE_DEF	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def PRIVATE_DEF = VarDefParser.new(true, Writability.READ_ONLY);$/;"	d
PRIVATE_VAR	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def PRIVATE_VAR = VarDefParser.new(true, Writability.WRITEABLE);$/;"	d
PROFILE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PROFILE		= runOpt.newMatcherOption("profile",$/;"	d
PROFILE_DEPTH	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PROFILE_DEPTH	= runOpt.newIntOption ("profile-depth", 0,$/;"	d
PROGRAM_NAME	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def PROGRAM_NAME	= compileOpt.newStringOption("program-name", null,$/;"	d
PROT_NONE	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def PROT_NONE = 0;$/;"	d
PTR_16	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def PTR_16: Pointer_TypeCon = Pointer_TypeCon.new(ptr, 16);$/;"	d
PTR_32	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def PTR_32: Pointer_TypeCon = Pointer_TypeCon.new(ptr, 32);$/;"	d
PTR_64	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def PTR_64: Pointer_TypeCon = Pointer_TypeCon.new(ptr, 64);$/;"	d
PT_DYNAMIC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_DYNAMIC = 2;$/;"	d
PT_HIPROC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_HIPROC = 0x7fffffff;$/;"	d
PT_INTERP	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_INTERP = 3;$/;"	d
PT_LOAD	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_LOAD = 1;$/;"	d
PT_LOPROC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_LOPROC = 0x70000000;$/;"	d
PT_NOTE	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_NOTE = 4;$/;"	d
PT_NULL	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_NULL = 0;$/;"	d
PT_PHDR	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_PHDR = 6;$/;"	d
PT_SHLIB	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def PT_SHLIB = 5;$/;"	d
PUBLIC_DEF	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def PUBLIC_DEF  = VarDefParser.new(false, Writability.READ_ONLY);$/;"	d
PUBLIC_DEFVAR	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def PUBLIC_DEFVAR  = VarDefParser.new(false, Writability.PRIVATE_WRITEABLE);$/;"	d
PUBLIC_VAR	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def PUBLIC_VAR  = VarDefParser.new(false, Writability.WRITEABLE);$/;"	d
PUTFIELD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def PUTFIELD		= '\xb5'; \/\/ 181$/;"	d
PUTSTATIC	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def PUTSTATIC		= '\xb3'; \/\/ 179$/;"	d
Packed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Packed;$/;"	d
Packing	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Packing(p: VstList<VstPackingExpr>);$/;"	d
PackingBit	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type PackingBit #unboxed {$/;"	c
PackingBit.Assigned	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Assigned(ch: u8);	\/\/ . 		is already assigned (a bit of {ch})$/;"	c
PackingBit.Fixed	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Fixed(v: u1);	\/\/ 0 or 1	is fixed to the given value$/;"	c
PackingBit.Unassigned	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Unassigned;	\/\/ ?		may be chosen by the solver$/;"	c
PackingBitsMissing	$VIRGIL/aeneas/src/main/Error.v3	/^	def PackingBitsMissing(name: string, width: byte, got: int) {$/;"	m
PackingExprTooLong	$VIRGIL/aeneas/src/main/Error.v3	/^	def PackingExprTooLong(max: byte, got: int) {$/;"	m
PackingField	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type PackingField #unboxed {$/;"	c
PackingField.Nonref	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Nonref(size: byte);$/;"	c
PackingField.Ref	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Ref;$/;"	c
PackingParamDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^class PackingParamDecl extends VarDecl {$/;"	c
PackingParamReused	$VIRGIL/aeneas/src/main/Error.v3	/^	def PackingParamReused(name: string) {$/;"	m
PackingProblem	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type PackingProblem(cases: Array<Array<PackingField>>, assignments: Array<(CaseField, Interval)>) #unboxed {$/;"	c
PackingRedefined	$VIRGIL/aeneas/src/main/Error.v3	/^	def PackingRedefined(p: Token) {$/;"	m
PackingSolution	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^class PackingSolution($/;"	c
PackingSolver	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^class PackingSolver(size: byte, refPatterns: RefPatterns) {$/;"	c
ParamDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ParamDecl extends VarDecl {$/;"	c
ParamDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def ParamDeclError(msg: string) {$/;"	m
ParamExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ParamExpr(token: Token) extends Expr {$/;"	c
ParamExprError	$VIRGIL/aeneas/src/main/Error.v3	/^	def ParamExprError(msg: string) {$/;"	m
ParsedFile	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^class ParsedFile {$/;"	c
Parser	$VIRGIL/aeneas/src/vst/Parser.v3	/^component Parser {$/;"	n
ParserState	$VIRGIL/aeneas/src/vst/ParserState.v3	/^class ParserState {$/;"	c
Partial	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Partial(op: Operator, facts: Fact.set);		\/\/ partially apply {op} to receiver$/;"	d
PartialBoundsChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var PartialBoundsChecks 	= flags.get("PartialBoundsChecks", level >= 1);$/;"	d
PartialMap	$VIRGIL/lib/util/Map.v3	/^class PartialMap<K, V> extends Map<K, V> {$/;"	c
PartialSpecialization	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var PartialSpecialization	= flags.get("PartialSpecialization", false);$/;"	d
Paths	$VIRGIL/aeneas/src/util/Paths.v3	/^component Paths {$/;"	n
PointerRangeStart	$VIRGIL/aeneas/src/v3/V3Range.v3	/^class PointerRangeStart(start: Addr) extends Val {$/;"	c
PointerType	$VIRGIL/aeneas/src/mach/Pointer.v3	/^class PointerType extends Type {$/;"	c
Pointer_OpCache	$VIRGIL/aeneas/src/mach/Pointer.v3	/^class Pointer_OpCache(ptrType: Type, it: IntType) {$/;"	c
Pointer_TypeCon	$VIRGIL/aeneas/src/mach/Pointer.v3	/^class Pointer_TypeCon extends TypeCon {$/;"	c
Poly	$VIRGIL/lib/util/Poly.v3	/^component Poly {$/;"	n
PostpassOptimize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var PostpassOptimize		= flags.get("PostpassOptimize", level >= 1);$/;"	d
Printer	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^class Printer(printer: VstPrinter) {$/;"	c
PriorBoundsChecks	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var PriorBoundsChecks 		= flags.get("PriorBoundsChecks", level >= 1);$/;"	d
Probe	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Probe(orig: IcInstr, probes: IcProbes);$/;"	d
Profiler	$VIRGIL/aeneas/src/main/Profiler.v3	/^class Profiler {$/;"	c
Program	$VIRGIL/aeneas/src/core/Program.v3	/^class Program {$/;"	c
ProgressPrinter	$VIRGIL/aeneas/src/util/Progress.v3	/^class ProgressPrinter(total: int) {$/;"	c
PtrAdd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAdd;$/;"	d
PtrAddRangeStart	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAddRangeStart;$/;"	d
PtrAtArrayElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtArrayElem;$/;"	d
PtrAtComponentField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtComponentField(field: IrField);$/;"	d
PtrAtComponentField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtComponentField(receiver: Type, field: VstField, ptrType: Type);$/;"	d
PtrAtContents	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtContents;$/;"	d
PtrAtEnd	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtEnd;$/;"	d
PtrAtField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtField(ptrType: Type);$/;"	d
PtrAtFieldError	$VIRGIL/aeneas/src/main/Error.v3	/^	def PtrAtFieldError() {$/;"	m
PtrAtLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtLength;$/;"	d
PtrAtObject	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtObject;$/;"	d
PtrAtObjectField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtObjectField(field: IrField);$/;"	d
PtrAtObjectField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtObjectField(receiver: Type, field: VstField, ptrType: Type);$/;"	d
PtrAtRangeElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRangeElem;$/;"	d
PtrAtRef	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRef;$/;"	d
PtrAtRefLayoutField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrAtRefLayoutField(offset: int);$/;"	d
PtrAtRefLayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtRefLayoutField(receiver: Type, field: VstLayoutField, ptrType: Type);$/;"	d
PtrCmpSwp	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrCmpSwp;$/;"	d
PtrLoad	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLoad;$/;"	d
PtrLt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLt;$/;"	d
PtrLteq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrLteq;$/;"	d
PtrStore	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrStore;$/;"	d
PtrSub	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case PtrSub;$/;"	d
R10	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def R10 = '\x0b';$/;"	d
R10	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R10 = gpr("r10", Arm64Regs.R10, true), R11 = gpr("r11", Arm64Regs.R11, true);$/;"	d
R10	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R10 = gpr("r10", X86_64Regs.R10, true);$/;"	d
R10	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	d
R10	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R10 = Arm64Gpr.new("x10", "w10", 10), R11 = Arm64Gpr.new("x11", "w11", 11);$/;"	d
R10	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	d
R10	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R10 = X86_64Gpr.new("r10b", "r10w", "r10d", "r10", 10);$/;"	d
R11	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def R11 = '\x0c';$/;"	d
R11	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R10 = gpr("r10", Arm64Regs.R10, true), R11 = gpr("r11", Arm64Regs.R11, true);$/;"	d
R11	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R11 = gpr("r11", X86_64Regs.R11, true);$/;"	d
R11	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	d
R11	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R10 = Arm64Gpr.new("x10", "w10", 10), R11 = Arm64Gpr.new("x11", "w11", 11);$/;"	d
R11	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R8;  case R9;  case R10; case R11;$/;"	d
R11	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R11 = X86_64Gpr.new("r11b", "r11w", "r11d", "r11", 11);$/;"	d
R12	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def R12 = '\x0d';$/;"	d
R12	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R12 = gpr("r12", Arm64Regs.R12, true), R13 = gpr("r13", Arm64Regs.R13, true);$/;"	d
R12	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R12 = gpr("r12", X86_64Regs.R12, true);$/;"	d
R12	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R12	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R12 = Arm64Gpr.new("x12", "w12", 12), R13 = Arm64Gpr.new("x13", "w13", 13);$/;"	d
R12	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R12	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R12 = X86_64Gpr.new("r12b", "r12w", "r12d", "r12", 12);$/;"	d
R13	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R12 = gpr("r12", Arm64Regs.R12, true), R13 = gpr("r13", Arm64Regs.R13, true);$/;"	d
R13	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R13 = gpr("r13", X86_64Regs.R13, true);$/;"	d
R13	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R13	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R12 = Arm64Gpr.new("x12", "w12", 12), R13 = Arm64Gpr.new("x13", "w13", 13);$/;"	d
R13	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R13	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R13 = X86_64Gpr.new("r13b", "r13w", "r13d", "r13", 13);$/;"	d
R14	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R14 = gpr("r14", Arm64Regs.R14, true), R15 = gpr("r15", Arm64Regs.R15, true);$/;"	d
R14	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R14 = gpr("r14", X86_64Regs.R14, true);$/;"	d
R14	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R14	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R14 = Arm64Gpr.new("x14", "w14", 14), R15 = Arm64Gpr.new("x15", "w15", 15); \/\/ PC$/;"	d
R14	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R14	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R14 = X86_64Gpr.new("r14b", "r14w", "r14d", "r14", 14);$/;"	d
R15	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R14 = gpr("r14", Arm64Regs.R14, true), R15 = gpr("r15", Arm64Regs.R15, true);$/;"	d
R15	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def R15 = gpr("r15", X86_64Regs.R15, true);$/;"	d
R15	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R15	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R14 = Arm64Gpr.new("x14", "w14", 14), R15 = Arm64Gpr.new("x15", "w15", 15); \/\/ PC$/;"	d
R15	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R12; case R13; case R14; case R15;$/;"	d
R15	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def R15 = X86_64Gpr.new("r15b", "r15w", "r15d", "r15", 15);$/;"	d
R16	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R16 = gpr("r16", Arm64Regs.R16, false), R17 = gpr("r17", Arm64Regs.R17, true);$/;"	d
R16	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R16 = Arm64Gpr.new("x16", "w16", 16), R17 = Arm64Gpr.new("x17", "w17", 17);$/;"	d
R16	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	d
R17	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R16 = gpr("r16", Arm64Regs.R16, false), R17 = gpr("r17", Arm64Regs.R17, true);$/;"	d
R17	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R16 = Arm64Gpr.new("x16", "w16", 16), R17 = Arm64Gpr.new("x17", "w17", 17);$/;"	d
R17	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	d
R18	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R18 = gpr("r18", Arm64Regs.R18, true);$/;"	d
R18	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R18 = Arm64Gpr.new("x18", "w18", 18), R19 = Arm64Gpr.new("x19", "w19", 19);$/;"	d
R18	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	d
R19	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R19 = gpr("r19", Arm64Regs.R19, true), R20 = gpr("r20", Arm64Regs.R20, true);$/;"	d
R19	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R18 = Arm64Gpr.new("x18", "w18", 18), R19 = Arm64Gpr.new("x19", "w19", 19);$/;"	d
R19	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R16; case R17; case R18; case R19;$/;"	d
R20	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R19 = gpr("r19", Arm64Regs.R19, true), R20 = gpr("r20", Arm64Regs.R20, true);$/;"	d
R20	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R20 = Arm64Gpr.new("x20", "w20", 20), R21 = Arm64Gpr.new("x21", "w21", 21);$/;"	d
R20	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	d
R21	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R21 = gpr("r21", Arm64Regs.R21, true), R22 = gpr("r22", Arm64Regs.R22, true);$/;"	d
R21	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R20 = Arm64Gpr.new("x20", "w20", 20), R21 = Arm64Gpr.new("x21", "w21", 21);$/;"	d
R21	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	d
R22	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R21 = gpr("r21", Arm64Regs.R21, true), R22 = gpr("r22", Arm64Regs.R22, true);$/;"	d
R22	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R22 = Arm64Gpr.new("x22", "w22", 22), R23 = Arm64Gpr.new("x23", "w23", 23);$/;"	d
R22	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	d
R23	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R23 = gpr("r23", Arm64Regs.R23, true), R24 = gpr("r24", Arm64Regs.R24, true);$/;"	d
R23	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R22 = Arm64Gpr.new("x22", "w22", 22), R23 = Arm64Gpr.new("x23", "w23", 23);$/;"	d
R23	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R20; case R21; case R22; case R23;$/;"	d
R24	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R23 = gpr("r23", Arm64Regs.R23, true), R24 = gpr("r24", Arm64Regs.R24, true);$/;"	d
R24	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R24 = Arm64Gpr.new("x24", "w24", 24), R25 = Arm64Gpr.new("x25", "w25", 25);$/;"	d
R24	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	d
R25	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R25 = gpr("r25", Arm64Regs.R25, true), R26 = gpr("r26", Arm64Regs.R26, true);$/;"	d
R25	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R24 = Arm64Gpr.new("x24", "w24", 24), R25 = Arm64Gpr.new("x25", "w25", 25);$/;"	d
R25	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	d
R26	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R25 = gpr("r25", Arm64Regs.R25, true), R26 = gpr("r26", Arm64Regs.R26, true);$/;"	d
R26	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R26 = Arm64Gpr.new("x26", "w26", 26), R27 = Arm64Gpr.new("x27", "w27", 27);$/;"	d
R26	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	d
R27	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R27 = gpr("r27", Arm64Regs.R27, true), R28 = gpr("r28", Arm64Regs.R28, true);$/;"	d
R27	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R26 = Arm64Gpr.new("x26", "w26", 26), R27 = Arm64Gpr.new("x27", "w27", 27);$/;"	d
R27	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R24; case R25; case R26; case R27;$/;"	d
R28	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R27 = gpr("r27", Arm64Regs.R27, true), R28 = gpr("r28", Arm64Regs.R28, true);$/;"	d
R28	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R28 = Arm64Gpr.new("x28", "w28", 28), R29 = Arm64Gpr.new("x29", "w29", 29);$/;"	d
R28	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	d
R29	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R29 = gpr("r29", Arm64Regs.R29, false);$/;"	d
R29	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R28 = Arm64Gpr.new("x28", "w28", 28), R29 = Arm64Gpr.new("x29", "w29", 29);$/;"	d
R29	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	d
R30	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def R30 = gpr("r30", Arm64Regs.R30, false);$/;"	d
R30	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def R30 = Arm64Gpr.new("x30", "w30", 30), SP = Arm64Gpr.new("sp", "wsp", 31);$/;"	d
R30	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	d
R31	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	case R28; case R29; case R30; case R31;$/;"	d
RAX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RAX = gpr("rax", X86_64Regs.RAX, true);$/;"	d
RAX	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RAX = X86_64Gpr.new("al", "ax", "eax", "rax", 0);$/;"	d
RAX_RDX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RAX_RDX = set("{rax,rdx}", [RAX, RDX]);$/;"	d
RBP	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RBP = gpr("rbp", X86_64Regs.RBP, false);$/;"	d
RBP	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RBP = X86_64Gpr.new("bpl", "bp", "ebp", "rbp", 5);$/;"	d
RBX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RBX = gpr("rbx", X86_64Regs.RBX, true);$/;"	d
RBX	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RBX = X86_64Gpr.new("bl", "bx", "ebx", "rbx", 3);$/;"	d
RCX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RCX = gpr("rcx", X86_64Regs.RCX, true);$/;"	d
RCX	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RCX = X86_64Gpr.new("cl", "cx", "ecx", "rcx", 1);$/;"	d
RDI	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RDI = gpr("rdi", X86_64Regs.RDI, true);$/;"	d
RDI	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RDI = X86_64Gpr.new("dil", "di", "edi", "rdi", 7);$/;"	d
RDX	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RDX = gpr("rdx", X86_64Regs.RDX, true);$/;"	d
RDX	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RDX = X86_64Gpr.new("dl", "dx", "edx", "rdx", 2);$/;"	d
READONLY_ARRAYS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def READONLY_ARRAYS	= langOpt.newBoolOption("read-only-arrays", false,$/;"	d
REDEF_FIELD	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def REDEF_FIELD		= compileOpt.newStringOption("redef-field", null,$/;"	d
REF_ARRAY_TAG	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def REF_ARRAY_TAG = 3;$/;"	d
REF_TYPE_PARAM	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def REF_TYPE_PARAM = List.new(newTypeParamWithConstraint(BUILTIN_TOKEN, globalCache,$/;"	d
REGS	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^def REGS = MachRegSet.new(1, [[1]], ["tos"], [1], [1], 1000, 2000);$/;"	d
REL32	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^def REL32 = '\x88';$/;"	d
REL_CONST	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def REL_CONST = 0x44332205;$/;"	d
REL_MARKER	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^def REL_MARKER = 0xAABBCCDD;$/;"	d
REL_MARKER	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def REL_MARKER = 0xAABBCCDD;$/;"	d
REL_MARKER	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^def REL_MARKER = 0x55443388;$/;"	d
RET	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def RET		= '\xa9'; \/\/ 169$/;"	d
RETURN	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^def RETURN = '\xFE';$/;"	d
RETURN	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def RETURN		= '\xb1'; \/\/ 177$/;"	d
RET_GPRS	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def RET_GPRS = [R.R0]; 				\/\/ System-V + 2$/;"	d
RET_GPRS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RET_GPRS = [R.RAX, R.RDX, R.RCX, R.RSI]; 					\/\/ System-V + 2$/;"	d
RET_XMMS	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def RET_XMMS: Array<byte> = [];						\/\/ System-V$/;"	d
RET_XMMS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RET_XMMS = [R.XMM0, R.XMM1];						\/\/ System-V$/;"	d
REX_B	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def REX_B: byte		= 0b00000001;$/;"	d
REX_BYTE	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def REX_BYTE: byte	= 0b01000000;$/;"	d
REX_R	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def REX_R: byte		= 0b00000100;$/;"	d
REX_W	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def REX_W: byte		= 0b00001000;$/;"	d
REX_X	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def REX_X: byte		= 0b00000010;$/;"	d
ROOT_VARIANT	$VIRGIL/aeneas/src/vst/Vst.v3	/^def ROOT_VARIANT = -1;$/;"	d
ROUNDING_SHIFT	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def ROUNDING_SHIFT = u5.view(17);$/;"	d
ROUNDI_TYPE_PARAM_LIST	$VIRGIL/aeneas/src/types/Float.v3	/^	def ROUNDI_TYPE_PARAM_LIST = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
RO_TYPECON	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def RO_TYPECON = V3Ref_TypeCon.new(null, false, TypeUtil.globalCache);$/;"	d
RO_TYPECON	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	def RO_TYPECON = Simple_TypeCon.new("array", Kind.ARRAY, 1, TypeUtil.globalCache, ArrayType.new(_, false, _, _));$/;"	d
RO_TYPECON	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def RO_TYPECON = Simple_TypeCon.new("range", Kind.RANGE, 1, TypeUtil.globalCache, RangeType.new(_, false, _, _));$/;"	d
RSI	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def RSI = gpr("rsi", X86_64Regs.RSI, true);$/;"	d
RSI	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RSI = X86_64Gpr.new("sil", "si", "esi", "rsi", 6);$/;"	d
RSP	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def RSP = X86_64Gpr.new("spl", "sp", "esp", "rsp", 4);$/;"	d
RT_FILES	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RT_FILES		= rtOpt.newOption("rt.files", Array<string>.new(0), "=<path*>", parseStringArray,$/;"	d
RT_GC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RT_GC		= rtOpt.newBoolOption("rt.gc", false,$/;"	d
RT_GCTABLES	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RT_GCTABLES		= rtOpt.newBoolOption("rt.gctables", false,$/;"	d
RT_STTABLES	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RT_STTABLES		= rtOpt.newBoolOption("rt.sttables", false,$/;"	d
RT_TEST_GC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RT_TEST_GC		= rtOpt.newBoolOption("rt.test-gc", false,$/;"	d
RUN	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def RUN			= actionOpt.newBoolOption("run", false,$/;"	d
RW_TYPECON	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def RW_TYPECON = V3Ref_TypeCon.new(null, true, TypeUtil.globalCache);$/;"	d
RZR	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def RZR = Arm64Gpr.new("xzr", "wzr", 31);$/;"	d
RaArray	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaArray extends RaType {$/;"	c
RaClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaClass extends RaType {$/;"	c
RaDevirtualize	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var RaDevirtualize		= flags.get("RaDevirtualize", level >= 1);$/;"	d
RaField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaField(receiver: Type, orig: IrField, fieldType: Type) extends RaItem {$/;"	c
RaItem	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaItem {$/;"	c
RaMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaMethod(receiver: Type, orig: IrMethod, spec: IrSpec) extends RaItem {$/;"	c
RaTarget	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaTarget extends Target("ra") {$/;"	c
RaType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaType(oldType: Type) extends RaItem {$/;"	c
RaVirtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class RaVirtual(raMethod: RaMethod) {$/;"	c
Random	$VIRGIL/lib/util/Random.v3	/^component Random {$/;"	n
RangeExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class RangeExpr(expr: Expr, start: Expr, plus: bool, end: Expr) extends Expr {$/;"	c
RangeFromPlus	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeFromPlus;$/;"	d
RangeFromTo	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeFromTo;$/;"	d
RangeGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeGetElem;$/;"	d
RangeGetLength	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeGetLength;$/;"	d
RangeNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class RangeNorm extends TypeNorm {$/;"	c
RangeSetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeSetElem;$/;"	d
RangeStartFromPointer	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeStartFromPointer;$/;"	d
RangeStartPlusIndex	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RangeStartPlusIndex;$/;"	d
RangeStartType	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var RangeStartType: IntType;$/;"	d
RangeStartType	$VIRGIL/aeneas/src/v3/V3Range.v3	/^class RangeStartType extends Type {$/;"	c
RangeType	$VIRGIL/aeneas/src/v3/V3Range.v3	/^class RangeType extends Type {$/;"	c
Ranges	$VIRGIL/lib/util/Ranges.v3	/^component Ranges {$/;"	n
Reachability	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var Reachability		= CLOptions.RA.get();$/;"	d
ReachabilityAnalyzer	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class ReachabilityAnalyzer(compilation: Compilation) {$/;"	c
ReachabilityNormalizer	$VIRGIL/aeneas/src/ir/Normalization.v3	/^class ReachabilityNormalizer(config: NormalizerConfig, ra: ReachabilityAnalyzer) {$/;"	c
Record	$VIRGIL/aeneas/src/core/Program.v3	/^class Record(id: int, rtype: Type, values: Array<Val>) extends Val {$/;"	c
Ref	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Ref;$/;"	d
RefEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefEq;$/;"	d
RefLayoutAt	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutAt;$/;"	d
RefLayoutAtRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutAtRepeatedField(offset: int, scale: int, max: int);$/;"	d
RefLayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutField(receiver: RefType, member: VstLayoutField);$/;"	d
RefLayoutGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutGetField(offset: int);$/;"	d
RefLayoutGetRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutGetRepeatedField(offset: int, scale: int, max: int);$/;"	d
RefLayoutIn	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutIn(offset: int);$/;"	d
RefLayoutNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutNested(receiver: RefType, member: VstLayoutField);$/;"	d
RefLayoutOf	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutOf;$/;"	d
RefLayoutRepeatedField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutRepeatedField(receiver: RefType, member: VstLayoutField);$/;"	d
RefLayoutRepeatedNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutRepeatedNested(receiver: RefType, member: VstLayoutField);$/;"	d
RefLayoutSetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutSetField(offset: int);$/;"	d
RefLayoutSetRepeatedField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case RefLayoutSetRepeatedField(offset: int, scale: int, max: int);$/;"	d
RefMap	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case RefMap(livepoint: int, outgoing: MachCallConv);$/;"	d
RefNull	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case RefNull(ht: WasmHeapType);$/;"	d
RefPatterns	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^class RefPatterns($/;"	c
RefType	$VIRGIL/aeneas/src/v3/Ref.v3	/^class RefType extends Type {$/;"	c
Reg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case Reg(rm: ArmReg);$/;"	d
RegAllocStatistic	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^class RegAllocStatistic {$/;"	c
RegRorImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegRorImm(rm: ArmReg, shift: u5);$/;"	d
RegRorReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegRorReg(rm: ArmReg, rs: ArmReg);$/;"	d
RegSarImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegSarImm(rm: ArmReg, shift: u5);$/;"	d
RegSarReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegSarReg(rm: ArmReg, rs: ArmReg);$/;"	d
RegShlImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShlImm(rm: ArmReg, shift: u5);$/;"	d
RegShlReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShlReg(rm: ArmReg, rs: ArmReg);$/;"	d
RegShrImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShrImm(rm: ArmReg, shift: u5);$/;"	d
RegShrReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case RegShrReg(rm: ArmReg, rs: ArmReg);$/;"	d
RegState	$VIRGIL/aeneas/src/mach/RegState.v3	/^class RegState(regSet: MachRegSet, codegen: SsaMachGen) {$/;"	c
Region	$VIRGIL/aeneas/src/mach/Memory.v3	/^class Region(name: string, space: AddressSpace) {$/;"	c
Regs	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^def Regs: Arm64RegSet;$/;"	d
Regs	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^def Regs: Arm64RegSet;$/;"	d
Regs	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^def Regs: X86_64RegSet;$/;"	d
Regs	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^def Regs: X86_64RegSet;$/;"	d
Regs	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def Regs: X86_64Regs;$/;"	d
Regs	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def Regs: X86_64Regs;$/;"	d
Regs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^def Regs: X86RegSet;$/;"	d
Regs	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def Regs: X86RegSet;$/;"	d
Repeated	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Repeated(ex: u4, count: u4, framewords: u20)	#packing 0b_11111111_11111111_1111eeee_ccccffff_ffffffff_ffffffff;$/;"	d
ResolvedMember	$VIRGIL/aeneas/src/vst/Verifier.v3	/^class ResolvedMember(receiver: Type, member: VstMember, typeArgs: TypeArgs, memberType: Type) {$/;"	c
Result	$VIRGIL/aeneas/src/core/Value.v3	/^class Result { }$/;"	c
Result	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	case Result(v: T);$/;"	d
Ret	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Ret(arg: int);$/;"	d
Ret	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Ret(r: SsaReturn);$/;"	d
Return	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Return(t: Type);$/;"	d
ReturnStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class ReturnStmt(src: FileRange, expr: Expr) extends Stmt {$/;"	c
ReturnType	$VIRGIL/aeneas/src/vst/Vst.v3	/^type ReturnType {$/;"	c
ReturnType.Explicit	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Explicit(tref: TypeRef);	\/\/ -> typeref$/;"	c
ReturnType.Implicit	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Implicit(expr: Expr);	\/\/ => expr$/;"	c
ReturnType.This	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case This(token: Token);	\/\/ -> this$/;"	c
ReturnType.Void	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Void;			\/\/ omitted$/;"	c
RiOs	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^component RiOs {$/;"	n
RiscV64Assembler	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^class RiscV64Assembler(w: DataWriter) {$/;"	c
RiscV64Regs	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^component RiscV64Regs {$/;"	n
S10	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def S10 = RiscV64Gpr.X26;$/;"	d
S11	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def S11 = RiscV64Gpr.X27;$/;"	d
SALOAD	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def SALOAD	= '\x35'; \/\/ 53$/;"	d
SAR_shifter	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^def SAR_shifter = X86Shifter.new(Opcode.IntSar);$/;"	d
SASTORE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def SASTORE	= '\x56'; \/\/ 86$/;"	d
SCRATCH	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def SCRATCH = ArmReg.R12;$/;"	d
SCRATCH	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def SCRATCH = X86Regs.EBP;$/;"	d
SCRATCH_GPR	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def SCRATCH_GPR = R16;$/;"	d
SCRATCH_GPR	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def SCRATCH_GPR = RBP;$/;"	d
SEEK_CUR	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SEEK_CUR = 1;$/;"	d
SEEK_END	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SEEK_END = 2;$/;"	d
SEEK_SET	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SEEK_SET = 0; \/\/ constants for lseek$/;"	d
SET	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def SET = MachRegSet.new(physRegs, regSets, regNames, regClasses, [],$/;"	d
SET	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def SET = MachRegSet.new(PHYS_COUNT, ALL_ARRAY, ALL_NAMES, rclasses, tmps,$/;"	d
SET_EXEC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def SET_EXEC		= compileOpt.newBoolOption("set-exec", true,$/;"	d
SFRS	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def SFRS = [$/;"	d
SHADOW_STACK_CUR_PTR	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SHADOW_STACK_CUR_PTR    = addr("SHADOW_STACK_CUR_PTR");$/;"	d
SHADOW_STACK_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SHADOW_STACK_END        = addr("SHADOW_STACK_END");$/;"	d
SHADOW_STACK_END_PTR	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SHADOW_STACK_END_PTR    = addr("SHADOW_STACK_END_PTR");$/;"	d
SHADOW_STACK_PERCENT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def SHADOW_STACK_PERCENT= wasmOpt.newSizeOption("shadow-stack-percent", 0,$/;"	d
SHADOW_STACK_SIZE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def SHADOW_STACK_SIZE	= wasmOpt.newSizeOption("shadow-stack-size", 0,$/;"	d
SHADOW_STACK_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SHADOW_STACK_START      = addr("SHADOW_STACK_START");$/;"	d
SHADOW_STACK_START_PTR	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SHADOW_STACK_START_PTR  = addr("SHADOW_STACK_START_PTR");$/;"	d
SHF_ALLOC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHF_ALLOC = '\x02';$/;"	d
SHF_EXECINSTR	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHF_EXECINSTR = '\x04';$/;"	d
SHF_WRITE	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHF_WRITE = '\x01';$/;"	d
SHL_shifter	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^def SHL_shifter = X86Shifter.new(Opcode.IntShl);$/;"	d
SHORT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SHORT   = JvmPrimitive.new("short", "S", "S", KIND_SHORT);$/;"	d
SHR_shifter	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^def SHR_shifter = X86Shifter.new(Opcode.IntShr);$/;"	d
SHT_PROGBITS	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHT_PROGBITS = 1;$/;"	d
SHT_STRTAB	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHT_STRTAB = 3;$/;"	d
SHT_SYMTAB	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def SHT_SYMTAB = 2;$/;"	d
SIGNAL_RESTORER	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SIGNAL_RESTORER       = addr("signalRestorer");$/;"	d
SIGNAL_STUB	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SIGNAL_STUB           = addr("signalStub");$/;"	d
SIG_BYTE_ARRAY_INT_BYTE_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_BYTE_INT_VOID	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, BYTE, INT], VOID);$/;"	d
SIG_BYTE_ARRAY_INT_DOUBLE_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_DOUBLE_INT_VOID 	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, DOUBLE, INT], VOID);$/;"	d
SIG_BYTE_ARRAY_INT_FLOAT_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_FLOAT_INT_VOID 	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, FLOAT, INT], VOID);$/;"	d
SIG_BYTE_ARRAY_INT_INT_BYTE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_BYTE 	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], BYTE);$/;"	d
SIG_BYTE_ARRAY_INT_INT_DOUBLE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_DOUBLE	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], DOUBLE);$/;"	d
SIG_BYTE_ARRAY_INT_INT_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_FLOAT	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], FLOAT);$/;"	d
SIG_BYTE_ARRAY_INT_INT_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_INT 		= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], INT);$/;"	d
SIG_BYTE_ARRAY_INT_INT_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_INT_VOID	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT, INT], VOID);$/;"	d
SIG_BYTE_ARRAY_INT_INT_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_LONG 	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], LONG);$/;"	d
SIG_BYTE_ARRAY_INT_INT_SHORT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_INT_SHORT 	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, INT], SHORT);$/;"	d
SIG_BYTE_ARRAY_INT_LONG_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_LONG_INT_VOID	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, LONG, INT], VOID);$/;"	d
SIG_BYTE_ARRAY_INT_SHORT_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_BYTE_ARRAY_INT_SHORT_INT_VOID	= JvmSig.new([JvmTypes.BYTE_ARRAY, INT, SHORT, INT], VOID);$/;"	d
SIG_DOUBLE_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_BOOLEAN       = JvmSig.new([DOUBLE], BOOLEAN);$/;"	d
SIG_DOUBLE_DOUBLE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_DOUBLE        = JvmSig.new([DOUBLE], DOUBLE);$/;"	d
SIG_DOUBLE_DOUBLE_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_DOUBLE_BOOLEAN = JvmSig.new([DOUBLE, DOUBLE], BOOLEAN);$/;"	d
SIG_DOUBLE_DOUBLE_DOUBLE_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_DOUBLE_DOUBLE_BOOLEAN  = JvmSig.new([DOUBLE, DOUBLE, DOUBLE], BOOLEAN);$/;"	d
SIG_DOUBLE_DOUBLE_DOUBLE_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_DOUBLE_DOUBLE_LONG  = JvmSig.new([DOUBLE, DOUBLE, DOUBLE], LONG);$/;"	d
SIG_DOUBLE_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_FLOAT         = JvmSig.new([DOUBLE], FLOAT);$/;"	d
SIG_DOUBLE_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_DOUBLE_LONG          = JvmSig.new([DOUBLE], LONG);$/;"	d
SIG_EQUALS	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_EQUALS               = JvmSig.new([java_lang_Object, java_lang_Object], BOOLEAN);$/;"	d
SIG_EQUALV	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_EQUALV               = JvmSig.new([java_lang_Object], BOOLEAN);$/;"	d
SIG_FLOAT_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_FLOAT_FLOAT          = JvmSig.new([FLOAT], FLOAT);$/;"	d
SIG_FLOAT_FLOAT_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_FLOAT_FLOAT_BOOLEAN  = JvmSig.new([FLOAT, FLOAT], BOOLEAN);$/;"	d
SIG_FLOAT_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_FLOAT_INT            = JvmSig.new([FLOAT], INT);$/;"	d
SIG_INT_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_BOOLEAN          = JvmSig.new([INT], BOOLEAN);$/;"	d
SIG_INT_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_FLOAT            = JvmSig.new([INT], FLOAT);$/;"	d
SIG_INT_INTEGER	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_INTEGER          = JvmSig.new([INT], java_lang_Integer);$/;"	d
SIG_INT_INT_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_INT_INT          = JvmSig.new([INT, INT], INT);$/;"	d
SIG_INT_INT_INT_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_INT_INT_INT      = JvmSig.new([INT, INT, INT], INT);$/;"	d
SIG_INT_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_INT_VOID             = JvmSig.new([INT], VOID);$/;"	d
SIG_JAVA_MAIN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_JAVA_MAIN            = JvmSig.new([STRING_ARRAY], JvmTypes.VOID);$/;"	d
SIG_LONG_BOOLEAN	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_BOOLEAN         = JvmSig.new([LONG], BOOLEAN);$/;"	d
SIG_LONG_BYTE_BYTE_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_BYTE_BYTE_LONG  = JvmSig.new([LONG, BYTE, BYTE], LONG);$/;"	d
SIG_LONG_DOUBLE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_DOUBLE          = JvmSig.new([LONG], DOUBLE);$/;"	d
SIG_LONG_FLOAT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_FLOAT           = JvmSig.new([LONG], FLOAT);$/;"	d
SIG_LONG_LONG_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_LONG_INT        = JvmSig.new([LONG, LONG], INT);$/;"	d
SIG_LONG_LONG_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_LONG_LONG       = JvmSig.new([LONG, LONG], LONG);$/;"	d
SIG_LONG_LONG_LONG_LONG	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_LONG_LONG_LONG_LONG  = JvmSig.new([LONG, LONG, LONG], LONG);$/;"	d
SIG_STRING_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_STRING_VOID          = JvmSig.new([java_lang_String], VOID);$/;"	d
SIG_VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_VOID                 = JvmSig.new([], VOID);$/;"	d
SIG_VOID_BYTE_ARRAY	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_VOID_BYTE_ARRAY      = JvmSig.new([], JvmTypes.BYTE_ARRAY);$/;"	d
SIG_VOID_INT	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def SIG_VOID_INT             = JvmSig.new([], INT);$/;"	d
SIPUSH	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def SIPUSH	= '\x11'; \/\/ 17$/;"	d
SLOW	$VIRGIL/aeneas/src/ic/Ic.v3	/^def SLOW = 1;$/;"	d
SPACE	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def SPACE = AddressSpace.new("mem", false, 32, 4, Alignment.new(65536), Alignment.new(4));$/;"	d
SPACE	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def SPACE = AddressSpace.new("mem", false, 64, 8,$/;"	d
SPACE	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def SPACE = AddressSpace.new("mem", false, 64, 8,$/;"	d
SPACE	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^def SPACE = AddressSpace.new("mem", false, 32, 4,$/;"	d
SPACE	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^def SPACE = AddressSpace.new("mem", false, 32, 4,$/;"	d
SRC_CLASS_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_CLASS_TABLE       = addr("SRC_CLASS_TABLE");$/;"	d
SRC_METHODS_PAGES	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_METHODS_PAGES     = addr("SRC_METHODS_PAGES");$/;"	d
SRC_METHODS_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_METHODS_TABLE     = addr("SRC_METHODS_TABLE");$/;"	d
SRC_METHODS_TABLE_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_METHODS_TABLE_END = addr("SRC_METHODS_TABLE_END");$/;"	d
SRC_POINTS_PAGES	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_POINTS_PAGES      = addr("SRC_POINTS_PAGES");$/;"	d
SRC_POINTS_TABLE	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_POINTS_TABLE      = addr("SRC_POINTS_TABLE");$/;"	d
SRC_STRINGS	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def SRC_STRINGS           = addr("SRC_STRINGS");$/;"	d
SSA_INT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def SSA_INT		= runOpt.newBoolOption("ssa-int", false,$/;"	d
SSEAddr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class SSEAddr(base: X86Reg, index: X86Reg, scale: byte, disp: int) extends SSERm {$/;"	c
SSECmp	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class SSECmp(name: string, index: int) {$/;"	c
SSECmps	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^component SSECmps {$/;"	n
SSEReg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class SSEReg(name: string, index: int) extends SSERm {$/;"	c
SSERm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class SSERm {$/;"	c
SSE_CLASS	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def SSE_CLASS = '\x16';$/;"	d
SSE_SCRATCH	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def SSE_SCRATCH = X86Regs.XMM7;$/;"	d
STACK_END	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def STACK_END             = addr("STACK_END");$/;"	d
STACK_SIZE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def STACK_SIZE		= rtOpt.newSizeOption("stack-size", 0,$/;"	d
STACK_START	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def STACK_START           = addr("STACK_START");$/;"	d
STACK_START_ADDR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def STACK_START_ADDR	= rtOpt.newAddrOption("stack-start-addr", 0,$/;"	d
START	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def START: byte = 8;	 \/\/ Start function declaration$/;"	d
START_TYPE	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def START_TYPE = TypeUtil.singleType("#RangeStart", Kind.RANGE_START, RangeStartType.new);$/;"	d
START_UID	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def START_UID		= debugOpt.newIntOption("start-uid", 0,$/;"	d
STAT_ST_SIZE	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def STAT_ST_SIZE = 72; \/\/ offset of st_size in statbuf$/;"	d
STB_GLOBAL	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STB_GLOBAL = '\x10';$/;"	d
STB_LOCAL	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STB_LOCAL = '\x00';$/;"	d
STB_WEAK	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STB_WEAK = '\x20';$/;"	d
STDERR	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def STDERR = 2;$/;"	d
STDERR	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def STDERR = 2;$/;"	d
STDIN	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def STDIN = 0;$/;"	d
STDIN	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def STDIN = 0;$/;"	d
STDIN	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def STDIN  = 0;$/;"	d
STDOUT	$VIRGIL/aeneas/src/util/Terminal.v3	/^def STDOUT = System.write(1, _);$/;"	d
STDOUT	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def STDOUT = 1;$/;"	d
STDOUT	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def STDOUT = 1;$/;"	d
STENTSIZE32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STENTSIZE32 = 16; \/\/ size of symbol table entry$/;"	d
STENTSIZE64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STENTSIZE64 = 24; \/\/ size of symbol table entry$/;"	d
STRING_ARRAY	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def STRING_ARRAY: JvmArray_Type = JvmTypes.java_lang_String.arrayType();$/;"	d
STT_FILE	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STT_FILE = '\x04';$/;"	d
STT_FUNC	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STT_FUNC = '\x02';$/;"	d
STT_OBJECT	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STT_OBJECT = '\x01';$/;"	d
STT_SECTION	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def STT_SECTION = '\x03';$/;"	d
SWAP	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def SWAP	= '\x5f'; \/\/ 95$/;"	d
SYMBOLS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def SYMBOLS		= compileOpt.newBoolOption("symbols", false,$/;"	d
SYSNUM	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def SYSNUM = Regs.RAX;$/;"	d
SYSNUM	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def SYSNUM = Regs.RAX;$/;"	d
SYS_RT_sigreturn	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def SYS_RT_sigreturn = 0x20000B8;$/;"	d
SYS_chmod	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_chmod = 0x200000F;$/;"	d
SYS_close	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_close = 0x2000006;$/;"	d
SYS_exit	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def SYS_exit = 0x2000001;$/;"	d
SYS_exit	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_exit = 0x2000001;$/;"	d
SYS_fork	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_fork = 0x2000002;$/;"	d
SYS_fstat	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_fstat = 0x20000BD;$/;"	d
SYS_gettimeofday	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_gettimeofday = 0x2000074;$/;"	d
SYS_ioctl	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_ioctl = 0x20000FE;$/;"	d
SYS_lseek	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_lseek = 0x20000C7;$/;"	d
SYS_mprotect	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_mprotect = 0x200004A;$/;"	d
SYS_open	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_open = 0x2000005;$/;"	d
SYS_poll	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_poll = 0x20000E6;$/;"	d
SYS_read	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_read = 0x2000003;$/;"	d
SYS_sigaction	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def SYS_sigaction = 0x200002E;$/;"	d
SYS_sigaction	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_sigaction = 0x200002E;$/;"	d
SYS_sigaltstack	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_sigaltstack = 0x2000035;$/;"	d
SYS_stat	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_stat = 0x20000BC;$/;"	d
SYS_write	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^def SYS_write = 0x2000004;$/;"	d
SYS_write	$VIRGIL/rt/x86-64-darwin/DarwinConst.v3	/^	def SYS_write = 0x2000004;$/;"	d
ScalarPattern	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^class ScalarPattern(bits: Array<PackingBit>) {$/;"	c
ScalarPatterns	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^component ScalarPatterns {$/;"	n
Scratch	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Scratch(regClass: RegClass);$/;"	d
ServerSocket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^class ServerSocket extends Socket {$/;"	c
ShadowStackSpiller	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^class ShadowStackSpiller() {$/;"	c
Signature	$VIRGIL/aeneas/src/types/Function.v3	/^class Signature {$/;"	c
SimpleRegAlloc	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^class SimpleRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {$/;"	c
Simple_TypeCon	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^class Simple_TypeCon extends TypeCon {$/;"	c
Socket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^class Socket {$/;"	c
Solve	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Solve(l: VstList<VstPackingExpr>);				\/\/ #solve(_, ...)$/;"	d
Some	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case Some(patterns: List<VstPattern>);$/;"	d
Source	$VIRGIL/aeneas/src/core/Value.v3	/^class Source(mdecl: VstMethod, line: int, column: int, tail: Source, range: FileRange) {$/;"	c
SourceCodeError	$VIRGIL/aeneas/src/main/Error.v3	/^class SourceCodeError extends Error {$/;"	c
SpecEdge	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class SpecEdge extends Edge<SpecMethod> {$/;"	c
SpecMethod	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class SpecMethod(uid: int, raMethod: RaMethod) {$/;"	c
SpecSet	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class SpecSet(uid: int, method: IrMethod) {$/;"	c
SpecSigNode	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class SpecSigNode {$/;"	c
SpecSignature	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class SpecSignature {$/;"	c
Specializer	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^class Specializer(ra: ReachabilityAnalyzer, rn: ReachabilityNormalizer) {$/;"	c
SpillQueue	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^class SpillQueue {$/;"	c
SrcPrinter	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^class SrcPrinter(vstFiles: Array<VstFile>, interp: SsaInterpreter) {$/;"	c
Ssa	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^component Ssa {$/;"	n
SsaApplyOp	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaApplyOp extends SsaInstr {$/;"	c
SsaArm64Gen	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^class SsaArm64Gen extends SsaMachGen {$/;"	c
SsaBlock	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaBlock extends SsaLink {$/;"	c
SsaBlockInfo	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^class SsaBlockInfo(block: SsaBlock) {$/;"	c
SsaBlockOrder	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^class SsaBlockOrder(graph: SsaGraph) {$/;"	c
SsaBlockProfiler	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^class SsaBlockProfiler {$/;"	c
SsaBlockProfilerProbe	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^private class SsaBlockProfilerProbe extends SsaProbe {$/;"	c
SsaBlockSplit	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^class SsaBlockSplit {$/;"	c
SsaBlockState	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaBlockState {$/;"	c
SsaBuilder	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^class SsaBuilder extends SsaBlockState {$/;"	c
SsaCallEntryProbe	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^private class SsaCallEntryProbe(tracer: SsaCallTracer) extends SsaProbe {$/;"	c
SsaCallRetProbe	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^private class SsaCallRetProbe(tracer: SsaCallTracer) extends SsaProbe {$/;"	c
SsaCallTracer	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^class SsaCallTracer(matcher: VstMatcher, traceParent: bool) {$/;"	c
SsaCfEdge	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaCfEdge {$/;"	c
SsaCfOptimizer	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaCfOptimizer(context: SsaContext) {$/;"	c
SsaCheckpoint	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaCheckpoint extends SsaInstr {$/;"	c
SsaConst	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaConst(vtype: Type, val: Val) extends SsaInstr(null) {$/;"	c
SsaConstCacheEntry	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^class SsaConstCacheEntry(index: byte, vtype: Type, val: Val, facts: Fact.set) {$/;"	c
SsaContext	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^class SsaContext(compiler: Compiler, prog: Program) {$/;"	c
SsaCoverage	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^class SsaCoverage(compiler: Compiler, prog: Program, instr: bool) {$/;"	c
SsaCoverageProbe	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^class SsaCoverageProbe extends SsaProbe {$/;"	c
SsaDebugger	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^class SsaDebugger(prog: Program, genSsa: (IrSpec, int) -> SsaGraph, interp: SsaInterpreter) {$/;"	c
SsaDeconstructor	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^class SsaDeconstructor {$/;"	c
SsaDeleteVar	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaDeleteVar(n: int) extends SsaInstr(null) {$/;"	c
SsaDfEdge	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaDfEdge extends Edge<SsaInstr> {$/;"	c
SsaEarlyInliner	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^class SsaEarlyInliner(context: SsaContext, compilation: Compilation, gen: VstSsaGen) {$/;"	c
SsaEnd	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaEnd extends SsaInstr {$/;"	c
SsaExternalMarker	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^class SsaExternalMarker extends SsaMarker {$/;"	c
SsaGoto	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaGoto extends SsaEnd {$/;"	c
SsaGraph	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^class SsaGraph {$/;"	c
SsaGraphNormalizer	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^class SsaGraphNormalizer(context: SsaContext) {$/;"	c
SsaGraphVerifier	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^class SsaGraphVerifier(context: SsaContext) {$/;"	c
SsaIcBlock	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^class SsaIcBlock(block: SsaBlock) {$/;"	c
SsaIcGen	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^class SsaIcGen(context: SsaContext) {$/;"	c
SsaIf	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaIf extends SsaEnd {$/;"	c
SsaInliner	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^class SsaInliner extends SsaRebuilder {$/;"	c
SsaInstr	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaInstr extends SsaLink {$/;"	c
SsaInstrMatcher	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaInstrMatcher {$/;"	c
SsaInstrReducer	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaInstrReducer(context: SsaContext) extends SsaInstrMatcher {$/;"	c
SsaIntArguments	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^class SsaIntArguments(prog: Program) extends Arguments {$/;"	c
SsaIntFrame	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^class SsaIntFrame {$/;"	c
SsaInternalMarker	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^class SsaInternalMarker extends SsaMarker {$/;"	c
SsaInterpreter	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^class SsaInterpreter(prog: Program, genSsa: (IrSpec, int) -> SsaGraph) {$/;"	c
SsaJvmBlock	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^class SsaJvmBlock(block: SsaBlock) {$/;"	c
SsaJvmCompareBranch	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^class SsaJvmCompareBranch {$/;"	c
SsaJvmGen	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^class SsaJvmGen(jprog: JvmProgram, context: SsaContext, jsig: JvmSig, code: JvmCodeBuilder) {$/;"	c
SsaJvmInstr	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^class SsaJvmInstr {$/;"	c
SsaLinearIv	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaLinearIv {$/;"	c
SsaLink	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaLink {$/;"	c
SsaLoadOptimizer	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaLoadOptimizer(context: SsaContext) {$/;"	c
SsaLoadedFields	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaLoadedFields {$/;"	c
SsaLoopInfo	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^class SsaLoopInfo(index: int) {$/;"	c
SsaLoopNode	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^class SsaLoopNode(loop: SsaLoopInfo, start: List<SsaLoopNode>, end: List<SsaLoopNode>, block: SsaBlock) {$/;"	c
SsaLoopOptimizer	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaLoopOptimizer {$/;"	c
SsaLoopOrder	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^class SsaLoopOrder(order: SsaBlockOrder, count: int) {$/;"	c
SsaMachGen	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class SsaMachGen(context: SsaContext, mach: MachProgram, regSet: MachRegSet, w: MachDataWriter) {$/;"	c
SsaMap	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^class SsaMap {$/;"	c
SsaMarker	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^class SsaMarker {$/;"	c
SsaNewVar	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaNewVar extends SsaInstr {$/;"	c
SsaOptimizer	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SsaOptimizer(context: SsaContext) {$/;"	c
SsaParam	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaParam(index: int, vtype: Type) extends SsaInstr(null) {$/;"	c
SsaPhi	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaPhi extends SsaInstr {$/;"	c
SsaPrinter	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^class SsaPrinter {$/;"	c
SsaProbe	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaProbe extends SsaInstr(Ssa.NO_INSTRS) {$/;"	c
SsaRaNormalizer	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^class SsaRaNormalizer extends SsaRebuilder {$/;"	c
SsaRebuilder	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^class SsaRebuilder(context: SsaContext) {$/;"	c
SsaReturn	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaReturn extends SsaEnd {$/;"	c
SsaSwitch	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaSwitch extends SsaEnd {$/;"	c
SsaTarget	$VIRGIL/aeneas/src/ssa/SsaTarget.v3	/^class SsaTarget extends Target("ssa") {$/;"	c
SsaThrow	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaThrow extends SsaEnd {$/;"	c
SsaTreeProfiler	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^class SsaTreeProfiler extends TreeProfiler<SsaIntFrame> {$/;"	c
SsaTreeProfilerEntryProbe	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^private class SsaTreeProfilerEntryProbe(profiler: SsaTreeProfiler) extends SsaProbe {$/;"	c
SsaTreeProfilerRetProbe	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^private class SsaTreeProfilerRetProbe(profiler: SsaTreeProfiler) extends SsaProbe {$/;"	c
SsaUpdateVar	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^class SsaUpdateVar extends SsaInstr {$/;"	c
SsaX86_64Gen	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^class SsaX86_64Gen extends SsaMachGen {$/;"	c
Stack	$VIRGIL/lib/util/Stack.v3	/^class Stack<T> {$/;"	c
StatementError	$VIRGIL/aeneas/src/main/Error.v3	/^	def StatementError() {$/;"	m
Stmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class Stmt {$/;"	c
StoreNarrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var StoreNarrow = true;		 \/\/ enables store narrowing optimization$/;"	d
Stream	$VIRGIL/lib/util/IO.v3	/^class Stream {$/;"	c
StringBuilder	$VIRGIL/lib/util/StringBuilder.v3	/^class StringBuilder {$/;"	c
StringExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class StringExpr(token: Token, array: Array<byte>) extends Expr {$/;"	c
Strings	$VIRGIL/lib/util/Strings.v3	/^component Strings {$/;"	n
SubImm	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubImm(off: u8);$/;"	d
SubReg	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	case SubReg(rm: ArmReg);$/;"	d
SuperClause	$VIRGIL/aeneas/src/vst/Vst.v3	/^class SuperClause {$/;"	c
Switch	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Switch(arg: int, targets: Array<int>);$/;"	d
SwitchCmp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^class SwitchCmp(val: int, cmp: SsaInstr, end: SsaIf, tSucc: SsaCfEdge, fSucc: SsaCfEdge) { }$/;"	c
System	$VIRGIL/rt/x86-64-darwin/System.v3	/^component System {$/;"	n
SystemCall	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case SystemCall(syscall: SystemCall);$/;"	d
SystemCallState	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^class SystemCallState {$/;"	c
SystemCalls	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^component SystemCalls {$/;"	n
System_TypeCon	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^class System_TypeCon extends Member_TypeCon {$/;"	c
TABLE	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def TABLE: byte = 4;	 \/\/ Indirect function table and other tables$/;"	d
TABLESWITCH	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def TABLESWITCH		= '\xaa'; \/\/ 170$/;"	d
TAGGED_PTR_32	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def TAGGED_PTR_32 = RefPatterns.new($/;"	d
TAGGED_PTR_64	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def TAGGED_PTR_64 = RefPatterns.new($/;"	d
TARGET	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TARGET		= actionOpt.newOption("target", null, "=<target>", Aeneas.getTarget,$/;"	d
TCGETS	$VIRGIL/lib/term/Termios.v3	/^	def TCGETS     = 0x5401;     \/\/ TCGETS get terminal attributes$/;"	d
TCSETS	$VIRGIL/lib/term/Termios.v3	/^	def TCSETS     = 0x5402;     \/\/ TCSETS set terminal attributes$/;"	d
TEST	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TEST		= actionOpt.newBoolOption("test", false,$/;"	d
TEST_GC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TEST_GC		= testOpt.newStringOption("test.gc", "",$/;"	d
TEST_ST	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TEST_ST		= testOpt.newBoolOption("test.st", false,$/;"	d
TIOCGPTN	$VIRGIL/lib/term/Termios.v3	/^	def TIOCGPTN   = 0x80045430; \/\/ TIOCGPTN IOCTL used to get the PTY number$/;"	d
TIOCGWINSZ	$VIRGIL/lib/term/Termios.v3	/^	def TIOCGWINSZ = 0x5413;     \/\/ TIOCGWINSZ used to get the terminal window size$/;"	d
TIOCSPTLCK	$VIRGIL/lib/term/Termios.v3	/^	def TIOCSPTLCK = 0x40045431; \/\/ TIOCSPTLCK IOCT used to lock\/unlock PTY$/;"	d
TIOCSWINSZ	$VIRGIL/lib/term/Termios.v3	/^	def TIOCSWINSZ = 0x5414;     \/\/ TIOCSWINSZ used to set the terminal window size$/;"	d
TRACE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TRACE		= runOpt.newBoolOption("trace", false,$/;"	d
TRACE_CALLS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TRACE_CALLS		= runOpt.newMatcherOption("trace-calls",$/;"	d
TRACE_PARENT	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def TRACE_PARENT	= runOpt.newBoolOption("trace-parent", false,$/;"	d
TRANSFERRABLE_FACTS	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def TRANSFERRABLE_FACTS = (Fact.M_ABSTRACT | Fact.M_INLINE | Fact.M_OPERATOR | Fact.M_NEW | Fact.M_EMPTY | Fact.M_EQUALS);$/;"	d
TRUE	$VIRGIL/aeneas/src/types/Bool.v3	/^	def TRUE  = Box.new(true);$/;"	d
TRUE_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def TRUE_ENTRY = SsaConstCacheEntry.new(1, Bool.TYPE, Bool.TRUE, Fact.V_NON_ZERO);$/;"	d
TRUNCATE	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^def TRUNCATE = true;$/;"	d
TUPLE_MARK	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^def TUPLE_MARK = '\xFF';$/;"	d
TWO	$VIRGIL/aeneas/src/types/Int.v3	/^	def TWO       = Box.new(2);$/;"	d
TWO_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def TWO_ENTRY = SsaConstCacheEntry.new(5, Int.TYPE, Int.TWO, Facts.intFacts(2));$/;"	d
TYPE	$VIRGIL/aeneas/src/main/Error.v3	/^def TYPE(tref: Type) -> string {$/;"	f
TYPE	$VIRGIL/aeneas/src/types/Bool.v3	/^	def TYPE = TypeUtil.singleType("bool", Kind.BOOL, BoolType.new);$/;"	d
TYPE	$VIRGIL/aeneas/src/types/Byte.v3	/^	var TYPE = Int.getType(false, 8);$/;"	d
TYPE	$VIRGIL/aeneas/src/types/Int.v3	/^	def TYPE = Int.getType(true, 64);$/;"	d
TYPE	$VIRGIL/aeneas/src/types/Void.v3	/^	def TYPE = TypeUtil.singleType("void", Kind.VOID, VoidType.new);$/;"	d
TYPE	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def TYPE(tref: Type) -> string {$/;"	f
TYPE	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def TYPE: byte = 1;	 \/\/ Function signature declarations$/;"	d
TYPECON	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def TYPECON = Tuple_TypeCon.new();$/;"	d
TYPECON	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def TYPECON = System_TypeCon.new();$/;"	d
TYPECON	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	def TYPECON = Simple_TypeCon.new("Array", Kind.ARRAY, 1, TypeUtil.globalCache, ArrayType.new(_, true, _, _));$/;"	d
TYPECON	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def TYPECON = Simple_TypeCon.new("Range", Kind.RANGE, 1, TypeUtil.globalCache, RangeType.new(_, true, _, _));$/;"	d
TYPEPARAM_MASK	$VIRGIL/aeneas/src/types/Type.v3	/^	def TYPEPARAM_MASK = 0x20000000;$/;"	d
TYPEVAR_MASK	$VIRGIL/aeneas/src/types/Type.v3	/^	def TYPEVAR_MASK   = 0x40000000;$/;"	d
TYPE_MASK	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def TYPE_MASK = 0x3;$/;"	d
TYPE_PARAM	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def TYPE_PARAM = newTypeParam(BUILTIN_TOKEN, globalCache);$/;"	d
TYPE_PARAMS	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def TYPE_PARAMS = Lists.cons3(C, P, R);$/;"	d
TYPE_PARAM_KIND	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def TYPE_PARAM_KIND = '\x09';$/;"	d
TYPE_VAR_KIND	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def TYPE_VAR_KIND   = '\x0A';$/;"	d
TableIndex	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^class TableIndex<K, D>(hash: K -> int) {$/;"	c
Target	$VIRGIL/aeneas/src/main/Compiler.v3	/^class Target(name: string) {$/;"	c
TargetProgram	$VIRGIL/aeneas/src/core/Program.v3	/^class TargetProgram(prog: Program) {$/;"	c
Terminal	$VIRGIL/aeneas/src/util/Terminal.v3	/^component Terminal {$/;"	n
TerminalBuffer	$VIRGIL/aeneas/src/util/Terminal.v3	/^class TerminalBuffer extends StringBuilder {$/;"	c
Termios	$VIRGIL/lib/term/Termios.v3	/^component Termios {$/;"	n
TextReader	$VIRGIL/lib/util/TextReader.v3	/^class TextReader {$/;"	c
This	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case This(token: Token);	\/\/ -> this$/;"	d
Throw	$VIRGIL/aeneas/src/ic/Ic.v3	/^	case Throw(exception: string, src: Source);$/;"	d
Token	$VIRGIL/lib/util/Token.v3	/^class Token extends FilePoint {$/;"	c
Trace	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var Trace			= CLOptions.TRACE.get();$/;"	d
TraceCalls	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var TraceCalls			= CLOptions.TRACE_CALLS.get();$/;"	d
TraceParent	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var TraceParent			= CLOptions.TRACE_PARENT.get();$/;"	d
TreeProfiler	$VIRGIL/aeneas/src/main/Profiler.v3	/^class TreeProfiler<F> extends Profiler {$/;"	c
TryRepresentationChangeOfLiteral	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def TryRepresentationChangeOfLiteral(lit: IntLiteral, outer: Type) -> Type {$/;"	m
TryRepresentationChangeToFloat	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def TryRepresentationChangeToFloat(lit: IntLiteral, outer: Type) -> Type {$/;"	m
Tuple	$VIRGIL/aeneas/src/types/Tuple.v3	/^component Tuple {$/;"	n
TupleCreate	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TupleCreate(length: int);$/;"	d
TupleExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class TupleExpr(exprs: VstList<Expr>) extends Expr {$/;"	c
TupleGetElem	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TupleGetElem(index: int);$/;"	d
TupleNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class TupleNorm extends TypeNorm {$/;"	c
TupleType	$VIRGIL/aeneas/src/types/Tuple.v3	/^class TupleType extends Type {$/;"	c
TupleTypeRef	$VIRGIL/aeneas/src/vst/Vst.v3	/^class TupleTypeRef(nested: VstList<TypeRef>) extends TypeRef {$/;"	c
TupleVal	$VIRGIL/aeneas/src/types/Tuple.v3	/^class TupleVal(values: Array<Val>) extends Val {$/;"	c
Tuple_TypeCon	$VIRGIL/aeneas/src/types/Tuple.v3	/^class Tuple_TypeCon extends TypeCon {$/;"	c
Type	$VIRGIL/aeneas/src/types/Type.v3	/^class Type {$/;"	c
Type	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Type(t: Type);$/;"	d
TypeArgs	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeArgs(typeEnv: TypeEnv, types: Array<Type>) extends TypeSubst {$/;"	c
TypeCache	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeCache {$/;"	c
TypeCast	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeCast(cast: TypeCast);$/;"	d
TypeCast	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case TypeCast;		\/\/ overloading resolved if possible$/;"	d
TypeCastError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeCastError(fromType: Type, toType: Type, msg: string) {$/;"	m
TypeCheck	$VIRGIL/aeneas/src/v3/V3.v3	/^	def TypeCheck     = "TypeCheckException";$/;"	d
TypeChecker	$VIRGIL/aeneas/src/vst/Verifier.v3	/^class TypeChecker(ERROR: ErrorGen, file: VstFile) extends VstVisitor<Type, Type> {$/;"	c
TypeCon	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeCon {$/;"	c
TypeConst	$VIRGIL/aeneas/src/types/Type.v3	/^component TypeConst {$/;"	n
TypeEnv	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^class TypeEnv {$/;"	c
TypeError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeError(expected: Type, got: Type, what: string) {$/;"	m
TypeExprError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeExprError(t1: Type) {$/;"	m
TypeInferError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeInferError(reason: string) {$/;"	m
TypeNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^class TypeNorm(oldType: Type, newType: Type, sub: Array<Type>) {$/;"	c
TypeParamAbstracter	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^class TypeParamAbstracter(prog: Program) extends TypeSubst {$/;"	c
TypeParamArityError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeParamArityError(kind: string, name: string, expect: int, got: int) {$/;"	m
TypeParamInferError	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def TypeParamInferError(tvar: TypeVarType) -> Type {$/;"	m
TypeParamRedefined	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeParamRedefined(tparam: TypeParamType) {$/;"	m
TypeParamType	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeParamType extends Type {$/;"	c
TypeQuery	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeQuery(query: TypeQuery);$/;"	d
TypeQuery	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case TypeQuery;		\/\/ overloading resolved if possible$/;"	d
TypeQueryError	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeQueryError(fromType: Type, toType: Type, msg: string) {$/;"	m
TypeRedefined	$VIRGIL/aeneas/src/main/Error.v3	/^	def TypeRedefined(tref: Token) {$/;"	m
TypeRef	$VIRGIL/aeneas/src/vst/Vst.v3	/^class TypeRef {$/;"	c
TypeSubst	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeSubst {$/;"	c
TypeSubsume	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case TypeSubsume;$/;"	d
TypeSystem	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^component TypeSystem {$/;"	n
TypeUtil	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^component TypeUtil {$/;"	n
TypeVarEliminator	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeVarEliminator extends TypeSubst {$/;"	c
TypeVarType	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeVarType extends Type {$/;"	c
TypeVar_TypeCon	$VIRGIL/aeneas/src/types/Type.v3	/^class TypeVar_TypeCon extends TypeCon {$/;"	c
U31_MAX_1	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U31_MAX_1: u32 = 0x80000000;$/;"	d
U32_0	$VIRGIL/lib/util/Ints.v3	/^	private def U32_0 = u32.view('0');$/;"	d
U32_CHAR_ZERO	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U32_CHAR_ZERO: u32 = '0';$/;"	d
U32_MAX_DIV_10	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U32_MAX_DIV_10: u32 = 429496729;$/;"	d
U32_MAX_MOD_10	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U32_MAX_MOD_10: u32 = 6;$/;"	d
U32_TYPE	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U32_TYPE = Int.getType(false, 32);$/;"	d
U63_MAX_1	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U63_MAX_1: u64 = 0x8000000000000000;$/;"	d
U64_MAX_DIV_10	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U64_MAX_DIV_10: u64 = 0x1999999999999999; \/\/ (18,446,744,073,709,551,616 \/ 10)$/;"	d
U64_MAX_MOD_10	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U64_MAX_MOD_10: u32 = 6; \/\/ (18,446,744,073,709,551,616 % 10)$/;"	d
U64_TYPE	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^def U64_TYPE = Int.getType(false, 64);$/;"	d
UBYTE	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def UBYTE   = JvmPrimitive.new("byte", "C", "B", KIND_BYTE);$/;"	d
UID	$VIRGIL/lib/util/UID.v3	/^component UID {$/;"	n
UID_MASK	$VIRGIL/aeneas/src/types/Type.v3	/^	def UID_MASK       = 0x1FFFFFFF;$/;"	d
UNBOX_VARIANTS	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def UNBOX_VARIANTS	= compileOpt.newStringOption("unbox-variants", null,$/;"	d
UNBOX_VARIANT_CASES	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def UNBOX_VARIANT_CASES	= compileOpt.newStringOption("unbox-variant-cases", null,$/;"	d
UNICODE	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^def UNICODE = 0u; \/\/ 0x2715u;$/;"	d
UNKNOWN	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def UNKNOWN: byte = 0;	 \/\/ code for unknown sections$/;"	d
UNORD	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def UNORD = SSECmp.new("unord", 3);$/;"	d
UNUSED_MASK	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def UNUSED_MASK	  = 0x8;$/;"	d
USE	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def USE	 = 0x0;$/;"	d
USED_AS_TEMP	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^def USED_AS_TEMP = -1;$/;"	d
USE_GLOBALREGALLOC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def USE_GLOBALREGALLOC	= compileOpt.newMatcherOption("global-regalloc",$/;"	d
UdpPacket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^class UdpPacket {$/;"	c
UdpSocket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^class UdpSocket extends Socket {$/;"	c
Unassigned	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	case Unassigned;	\/\/ ?		may be chosen by the solver$/;"	d
Unboxed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Unboxed;$/;"	d
Unimplemented	$VIRGIL/aeneas/src/v3/V3.v3	/^	def Unimplemented = "UnimplementedException";$/;"	d
UnimplementedError	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnimplementedError(msg: string) {$/;"	m
UnpackClosure	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case UnpackClosure;$/;"	d
Unreachable	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Unreachable;$/;"	d
UnreachableCode	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnreachableCode() {$/;"	m
UnresolvedIdentifier	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnresolvedIdentifier(token: Token) {$/;"	m
UnresolvedMember	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnresolvedMember(token: Token, inType: bool, tref: Type) {$/;"	m
UnresolvedOp	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnresolvedOp(token: Token, t1: Type, t2: Type) {$/;"	m
UnresolvedPackingBit	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnresolvedPackingBit(ch: byte) {$/;"	m
UnresolvedType	$VIRGIL/aeneas/src/main/Error.v3	/^	def UnresolvedType(tref: TypeRef) {$/;"	m
Use	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	case Use(vreg: VReg, constraint: int);$/;"	d
Utf8	$VIRGIL/lib/util/Utf8.v3	/^component Utf8 {$/;"	n
V10	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V10 = Arm64Sfr.new("v10", 10), V11 = Arm64Sfr.new("v11", 11);$/;"	d
V11	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V10 = Arm64Sfr.new("v10", 10), V11 = Arm64Sfr.new("v11", 11);$/;"	d
V12	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V12 = Arm64Sfr.new("v12", 12), V13 = Arm64Sfr.new("v13", 13);$/;"	d
V13	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V12 = Arm64Sfr.new("v12", 12), V13 = Arm64Sfr.new("v13", 13);$/;"	d
V14	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V14 = Arm64Sfr.new("v14", 14), V15 = Arm64Sfr.new("v15", 15);$/;"	d
V15	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V14 = Arm64Sfr.new("v14", 14), V15 = Arm64Sfr.new("v15", 15);$/;"	d
V16	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V16 = Arm64Sfr.new("v16", 16), V17 = Arm64Sfr.new("v17", 17);$/;"	d
V17	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V16 = Arm64Sfr.new("v16", 16), V17 = Arm64Sfr.new("v17", 17);$/;"	d
V18	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V18 = Arm64Sfr.new("v18", 18), V19 = Arm64Sfr.new("v19", 19);$/;"	d
V19	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V18 = Arm64Sfr.new("v18", 18), V19 = Arm64Sfr.new("v19", 19);$/;"	d
V20	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V20 = Arm64Sfr.new("v20", 20), V21 = Arm64Sfr.new("v21", 21);$/;"	d
V21	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V20 = Arm64Sfr.new("v20", 20), V21 = Arm64Sfr.new("v21", 21);$/;"	d
V22	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V22 = Arm64Sfr.new("v22", 22), V23 = Arm64Sfr.new("v23", 23);$/;"	d
V23	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V22 = Arm64Sfr.new("v22", 22), V23 = Arm64Sfr.new("v23", 23);$/;"	d
V24	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V24 = Arm64Sfr.new("v24", 24), V25 = Arm64Sfr.new("v25", 25);$/;"	d
V25	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V24 = Arm64Sfr.new("v24", 24), V25 = Arm64Sfr.new("v25", 25);$/;"	d
V26	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V26 = Arm64Sfr.new("v26", 26), V27 = Arm64Sfr.new("v27", 27);$/;"	d
V27	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V26 = Arm64Sfr.new("v26", 26), V27 = Arm64Sfr.new("v27", 27);$/;"	d
V28	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V28 = Arm64Sfr.new("v28", 28), V29 = Arm64Sfr.new("v29", 29);$/;"	d
V29	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V28 = Arm64Sfr.new("v28", 28), V29 = Arm64Sfr.new("v29", 29);$/;"	d
V30	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V30 = Arm64Sfr.new("v30", 30), V31 = Arm64Sfr.new("v31", 31);$/;"	d
V31	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def V30 = Arm64Sfr.new("v30", 30), V31 = Arm64Sfr.new("v31", 31);$/;"	d
V3Array	$VIRGIL/aeneas/src/v3/V3Array.v3	/^component V3Array {$/;"	n
V3Class_TypeCon	$VIRGIL/aeneas/src/v3/V3Class.v3	/^class V3Class_TypeCon extends TypeCon {$/;"	c
V3Component_TypeCon	$VIRGIL/aeneas/src/v3/V3Component.v3	/^class V3Component_TypeCon extends TypeCon {$/;"	c
V3EnumSet_OpCache	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^class V3EnumSet_OpCache(t: Type) {$/;"	c
V3Exception	$VIRGIL/aeneas/src/v3/V3.v3	/^component V3Exception {$/;"	n
V3Op	$VIRGIL/aeneas/src/core/Operator.v3	/^component V3Op {$/;"	n
V3Range	$VIRGIL/aeneas/src/v3/V3Range.v3	/^component V3Range {$/;"	n
V3Ref	$VIRGIL/aeneas/src/v3/Ref.v3	/^component V3Ref {$/;"	n
V3Ref_TypeCon	$VIRGIL/aeneas/src/v3/Ref.v3	/^class V3Ref_TypeCon extends TypeCon {$/;"	c
VAR_SHIFT	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def VAR_SHIFT: u3 = 4;$/;"	d
VERBOSE	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^def VERBOSE = false;$/;"	d
VERSION	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def VERSION		= actionOpt.newBoolOption("version", false,$/;"	d
VIEW_TYPE_PARAM_LIST	$VIRGIL/aeneas/src/types/Int.v3	/^	def VIEW_TYPE_PARAM_LIST = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
VIEW_TYPE_PARAM_LIST_32	$VIRGIL/aeneas/src/types/Float.v3	/^	def VIEW_TYPE_PARAM_LIST_32 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
VIEW_TYPE_PARAM_LIST_32	$VIRGIL/aeneas/src/types/Int.v3	/^	def VIEW_TYPE_PARAM_LIST_32 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
VIEW_TYPE_PARAM_LIST_64	$VIRGIL/aeneas/src/types/Float.v3	/^	def VIEW_TYPE_PARAM_LIST_64 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
VIEW_TYPE_PARAM_LIST_64	$VIRGIL/aeneas/src/types/Int.v3	/^	def VIEW_TYPE_PARAM_LIST_64 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,$/;"	d
VM_PROT_EXECUTE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_EXECUTE = 0x04;$/;"	d
VM_PROT_READ	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_READ    = 0x01;$/;"	d
VM_PROT_RW	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_RW      = 0x03;$/;"	d
VM_PROT_RWX	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_RWX     = 0x07;$/;"	d
VM_PROT_RX	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_RX      = 0x05;$/;"	d
VM_PROT_WRITE	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def VM_PROT_WRITE   = 0x02;$/;"	d
VM_START_ADDR	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def VM_START_ADDR	= rtOpt.newAddrOption("vm-start-addr", 0x08000000,$/;"	d
VOID	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def VOID    = JvmPrimitive.new("void", "V", "V", KIND_VOID);$/;"	d
VOID_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def VOID_ENTRY = SsaConstCacheEntry.new(0, Void.TYPE, null, Fact.V_ZERO);$/;"	d
VReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^class VReg {$/;"	c
V_DEFAULT	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def V_DEFAULT = Fact.V_ZERO | Fact.V_NON_NEGATIVE;$/;"	d
V_FACTS	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def V_FACTS = Fact.V_ZERO | Fact.V_NON_ZERO | Fact.V_BELOW_ZERO | Fact.V_NON_NEGATIVE;$/;"	d
Val	$VIRGIL/aeneas/src/core/Value.v3	/^class Val extends Result {$/;"	c
Val	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	case Val(t: Type);$/;"	d
Values	$VIRGIL/aeneas/src/core/Value.v3	/^component Values {$/;"	n
VarBinding	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VarBinding {$/;"	c
VarBinding.Apply	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Apply(op: Operator, facts: Fact.set);		\/\/ apply {op} to receiver$/;"	c
VarBinding.ClassField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassField(receiver: Type, member: VstField);$/;"	c
VarBinding.ClassMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	c
VarBinding.ClassNew	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ClassNew(receiver: Type, member: VstNew, funcType: Type);$/;"	c
VarBinding.ComponentField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ComponentField(member: VstField);$/;"	c
VarBinding.ComponentMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ComponentMethod(member: VstMethod, typeArgs: TypeArgs);$/;"	c
VarBinding.Const	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Const(val: Val, vtype: Type);$/;"	c
VarBinding.EnumConst	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumConst(member: VstEnumCase);$/;"	c
VarBinding.Inst	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Inst(op: Operator, facts: Fact.set);		\/\/ instantiate {op}$/;"	c
VarBinding.LayoutDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutDecl(decl: VstLayout);$/;"	c
VarBinding.LayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutField(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.LayoutFieldDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutFieldDecl(decl: VstLayoutField);$/;"	c
VarBinding.LayoutNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutNested(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.LayoutRepeatedField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutRepeatedField(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.LayoutRepeatedNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case LayoutRepeatedNested(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.Local	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Local(decl: VarDecl);$/;"	c
VarBinding.None	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case None;$/;"	c
VarBinding.ObjectField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ObjectField(receiver: Type, member: VstField);$/;"	c
VarBinding.ObjectMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case ObjectMethod(receiver: Type, member: VstMethod, typeArgs: TypeArgs);$/;"	c
VarBinding.Partial	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Partial(op: Operator, facts: Fact.set);		\/\/ partially apply {op} to receiver$/;"	c
VarBinding.PtrAtField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case PtrAtField(ptrType: Type);$/;"	c
VarBinding.RefLayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutField(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.RefLayoutNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutNested(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.RefLayoutRepeatedField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutRepeatedField(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.RefLayoutRepeatedNested	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case RefLayoutRepeatedNested(receiver: RefType, member: VstLayoutField);$/;"	c
VarBinding.Type	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Type(t: Type);$/;"	c
VarBinding.VariantCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantCase(receiver: Type, member: VstCaseMember);$/;"	c
VarBinding.VariantField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantField(receiver: Type, member: VstField);$/;"	c
VarBinding.Void	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Void;$/;"	c
VarDecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VarDecl extends Decl {$/;"	c
VarDeclError	$VIRGIL/aeneas/src/main/Error.v3	/^	def VarDeclError(msg: string) {$/;"	m
VarDefParser	$VIRGIL/aeneas/src/vst/Parser.v3	/^class VarDefParser(isPrivate: bool, writability: Writability) {$/;"	c
VarEnvironment	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^class VarEnvironment {$/;"	c
VarExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VarExpr(expr: Expr, dot: FilePoint, ident: VstIdent<TypeRef>) extends Expr {$/;"	c
Variables	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^type Variables(name: string, t: Type, index: int, instr: SsaInstr) #unboxed { }$/;"	c
VariantCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantCase(receiver: Type, member: VstCaseMember);$/;"	d
VariantComparatorGen	$VIRGIL/aeneas/src/ir/Reachability.v3	/^class VariantComparatorGen(context: SsaContext, root: IrClass, receiver: IrClass, method: IrMethod) {$/;"	c
VariantDesugaring	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VariantDesugaring(isPrivate: bool, outer: VstIdent<TypeParamType>, params: VstList<ParamDecl>) {$/;"	c
VariantEq	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantEq;$/;"	d
VariantField	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantField(tn: TypeNorm, indexes: Array<int>) {$/;"	c
VariantField	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantField(receiver: Type, member: VstField);$/;"	d
VariantGetField	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetField(field: IrField);$/;"	d
VariantGetMethod	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetMethod(method: IrMethod);$/;"	d
VariantGetName	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantGetName;	\/\/ desugared to ArrayGetElem(#names, VariantGetTag(x))$/;"	d
VariantGetSelector	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetSelector(selector: IrSelector);$/;"	d
VariantGetTag	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetTag;$/;"	d
VariantGetVirtual	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantGetVirtual(method: IrMethod);$/;"	d
VariantNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantNorm extends TypeNorm {$/;"	c
VariantNormalizer	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantNormalizer(nc: NormalizerConfig, rn: ReachabilityNormalizer, verbose: bool) {$/;"	c
VariantPattern	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantPattern(scalars: Array<ScalarPattern>) {$/;"	c
VariantReplaceNull	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VariantReplaceNull;$/;"	d
VariantSolution	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantSolution {$/;"	c
VariantSolver	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^class VariantSolver(vnorm: VariantNormalizer, usePacking: bool) {$/;"	c
Vector	$VIRGIL/lib/util/Vector.v3	/^class Vector<T> {$/;"	c
Vectors	$VIRGIL/lib/util/Vector.v3	/^component Vectors {$/;"	n
Verifier	$VIRGIL/aeneas/src/vst/Verifier.v3	/^class Verifier(compiler: Compiler, prog: Program) {$/;"	c
Version	$VIRGIL/aeneas/src/main/Version.v3	/^component Version {$/;"	n
Void	$VIRGIL/aeneas/src/types/Void.v3	/^component Void {$/;"	n
Void	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Void;$/;"	d
Void	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case Void; \/\/ XXX: only for block types$/;"	d
VoidType	$VIRGIL/aeneas/src/types/Void.v3	/^class VoidType extends Type {$/;"	c
VstBranchOpt	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var VstBranchOpt		= flags.get("VstBranchOpt", level >= 1);$/;"	d
VstCaseMember	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstCaseMember extends VstMember {$/;"	c
VstClass	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstClass extends VstCompound {$/;"	c
VstComponent	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstComponent extends VstCompound {$/;"	c
VstCompound	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstCompound extends Decl {$/;"	c
VstCompoundVerifier	$VIRGIL/aeneas/src/vst/Verifier.v3	/^class VstCompoundVerifier {$/;"	c
VstControlOpt	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var VstControlOpt		= flags.get("VstControlOpt", level >= 1);$/;"	d
VstEnum	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstEnum extends VstCompound {$/;"	c
VstEnumCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstEnumCase extends VstMember {$/;"	c
VstField	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstField extends VstMember {$/;"	c
VstFile	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstFile extends ParsedFile {$/;"	c
VstIdent	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstIdent<T>(name: Token, kwClass: byte, params: VstList<T>) {$/;"	c
VstInit	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var VstInit			= true;$/;"	d
VstIr	$VIRGIL/aeneas/src/ir/VstIr.v3	/^component VstIr {$/;"	n
VstLayout	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstLayout extends VstCompound {$/;"	c
VstLayoutField	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstLayoutField extends VstMember {$/;"	c
VstList	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstList<T>(src: FileRange, list: List<T>) {$/;"	c
VstLoopOpt	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var VstLoopOpt			= flags.get("VstLoopOpt", level >= 1);$/;"	d
VstMatcher	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^type VstMatcher {$/;"	c
VstMatcher.All	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case All;$/;"	c
VstMatcher.None	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case None;$/;"	c
VstMatcher.Some	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	case Some(patterns: List<VstPattern>);$/;"	c
VstMatchers	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^component VstMatchers {$/;"	n
VstMember	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstMember extends Decl {$/;"	c
VstMethod	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstMethod extends VstMember {$/;"	c
VstModule	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstModule {$/;"	c
VstNew	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstNew extends VstMethod {$/;"	c
VstOperator	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VstOperator {$/;"	c
VstOperator.BoolAndAnd	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case BoolAndAnd;	\/\/ desugared to if(a, b, false)$/;"	c
VstOperator.BoolOrOr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case BoolOrOr;		\/\/ desugared to if(a, true, b)$/;"	c
VstOperator.Commute	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Commute(op: Operator);	\/\/ desugared to (y op x)$/;"	c
VstOperator.EnumGetParam	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumGetParam(field: VstField);	\/\/ desugared to ArrayGetElem(#field, x)$/;"	c
VstOperator.EnumSetHas	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetHas(vcase: VstEnumCase);	\/\/ desugared to (1 << k) & x != 0$/;"	c
VstOperator.EnumSetIntersect	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetIntersect;			\/\/ desugared to x & y$/;"	c
VstOperator.EnumSetStrictSubset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetStrictSubset;$/;"	c
VstOperator.EnumSetStrictSuperset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetStrictSuperset;$/;"	c
VstOperator.EnumSetSubset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSubset;			\/\/ desugared to x & y == x$/;"	c
VstOperator.EnumSetSubtract	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSubtract;			\/\/ desugared to x & ~(x & y)$/;"	c
VstOperator.EnumSetSuperset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetSuperset;$/;"	c
VstOperator.EnumSetUnion	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case EnumSetUnion;			\/\/ desugared to x | y$/;"	c
VstOperator.FloatExponent	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatExponent;     \/\/ desugared to (u32|u64.view(float|double) >> 23|52) & (0xFF|0x7FF)$/;"	c
VstOperator.FloatFraction	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatFraction;	\/\/ desugared to (u23|u52).!(u32|u64.view(float|double))$/;"	c
VstOperator.FloatSign	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case FloatSign;		\/\/ desugared to u32|u64.view(float|double) >> 31|63$/;"	c
VstOperator.IntBitwiseNeg	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntBitwiseNeg;	\/\/ desugared to (-1 ^ a)$/;"	c
VstOperator.IntMixedEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedEqual;	\/\/ desugared to multiple comparisons$/;"	c
VstOperator.IntMixedLt	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedLt;	\/\/ desugared to multiple comparisons$/;"	c
VstOperator.IntMixedLteq	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedLteq;	\/\/ desugared to multiple comparisons$/;"	c
VstOperator.IntMixedNotEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntMixedNotEqual;	\/\/ desugared to multiple comparisons$/;"	c
VstOperator.IntView	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case IntView;		\/\/ desugared to IntConvert or FloatToBits$/;"	c
VstOperator.Nop	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Nop;		\/\/ desugar op(x) to x$/;"	c
VstOperator.NotEqual	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case NotEqual;		\/\/ desugared to !(a == b)$/;"	c
VstOperator.TypeCast	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case TypeCast;		\/\/ overloading resolved if possible$/;"	c
VstOperator.TypeQuery	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case TypeQuery;		\/\/ overloading resolved if possible$/;"	c
VstOperator.VariantGetName	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case VariantGetName;	\/\/ desugared to ArrayGetElem(#names, VariantGetTag(x))$/;"	c
VstPacking	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstPacking extends VstCompound {$/;"	c
VstPackingExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VstPackingExpr {$/;"	c
VstPackingExpr.App	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case App(p: VarExpr, args: VstList<VstPackingExpr>);$/;"	c
VstPackingExpr.Bits	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Bits(token: Token, rep: Array<(int, PackingBit)>);$/;"	c
VstPackingExpr.Concat	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Concat(l: VstList<VstPackingExpr>);			\/\/ #concat(_, ...)$/;"	c
VstPackingExpr.Field	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Field(f: VarExpr);$/;"	c
VstPackingExpr.Literal	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Literal(l: Literal);$/;"	c
VstPackingExpr.Solve	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Solve(l: VstList<VstPackingExpr>);				\/\/ #solve(_, ...)$/;"	c
VstPattern	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^class VstPattern(container: string -> bool, member: string -> bool) {$/;"	c
VstPrinter	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^class VstPrinter extends VstVisitor<int, void> {$/;"	c
VstRedefField	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstRedefField {$/;"	c
VstRepHint	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VstRepHint {$/;"	c
VstRepHint.Boxed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Boxed;$/;"	c
VstRepHint.Other	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Other(hint: string);$/;"	c
VstRepHint.Packed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Packed;$/;"	c
VstRepHint.Packing	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Packing(p: VstList<VstPackingExpr>);$/;"	c
VstRepHint.Unboxed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	case Unboxed;$/;"	c
VstSsaEnv	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^class VstSsaEnv extends SsaBuilder {$/;"	c
VstSsaGen	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^class VstSsaGen extends VstVisitor<VstSsaEnv, SsaInstr> {$/;"	c
VstSsaMerge	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^class VstSsaMerge(gen: VstSsaGen) {$/;"	c
VstSsaVar	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^class VstSsaVar {$/;"	c
VstSugar	$VIRGIL/aeneas/src/core/Opcode.v3	/^	case VstSugar(op: VstOperator);$/;"	d
VstVariantNameMember	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstVariantNameMember extends VstMember {$/;"	c
VstVariantTagMember	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstVariantTagMember extends VstMember {$/;"	c
VstVerify	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var VstVerify			= true;$/;"	d
VstVisitor	$VIRGIL/aeneas/src/vst/Vst.v3	/^class VstVisitor<E, R> {$/;"	c
Vt100	$VIRGIL/lib/term/Vt100.v3	/^component Vt100 {$/;"	n
WASM_EXPORT_MEM	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def WASM_EXPORT_MEM	= wasmOpt.newBoolOption("wasm.export-mem", true,$/;"	d
WASM_GC	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def WASM_GC		= wasmOpt.newBoolOption("wasm.gc", false,$/;"	d
WASM_MAGIC	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def WASM_MAGIC = 0x6d736100;$/;"	d
WASM_MULTI_VALUE	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def WASM_MULTI_VALUE	= wasmOpt.newBoolOption("wasm.multi-value", false,$/;"	d
WASM_PAGE_SIZE	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def WASM_PAGE_SIZE = 65536;$/;"	d
WASM_RUN_COMMAND	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def WASM_RUN_COMMAND	= wasmOpt.newStringOption("wasm.runcmd", null,$/;"	d
WASM_VERSION	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def WASM_VERSION = 0x1;$/;"	d
WIDE	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def WIDE		= '\xc4'; \/\/ 196$/;"	d
WasmArray	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^class WasmArray extends WasmHeapType {$/;"	c
WasmCodeGen	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^class WasmCodeGen extends SsaMachGen {$/;"	c
WasmComponent	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^component WasmComponent {$/;"	n
WasmExternal	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^component WasmExternal {$/;"	n
WasmFunc	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^class WasmFunc extends WasmHeapType {$/;"	c
WasmHeapType	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^class WasmHeapType(index: u32) {$/;"	c
WasmInstrBuffer	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^class WasmInstrBuffer extends ArchInstrBuffer {$/;"	c
WasmOpNames	$VIRGIL/aeneas/src/wasm/WasmOp.v3	/^component WasmOpNames {$/;"	n
WasmProgram	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^class WasmProgram(mach: MachProgram, gcTypes: bool, context: SsaContext) {$/;"	c
WasmSection	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^component WasmSection {$/;"	n
WasmSectionBuffer	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^class WasmSectionBuffer extends MachDataWriter {$/;"	c
WasmStackInstrGen	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^class WasmStackInstrGen(wasm: WasmProgram) {$/;"	c
WasmStruct	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^class WasmStruct extends WasmHeapType {$/;"	c
WasmTarget	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^class WasmTarget extends Target {$/;"	c
WasmType	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^type WasmType {$/;"	c
WasmType.ExternRef	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case ExternRef;$/;"	c
WasmType.F32	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case F32;$/;"	c
WasmType.F64	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case F64;$/;"	c
WasmType.FuncRef	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case FuncRef;$/;"	c
WasmType.I32	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case I32;$/;"	c
WasmType.I64	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case I64;$/;"	c
WasmType.RefNull	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case RefNull(ht: WasmHeapType);$/;"	c
WasmType.Void	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	case Void; \/\/ XXX: only for block types$/;"	c
WasmTypeTable	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^class WasmTypeTable(wasmType: Type -> WasmType) {$/;"	c
WhileStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^class WhileStmt(start: FilePoint, cond: Expr, body: Stmt) extends Stmt {$/;"	c
WideDivision	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^class WideDivision(mod: bool,		\/\/ modulus$/;"	c
Words	$VIRGIL/lib/packing/CiRuntime.v3	/^	case Words(framewords: u18)		#packing 0b_11ff_ffffffff_ffffffff;$/;"	d
WorkQueue	$VIRGIL/lib/util/WorkQueue.v3	/^class WorkQueue {$/;"	c
WorkUnit	$VIRGIL/lib/util/WorkQueue.v3	/^private class WorkUnit(run: void -> void) {$/;"	c
X86Addr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Addr(base: X86Reg, index: X86Reg, scale: byte, disp: int) extends X86Rm {$/;"	c
X86Addrs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^component X86Addrs {$/;"	n
X86Assembler	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Assembler(w: DataWriter) {$/;"	c
X86Backend	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^class X86Backend extends MachBackend {$/;"	c
X86CmpMatch	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^class X86CmpMatch {$/;"	c
X86CodeGen	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^class X86CodeGen extends OldCodeGen {$/;"	c
X86Cond	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Cond(name: string, index: int) {$/;"	c
X86Conds	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^component X86Conds {$/;"	n
X86DarwinBackend	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^class X86DarwinBackend extends X86Backend {$/;"	c
X86DarwinTarget	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^class X86DarwinTarget extends Target {$/;"	c
X86DarwinTargets	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^component X86DarwinTargets {$/;"	n
X86Instr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^class X86Instr<T> extends MachInstr {$/;"	c
X86InstrBuffer	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^class X86InstrBuffer extends ArchInstrBuffer {$/;"	c
X86LinuxBackend	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^class X86LinuxBackend extends X86Backend {$/;"	c
X86MacroAssembler	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^class X86MacroAssembler extends X86Assembler {$/;"	c
X86OP_eax_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def X86OP_eax_i = "\x05\x0D\x15\x1D\x25\x2D\x35\x3D";$/;"	d
X86OP_r_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def X86OP_r_rm	= "\x03\x0B\x13\x1B\x23\x2B\x33\x3B";$/;"	d
X86OP_rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def X86OP_rm_r	= "\x01\x09\x11\x19\x21\x29\x31\x39";$/;"	d
X86Op2	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Op2(asm: X86Assembler, operator: int) {$/;"	c
X86Reg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Reg(name8: string, name16: string, name32: string, index: int) extends X86Rm {$/;"	c
X86RegSet	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^component X86RegSet {$/;"	n
X86Regs	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^component X86Regs {$/;"	n
X86Rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^class X86Rm {$/;"	c
X86Shifter	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^class X86Shifter(opcode: Opcode) {$/;"	c
X86VirgilCallConv	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^component X86VirgilCallConv {$/;"	n
X86_64Addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Addr(base: X86_64Gpr, index: X86_64Gpr, scale: byte, disp: int) {$/;"	c
X86_64AddrPatcher	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64AddrPatcher(absMarker: int, relMarker: int) {$/;"	c
X86_64AddrPatcherImpl	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^class X86_64AddrPatcherImpl extends X86_64AddrPatcher {$/;"	c
X86_64AddrRef	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^class X86_64AddrRef extends X86_64Addr {$/;"	c
X86_64Assembler	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Assembler(w: DataWriter, OP_REX: byte) {$/;"	c
X86_64Assemblers	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^component X86_64Assemblers {$/;"	n
X86_64Backend	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^class X86_64Backend extends MachBackend {$/;"	c
X86_64Common	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^component X86_64Common {$/;"	n
X86_64Cond	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Cond(name: string, index: int) {$/;"	c
X86_64CondPair	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^class X86_64CondPair(cond1: X86_64Cond, and: bool, cond2: X86_64Cond) {$/;"	c
X86_64Conds	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^component X86_64Conds {$/;"	n
X86_64DarwinBackend	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^class X86_64DarwinBackend extends X86_64Backend {$/;"	c
X86_64DarwinTarget	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^class X86_64DarwinTarget extends Target {$/;"	c
X86_64DarwinTargets	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^component X86_64DarwinTargets {$/;"	n
X86_64Gpr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Gpr extends X86_64Reg {$/;"	c
X86_64Label	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Label {$/;"	c
X86_64LabelRef	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^class X86_64LabelRef extends X86_64Addr {$/;"	c
X86_64LinuxBackend	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^class X86_64LinuxBackend extends X86_64Backend {$/;"	c
X86_64MacroAssembler	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^class X86_64MacroAssembler extends X86_64Assembler {$/;"	c
X86_64OP_r_rm	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def X86_64OP_r_rm	= "\x03\x0B\x13\x1B\x23\x2B\x33\x3B";$/;"	d
X86_64OP_rax_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def X86_64OP_rax_i	= "\x05\x0D\x15\x1D\x25\x2D\x35\x3D";$/;"	d
X86_64OP_rm_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^def X86_64OP_rm_r	= "\x01\x09\x11\x19\x21\x29\x31\x39";$/;"	d
X86_64Reg	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Reg(regnum: byte) {$/;"	c
X86_64RegSet	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^component X86_64RegSet {$/;"	n
X86_64Regs	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^component X86_64Regs {$/;"	n
X86_64VirgilCallConv	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^component X86_64VirgilCallConv {$/;"	n
X86_64Xmmr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^class X86_64Xmmr extends X86_64Reg {$/;"	c
X86_64_LINUX_TARGET	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def X86_64_LINUX_TARGET = Aeneas.registerTarget($/;"	d
X86_64_LINUX_TEST_TARGET	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^def X86_64_LINUX_TEST_TARGET = Aeneas.registerTarget($/;"	d
X86_64_THREAD_STATE_FLAVOR	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def X86_64_THREAD_STATE_FLAVOR = 0x4; \/\/ 4$/;"	d
X86_LINUX_KERNEL_PARAM_REGS	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^def X86_LINUX_KERNEL_PARAM_REGS = [X86RegSet.EBX, X86RegSet.ECX, X86RegSet.EDX, X86RegSet.ESI, X86RegSet.EDI];$/;"	d
X86_LINUX_TARGET	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^def X86_LINUX_TARGET = Aeneas.registerTarget($/;"	d
X86_LINUX_TEST_TARGET	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^def X86_LINUX_TEST_TARGET = Aeneas.registerTarget($/;"	d
XMM0	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM0  = xmm("xmm0",  X86_64Regs.XMM0,  true);$/;"	d
XMM0	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM0 = '\x07';$/;"	d
XMM0	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM0 = X86_64Xmmr.new("xmm0", 0);$/;"	d
XMM0	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM0 = SSEReg.new("xmm0", 0);$/;"	d
XMM1	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM1  = xmm("xmm1",  X86_64Regs.XMM1,  true);$/;"	d
XMM1	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM1 = '\x08';$/;"	d
XMM1	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM1 = X86_64Xmmr.new("xmm1", 1);$/;"	d
XMM1	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM1 = SSEReg.new("xmm1", 1);$/;"	d
XMM10	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM10 = xmm("xmm10", X86_64Regs.XMM10, true);$/;"	d
XMM10	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM10 = X86_64Xmmr.new("xmm10", 10);$/;"	d
XMM11	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM11 = xmm("xmm11", X86_64Regs.XMM11, true);$/;"	d
XMM11	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM11 = X86_64Xmmr.new("xmm11", 11);$/;"	d
XMM12	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM12 = xmm("xmm12", X86_64Regs.XMM12, true);$/;"	d
XMM12	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM12 = X86_64Xmmr.new("xmm12", 12);$/;"	d
XMM13	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM13 = xmm("xmm13", X86_64Regs.XMM13, true);$/;"	d
XMM13	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM13 = X86_64Xmmr.new("xmm13", 13);$/;"	d
XMM14	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM14 = xmm("xmm14", X86_64Regs.XMM14, true);$/;"	d
XMM14	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM14 = X86_64Xmmr.new("xmm14", 14);$/;"	d
XMM15	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM15 = xmm("xmm15", X86_64Regs.XMM15, true);$/;"	d
XMM15	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM15 = X86_64Xmmr.new("xmm15", 15);$/;"	d
XMM2	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM2  = xmm("xmm2",  X86_64Regs.XMM2,  true);$/;"	d
XMM2	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM2 = '\x09';$/;"	d
XMM2	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM2 = X86_64Xmmr.new("xmm2", 2);$/;"	d
XMM2	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM2 = SSEReg.new("xmm2", 2);$/;"	d
XMM3	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM3  = xmm("xmm3",  X86_64Regs.XMM3,  true);$/;"	d
XMM3	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM3 = '\x0a';$/;"	d
XMM3	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM3 = X86_64Xmmr.new("xmm3", 3);$/;"	d
XMM3	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM3 = SSEReg.new("xmm3", 3);$/;"	d
XMM4	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM4  = xmm("xmm4",  X86_64Regs.XMM4,  true);$/;"	d
XMM4	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM4 = '\x0b';$/;"	d
XMM4	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM4 = X86_64Xmmr.new("xmm4", 4);$/;"	d
XMM4	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM4 = SSEReg.new("xmm4", 4);$/;"	d
XMM5	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM5  = xmm("xmm5",  X86_64Regs.XMM5,  true);$/;"	d
XMM5	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM5 = '\x0c';$/;"	d
XMM5	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM5 = X86_64Xmmr.new("xmm5", 5);$/;"	d
XMM5	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM5 = SSEReg.new("xmm5", 5);$/;"	d
XMM6	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM6  = xmm("xmm6",  X86_64Regs.XMM6,  true);$/;"	d
XMM6	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM6 = '\x0d';$/;"	d
XMM6	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM6 = X86_64Xmmr.new("xmm6", 6);$/;"	d
XMM6	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM6 = SSEReg.new("xmm6", 6);$/;"	d
XMM7	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM7  = xmm("xmm7",  X86_64Regs.XMM7,  false);$/;"	d
XMM7	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def XMM7 = '\x0e';$/;"	d
XMM7	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM7 = X86_64Xmmr.new("xmm7", 7);$/;"	d
XMM7	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def XMM7 = SSEReg.new("xmm7", 7);$/;"	d
XMM8	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM8  = xmm("xmm8",  X86_64Regs.XMM8,  true);$/;"	d
XMM8	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM8 = X86_64Xmmr.new("xmm8", 8);$/;"	d
XMM9	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM9  = xmm("xmm9",  X86_64Regs.XMM9,  true);$/;"	d
XMM9	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMM9 = X86_64Xmmr.new("xmm9", 9);$/;"	d
XMM_ARRAY	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def XMM_ARRAY = Array<byte>.new(XMM_COUNT);$/;"	d
XMM_CLASS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def XMM_CLASS = set("{xmm}", XMM_ARRAY);$/;"	d
XMM_COUNT	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def XMM_COUNT = 15;$/;"	d
XMM_REGS	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def XMM_REGS = Array<X86_64Xmmr>.new(XMM_COUNT + 1 \/*one unallocatable*\/);$/;"	d
XMMs	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def XMMs = [$/;"	d
XXX	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def XXX: Terminal;$/;"	d
XXX	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^def XXX: Terminal;$/;"	d
XXX	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^def XXX: Terminal;$/;"	d
XXX	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^def XXX: Terminal;$/;"	d
XXX	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def XXX: Terminal;$/;"	d
ZERO	$VIRGIL/aeneas/src/types/Int.v3	/^	def ZERO      = Box.new(0);$/;"	d
ZERO_ENTRY	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^def ZERO_ENTRY = SsaConstCacheEntry.new(3, Int.TYPE, null, Facts.V_DEFAULT);$/;"	d
[]=	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def [i: SsaInstr] = t: SsaInstr {$/;"	m
[]=	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def [ssa: VstSsaVar] = i: SsaInstr {$/;"	m
[]=	$VIRGIL/lib/util/BitMatrix.v3	/^	def [col: int] = val: bool {$/;"	m
[]=	$VIRGIL/lib/util/BitMatrix.v3	/^	def [row: int, col: int] = val: bool {$/;"	m
[]=	$VIRGIL/lib/util/Map.v3	/^	def [key: K] = val: V {$/;"	m
[]=	$VIRGIL/lib/util/Map.v3	/^	def [key: K] = val: V {$/;"	m
[]=	$VIRGIL/lib/util/Map.v3	/^	def [key: K] = val: V;$/;"	m
[]=	$VIRGIL/lib/util/Vector.v3	/^	def [index: int] = element: T {$/;"	m
abbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var abbrev: u32;$/;"	d
abs	$VIRGIL/lib/util/Ints.v3	/^	def abs(a: int) -> u32 {$/;"	f
abs4	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def abs4(addr: Addr, encoding: int) {$/;"	m
abs_of	$VIRGIL/lib/util/DataReader.v3	/^	def abs_of(pos: int) -> int {$/;"	m
absolute	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def absolute(a: Addr) -> int {$/;"	m
absolute	$VIRGIL/aeneas/src/mach/Memory.v3	/^	var absolute: int = -1;	\/\/ absolute address if this is a base address$/;"	d
absolute	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def absolute() -> bool { return base == null && index == null; }$/;"	m
absolute	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def absolute() -> bool { return base == null && index == null; }$/;"	m
abspos	$VIRGIL/lib/util/DataReader.v3	/^	def abspos() -> int {$/;"	m
abstractClosureClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var abstractClosureClass: JvmClassGen;$/;"	d
accept	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def accept<E, R>(v: VstVisitor<E, R>, env: E) -> R;$/;"	m
accept	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def accept(sockfd: int, sockAddr: Array<byte>) -> NetResult<(int, int)> {$/;"	f
acceptExplicitWidth	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def acceptExplicitWidth(c: byte) -> bool {$/;"	m
acceptFD	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def acceptFD() -> bool {$/;"	m
acceptUIL	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def acceptUIL() -> bool {$/;"	m
accept_message	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def accept_message();						  			\/\/ F$/;"	f
accept_width	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var accept_width: bool;$/;"	d
access_flags	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var access_flags: int;$/;"	d
aconst_null	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def aconst_null() {$/;"	m
acquire	$VIRGIL/lib/util/DataReader.v3	/^	def acquire(len: int) -> Range<byte> {$/;"	m
acquire	$VIRGIL/lib/util/DataWriter.v3	/^	def acquire(size: int) -> Array<byte> {$/;"	m
acquire	$VIRGIL/lib/util/StringBuilder.v3	/^	private def acquire(n: int) -> int {$/;"	m
acquireFileID	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def acquireFileID(sysfd: int) -> int {$/;"	m
actionOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def actionOpt = OptionGroup.new("ACTION", options);$/;"	d
activeList	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var activeList: VReg;$/;"	d
actualSpill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var actualSpill: bool;$/;"	d
adc	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def adc(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(10, rd, rn, op); }$/;"	m
adc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var adc: X86Op2;$/;"	d
adc_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def adc_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 2); }$/;"	m
adc_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def adc_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 2); }$/;"	m
adc_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def adc_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 2); }$/;"	m
adc_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def adc_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 2); }$/;"	m
adc_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def adc_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 2); }$/;"	m
adcs	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def adcs(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(11, rd, rn, op); }$/;"	m
add	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def add(offset: int, e0: int, e1: int) {$/;"	m
add	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def add(key: K, data: D) {$/;"	m
add	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def add(delta: int) -> Addr {$/;"	m
add	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def add<T>(opt: Option<T>, typename: string, help: string) -> Option<T> {$/;"	m
add	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def add(op: Operator, args: Array<SsaInstr>, facts: Fact.set) -> SsaApplyOp {$/;"	m
add	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def add(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {$/;"	m
add	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def add(typeCon: TypeCon) {$/;"	m
add	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def add = size - 1;$/;"	d
add	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def add(start: FilePoint, end: FileRange) -> FileRange {$/;"	f
add	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def add(sig: Signature) -> u32 {$/;"	m
add	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def add(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(8, rd, rn, op); }$/;"	m
add	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def add(rd: MipsReg, rs: MipsReg, rt: MipsReg)  { emit_r3(0x00000020, rd, rs, rt); }$/;"	m
add	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var add: X86Op2;$/;"	d
add	$VIRGIL/lib/util/Map.v3	/^	def add(key: K, val: V) { list = List.new(val, list); }$/;"	m
add	$VIRGIL/lib/util/Option.v3	/^	def add<T>(option: Option<T>) -> Option<T> {$/;"	m
add	$VIRGIL/lib/util/WorkQueue.v3	/^	def add<A, B>(func: A -> B, a: A) {$/;"	m
addApply	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addApply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {$/;"	m
addApplyF	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addApplyF(op: Operator, args: Array<SsaInstr>, facts: Fact.set) -> SsaInstr {$/;"	m
addApplyVst	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addApplyVst(source: Source, op: Operator, vst: VstOperator, args: Array<SsaInstr>) -> SsaInstr {$/;"	m
addBinOpSuffixes	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def addBinOpSuffixes(p: ParserState, expr: Expr) -> Expr {$/;"	f
addBinop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addBinop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
addCheckpoint	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addCheckpoint(source: Source, vals: Array<SsaInstr>) {$/;"	m
addClassEntry	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	private def addClassEntry(compound: VstCompound) -> (int, int) {$/;"	m
addClosureCreate	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addClosureCreate(comp: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {$/;"	m
addConditionalThrow	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addConditionalThrow(source: Source, exception: string, cond: SsaInstr) -> SsaInstr {$/;"	m
addConstructorCode	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addConstructorCode(decl: VstNew, env: VstSsaEnv) {$/;"	m
addCpe	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def addCpe(cpe: JvmCpe) -> int {$/;"	m
addCycle	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def addCycle(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {$/;"	m
addData	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def addData(name: string, data: Array<byte>) {$/;"	m
addDecDigit	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def addDecDigit(val: u32) -> this {$/;"	m
addDefaultCase	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addDefaultCase(c: MatchCase) {$/;"	m
addDeleteVar	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addDeleteVar(n: int) -> SsaInstr {$/;"	m
addDirectCall	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addDirectCall(spec: IrSpec) {$/;"	m
addDirectCallEdges	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addDirectCallEdges(sig: SpecSignature, calls: Vector<SpecEdge>, meth: SpecMethod) {$/;"	m
addElse	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addElse() -> SsaBuilder {$/;"	m
addEmptyInit	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def addEmptyInit() {$/;"	m
addEnds	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def addEnds(i: int) {$/;"	m
addEnumParamInitCode	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addEnumParamInitCode(env: VstSsaEnv) {$/;"	m
addEnumPattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addEnumPattern(pat: MatchPattern, vc: VstEnumCase) {$/;"	m
addEnumToSet	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addEnumToSet(tc: EnumSetType, x: SsaInstr) -> SsaInstr {$/;"	m
addEnumVals	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addEnumVals(decl: VstEnum) {$/;"	m
addEqual	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
addError	$VIRGIL/aeneas/src/main/Error.v3	/^	def addError(range: FileRange, sourceLine: string, error: string, msg: string) {$/;"	m
addErrorObj	$VIRGIL/aeneas/src/main/Error.v3	/^	def addErrorObj(error: Error) {$/;"	m
addExplicitNullCheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addExplicitNullCheck(source: Source, receiver: SsaInstr) -> SsaInstr {$/;"	m
addExport	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addExport(decl: ExportDecl) {$/;"	m
addField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	private def addField(rf: RaField) -> RaField {$/;"	m
addField	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addField(receiver: SsaInstr, field: IrField, value: SsaInstr) {$/;"	m
addFile	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def addFile(jarFile: JARFileFile) {$/;"	m
addFuncSymbol	$VIRGIL/aeneas/src/os/Linux.v3	/^	def addFuncSymbol(w: MachDataWriter, str: string, addr: Addr) {$/;"	m
addGoto	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addGoto(target: SsaBlock) {$/;"	m
addHeapPointers	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def addHeapPointers(w: MachDataWriter) {$/;"	m
addIf	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addIf(cond: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {$/;"	m
addIfNot	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addIfNot(cond: SsaInstr) -> SsaBuilder {$/;"	m
addIfNull	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def addIfNull(x: SsaInstr) -> (SsaBuilder, SsaBuilder, SsaBuilder) {$/;"	m
addIfNull	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addIfNull(x: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {$/;"	m
addImpl	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def addImpl(rm: RaMethod) {$/;"	m
addInit	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addInit(meth: IrMethod) {$/;"	m
addInitFor	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addInitFor(decl: VstCompound) {$/;"	m
addInlineMethodEntry	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def addInlineMethodEntry(source: VstMethod) {$/;"	m
addInstr	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def addInstr(i: MachInstr) -> MachInstr {$/;"	m
addInstr	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private def addInstr(j: SsaInstr) -> (int, int) {$/;"	m
addInterfere	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addInterfere(n: int) -> bool {$/;"	m
addInterferences	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addInterferences(vreg: VReg) {$/;"	m
addInterferencesReg	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addInterferencesReg(reg: int, filter: VReg) {$/;"	m
addIrField	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def addIrField(f: IrField) {$/;"	m
addIrMethod	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def addIrMethod(m: IrMethod) {$/;"	m
addIrMethodAddr	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addIrMethodAddr(m: IrItem, addr: Address<IrMethod>) {$/;"	m
addIrMethods	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addIrMethods() -> Vector<IrMethod> {$/;"	m
addKeyword	$VIRGIL/aeneas/src/vst/Parser.v3	/^	private def addKeyword(kw: string, kc: byte) -> bool {$/;"	f
addLine	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def addLine(p: string, ic: IrClass) {$/;"	m
addLineEntry	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def addLineEntry(src: Source, label: Label, prologue_end: bool) {$/;"	m
addLoc	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def addLoc(pos: u32, loc: (\/*reg*\/X86_64Reg, \/*stack location*\/int)) {$/;"	m
addLocList	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def addLocList(v: DwarfVariable) -> int {$/;"	m
addManifest	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def addManifest(mainClass: string) {$/;"	m
addMapping	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private def addMapping(index: int, range: (int, int)) {$/;"	m
addMemberSuffix	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def addMemberSuffix(p: ParserState, pos: FilePoint, expr: Expr) -> Expr {$/;"	f
addMethod	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def addMethod(vtable: Vector<IrMethod>, rc: RaClass, rm: RaMethod) {$/;"	m
addMethod	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addMethod(m: IrMethod) {$/;"	m
addMethodSymbol	$VIRGIL/aeneas/src/os/Linux.v3	/^	def addMethodSymbol(w: DataWriter, m: IrMethod, addr: Addr, buf: StringBuilder) {$/;"	m
addMove	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addMove(x: int, y: int) -> bool {$/;"	m
addMove	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def addMove(src: int, dest: int) {$/;"	m
addMtable	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addMtable(m: IrItem, addr: Addr) {$/;"	m
addNewVar	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addNewVar(name: string, vtype: Type, index: int, vals: Array<SsaInstr>) -> SsaInstr {$/;"	m
addNewVarDecl	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addNewVarDecl(v: VarDecl) {$/;"	m
addNot	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addNot(x: SsaInstr) -> SsaInstr {$/;"	m
addNotEqual	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
addNullCheck	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def addNullCheck(i_old: SsaInstr, obj: SsaInstr) {$/;"	m
addOffset	$VIRGIL/aeneas/src/v3/V3.v3	/^def addOffset(buf: StringBuilder, addr: Addr) {$/;"	f
addOldType	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addOldType(spec: Specializer, t: TypeNorm) {$/;"	m
addOp	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addOp(op: Operator, facts: Fact.set) -> SsaInstr {$/;"	m
addParam	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addParam(t: Type) {$/;"	m
addPhi	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addPhi(t: Type, vals: Array<SsaInstr>) -> SsaInstr {$/;"	m
addPhiMoves	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def addPhiMoves(livePhis: List<(SsaPhi, int)>, edges: Array<SsaCfEdge>) {$/;"	m
addPhis	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def addPhis(merge: SsaBuilder, t: Type, tn: TypeNorm, vals: Array<Array<SsaInstr>>) -> Array<SsaInstr> {$/;"	m
addPow2	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def addPow2(exp: int) -> this {$/;"	m
addPred	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def addPred(p: SsaCfEdge) -> int {$/;"	m
addProbeAfter	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def addProbeAfter(ip: int, f: (IcInterpreter, int) -> void) {$/;"	m
addProbeBefore	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def addProbeBefore(ip: int, f: (IcInterpreter, int) -> void) {$/;"	m
addProgramHeader	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def addProgramHeader() -> ElfProgramHeader {$/;"	m
addPtr	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def addPtr(w: MachDataWriter, ptr: CiRuntime_Address) {$/;"	m
addRange	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def addRange(num: FpSketch, pos: int, maxPos: int) -> u32 {$/;"	m
addRegMove	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addRegMove(vreg: VReg, src: int, dst: byte) {$/;"	m
addRegMove	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def addRegMove(vreg: VReg, src: int, dst: byte) {$/;"	m
addReturn	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addReturn(vals: Array<SsaInstr>) {$/;"	m
addReturnBool	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def addReturnBool(block: SsaBlock, val: bool) {$/;"	m
addRoot	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def addRoot(name: string, meth: IrSpec) -> int {$/;"	m
addRoot	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	private def addRoot(ctype: Type, meth: IrMethod) -> int {$/;"	m
addRoots	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def addRoots(compiler: Compiler, prog: Program) {$/;"	m
addRoots	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def addRoots() {$/;"	m
addRoots	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def addRoots(compiler: Compiler, prog: Program) { }$/;"	m
addRoots	$VIRGIL/aeneas/src/os/Linux.v3	/^	def addRoots(compiler: Compiler, prog: Program) {$/;"	m
addRoots	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addRoots(compiler: Compiler, prog: Program) {$/;"	m
addRoots	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def addRoots(compiler: Compiler, prog: Program) {$/;"	m
addRoots	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def addRoots(compiler: Compiler, prog: Program) {$/;"	m
addSect	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def addSect(sect: MachO_Section) {$/;"	m
addSig	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def addSig(receiver: Type, sig: Signature) -> u32 {$/;"	m
addState	$VIRGIL/lib/util/GlobMatcher.v3	/^	private def addState(pos: int, vec: Vector<int>) {$/;"	m
addSuccessors	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def addSuccessors(block: SsaBlock, queue: Vector<SsaBlock>, mark: int) {$/;"	m
addTermSuffixes	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def addTermSuffixes(p: ParserState, expr: Expr) -> Expr {$/;"	f
addThrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def addThrow(source: Source, exception: string) -> SsaInstr {$/;"	m
addThrow	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addThrow(source: Source, ex: string) -> SsaInstr {$/;"	m
addThrow	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def addThrow(source: Source, exception: string) -> SsaInstr {$/;"	m
addTo	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def addTo(vec: Vector<Type>) {$/;"	m
addTotal	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def addTotal(pm: IcMethodProf, range: (int, int), count: int) {$/;"	m
addType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def addType(t: Type) -> int {$/;"	m
addTypePattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addTypePattern(pat: MatchPattern, t: Type) {$/;"	m
addUpdateVar	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def addUpdateVar(index: int, vals: Array<SsaInstr>) -> SsaInstr {$/;"	m
addUtf16	$VIRGIL/lib/util/Utf8.v3	/^	private def addUtf16(buf: Vector<u16>, codepoint: u32) {$/;"	f
addVal	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def addVal(t: Type, val: Val) -> SsaInstr {$/;"	m
addValue	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def addValue(v: Val) {$/;"	m
addValue	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addValue(pat: MatchPattern, val: Val) {$/;"	m
addVar	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def addVar(newvar: (string, Type), index: int, locs: Array<(X86_64Reg, int)>, pos: int) {$/;"	m
addVariantPattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def addVariantPattern(pat: MatchPattern, vc: VstCaseMember) {$/;"	m
addVirtualCall	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addVirtualCall(spec: IrSpec) {$/;"	m
addVirtualCallEdges	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def addVirtualCallEdges(sig: SpecSignature, calls: Vector<SpecEdge>, meth: SpecMethod) {$/;"	m
addVstField	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def addVstField(f: VstField, isVariant: bool) {$/;"	m
addVstMethod	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def addVstMethod(m: VstMethod) {$/;"	m
addVstNew	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def addVstNew(m: VstNew, isVariant: bool) {$/;"	m
addWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def addWorklist(n: int) {$/;"	m
add_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def add_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 0); }$/;"	m
add_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def add_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 0); }$/;"	m
add_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def add_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 0); }$/;"	m
add_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def add_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 0); }$/;"	m
add_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def add_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 0); }$/;"	m
addd_r_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addd_r_r_i_i(rd: Arm64Reg, rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
addd_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addd_r_r_r_ex_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: DataRegExtend, imm: u3) -> this {$/;"	m
addd_r_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addd_r_r_r_sh_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u5) -> this {$/;"	m
addi	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def addi(rd: MipsReg, rs: MipsReg, imm: i16)    { emit_r2i(0x20000000, rd, rs, u16.!(imm)); }$/;"	m
addi	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def addi(rd: RiscV64Gpr, rs: RiscV64Gpr, imm: i12) -> this { emit_i_type(7, rd, 3, rs, u12.view(imm)); }$/;"	m
addiu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def addiu(rd: MipsReg, rs: MipsReg, imm: u16)   { emit_r2i(0x24000000, rd, rs, imm); }$/;"	m
addpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
addps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
addq_r_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addq_r_r_i_i(rd: Arm64Reg, rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
addq_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addq_r_r_r_ex_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: DataRegExtend, imm: u3) -> this {$/;"	m
addq_r_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def addq_r_r_r_sh_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u6) -> this {$/;"	m
addr	$VIRGIL/aeneas/src/core/Eval.v3	/^	def addr(i: int) -> Addr {$/;"	m
addr	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var addr: int;$/;"	d
addr	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def addr(name: string) -> CiRuntime_Address {$/;"	f
addr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	var addr: InetAddress;$/;"	d
addrAlign	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def addrAlign: Alignment;$/;"	d
addrOfMethod	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def addrOfMethod(m: IrMethod) -> Address<IrMethod> {$/;"	m
addrOfRecord	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def addrOfRecord(r: Record) -> Address<Record> {$/;"	m
addressSize	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def addressSize: u8;		\/\/ size of address in bytes$/;"	d
addressSizeLog2	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def addressSizeLog2: u8 = u8.view(Ints.log(addressSize)); \/\/ log of address size$/;"	d
addressWidth	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def addressWidth: u8;		\/\/ width of address in bits$/;"	d
addrs	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def addrs = Array<int>.new(CiRuntimeModule.max); \/\/ CiRuntime absolute addresses$/;"	d
adds	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def adds(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(9, rd, rn, op); }$/;"	m
addsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def addsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x58, a, b); }$/;"	m
addsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
addsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
addss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def addss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x58, a, b); }$/;"	m
addss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
addss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def addss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
addu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def addu(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x00000021, rd, rs, rt); }$/;"	m
adjust	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	private def adjust(loc: int, adjust: int) -> int {$/;"	m
adjustArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def adjustArgs(argRp: int, numParams: int, numArgs: int) {$/;"	m
adjustOpArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def adjustOpArgs(numParams: int, args: Array<int>) -> Array<int> {$/;"	m
advance	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def advance(len: int) -> int {$/;"	m
advance	$VIRGIL/lib/util/GlobMatcher.v3	/^	private def advance(pos: int, c: byte, vec: Vector<int>) {$/;"	m
advance	$VIRGIL/lib/util/TextReader.v3	/^	def advance(len: int) -> int {$/;"	m
advance1	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def advance1() -> this {$/;"	m
advance1	$VIRGIL/lib/util/TextReader.v3	/^	def advance1() -> this {$/;"	m
advanceCursor	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def advanceCursor() {$/;"	m
after	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var after: List<(IcInterpreter, int) -> void>;$/;"	d
after	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def after(i: IcInterpreter, probeIp: int) {$/;"	m
after	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var after: MoveResolver;	\/\/ phys -> phys moves, after$/;"	d
afterBranch	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def afterBranch(i: IcInterpreter, probeIp: int) {$/;"	m
afterReturn	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def afterReturn(i: IcInterpreter, probeIp: int) {$/;"	m
aliasTypeCon	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def aliasTypeCon(name: string, t: Type) -> TypeCon {$/;"	f
align	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var align: int;$/;"	d
align	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def align(size: int) -> this {$/;"	m
align	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def align(size: int) {$/;"	m
align	$VIRGIL/lib/util/DataWriter.v3	/^	def align(size: int) -> this {$/;"	m
alignAddr	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def alignAddr(size: int) {$/;"	m
alignDown	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def alignDown(i: int) -> int {$/;"	m
alignTo	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def alignTo(i: int, a: int) -> int {$/;"	m
alignUp	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def alignUp(i: int) -> int {$/;"	m
alignUp64	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def alignUp64(i: long) -> long {$/;"	m
all	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var all: bool;$/;"	d
all	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def all = [EQ, NEQ, GT, LT];$/;"	d
all	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def all = [EQ, LT, LE, UNORD, NEQ, NLT, NLE, ORD];$/;"	d
all	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def all = [$/;"	d
allCount	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def allCount = 33; \/\/ TODO$/;"	d
allCovered	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def allCovered() -> bool {$/;"	m
allLive	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var allLive: BitMatrixRow;$/;"	d
allTrue	$VIRGIL/lib/util/Arrays.v3	/^	def allTrue<T>(x: Array<T>, y: Array<T>, cond: (T, T) -> bool) -> bool {$/;"	f
allTrue	$VIRGIL/lib/util/List.v3	/^	def allTrue<T>(a: List<T>, b: List<T>, cond: (T, T) -> bool) -> bool {$/;"	f
alloc	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def alloc(mach: MachProgram, types: Array<Type>, gpr: Array<byte>, xmm: Array<byte>) -> (Array<int>, int) {$/;"	f
alloc	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def alloc(frame: MachFrame, curPoint: LsraPoint, regClass: RegClass) -> int {$/;"	m
alloc	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def alloc(vreg: VReg, constraint: int) -> int {$/;"	m
alloc	$VIRGIL/aeneas/src/types/Function.v3	/^	def alloc(hash: int, nested: List<Type>) -> FuncType {$/;"	m
alloc	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def alloc(hash: int, nested: List<Type>) -> TupleType {$/;"	m
alloc	$VIRGIL/aeneas/src/types/Type.v3	/^	def alloc(hash: int, nested: List<Type>) -> Type {$/;"	m
alloc	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def alloc(hash: int, nested: List<Type>) -> Type {$/;"	m
alloc	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def alloc(hash: int, nested: List<Type>) -> ClassType {$/;"	m
alloc	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def alloc(mach: MachProgram, types: Array<Type>, gpr: Array<byte>, xmm: Array<byte>) -> (Array<int>, int) {$/;"	f
allocCallerSpace	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def allocCallerSpace(conv: MachCallConv) -> MachCallConv {$/;"	m
allocCalls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def allocCalls(sig: SpecSignature) {$/;"	m
allocDefReg	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def allocDefReg(vreg: VReg, constraint: int, genSave: bool) -> int {$/;"	m
allocDefReg	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def allocDefReg(vreg: VReg, constraint: int) -> int {$/;"	m
allocFromRegSet	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocFromRegSet(mm: MachMoves, vloc: int, fixed: int) -> int {$/;"	m
allocFunc	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def allocFunc: (int, TypeCon, List<Type>) -> Type;$/;"	d
allocMark	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def allocMark(i: SsaLink) -> u31;$/;"	m
allocMethod	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var allocMethod: IrMethod;$/;"	d
allocMoveTmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def allocMoveTmp(loc: int) -> int {$/;"	m
allocMovesAt	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocMovesAt(pos: int) -> MachMoves {$/;"	m
allocOrSpill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocOrSpill(vreg: VReg, fixed: int) -> int {$/;"	m
allocOverflow	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def allocOverflow(overflow: int) {$/;"	m
allocOverflowFieldRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def allocOverflowFieldRecord() {$/;"	m
allocOverflowFields	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def allocOverflowFields(fnorm: FuncNorm) -> FuncNorm {$/;"	m
allocReg	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def allocReg(i: SsaInstr, t: Type) -> u31 {$/;"	m
allocReg	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def allocReg(i: SsaInstr, t: Type) -> u31 {$/;"	m
allocReg	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocReg(vreg: VReg) -> int {$/;"	m
allocRegOrSpill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocRegOrSpill(mm: MachMoves, vreg: VReg) -> int {$/;"	m
allocSlack	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def allocSlack(num: int) -> int {$/;"	m
allocSlot	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def allocSlot(v: VReg, wasmType: WasmType) -> VReg {$/;"	m
allocSpill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def allocSpill(vreg: VReg) {$/;"	m
allocSpill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def allocSpill(regClass: RegClass) -> int {$/;"	m
allocSpill	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def allocSpill(vreg: VReg) {$/;"	m
allocSpill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def allocSpill(regClass: RegClass) -> int {$/;"	m
allocSpill	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def allocSpill(vreg: VReg) {$/;"	m
allocSpillSlot	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def allocSpillSlot() -> int {$/;"	m
allocStub	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var allocStub: Addr;$/;"	d
allocStubAddr	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var allocStubAddr: Addr;$/;"	d
allocStubAddr	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var allocStubAddr: Addr;$/;"	d
allocStubAddr	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var allocStubAddr: Addr;$/;"	d
allocUseReg	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def allocUseReg(vreg: VReg, constraint: int) -> int {$/;"	m
allocUseReg	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def allocUseReg(vreg: VReg, constraint: int) -> int {$/;"	m
allocValueNum	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def allocValueNum(i: SsaInstr) {$/;"	m
allocatableGprs	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def allocatableGprs = Array<byte>.new(gprCount - 2);$/;"	d
allocate	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def allocate() {$/;"	m
allocate	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def allocate() {$/;"	m
allocate	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def allocate<T>(v: T, size: int) -> Address<T> {$/;"	m
allocate	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def allocate() {$/;"	m
allocate	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def allocate: (SsaInstr, Type) -> u31; \/\/ XXX: manage virtual registers internally?$/;"	d
allocateAfterColoring	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def allocateAfterColoring(block: SsaBlock, cur: ArchInstr) {$/;"	m
allocateRegs	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var allocateRegs: void -> void;$/;"	d
allocateRegs	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var allocateRegs: void -> void;$/;"	d
allocateRegsGlobal	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var allocateRegsGlobal: void -> void;$/;"	d
allocateRegsGlobal	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var allocateRegsGlobal: void -> void;$/;"	d
allocateShadowStack	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def allocateShadowStack(numShadowSlots: int) {$/;"	m
allocateStubFuncIndex	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var allocateStubFuncIndex = -1;$/;"	d
allocated	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def allocated = Array<(VReg, int)>.new(regSet.physRegs);	\/\/ (VReg, pos)$/;"	d
allocated	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def allocated = Array<byte>.new(regSet.physRegs);$/;"	d
allocates	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var allocates = false;$/;"	d
allocation	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def allocation(raType: RaType) {$/;"	m
allocator	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var allocator: ArmAllocator;$/;"	d
allowCriticalEdges	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	var allowCriticalEdges = true;$/;"	d
allowDeadNodes	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	var allowDeadNodes = false;$/;"	d
aload	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def aload(kind: JvmKind) {$/;"	m
aload_0	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def aload_0() {$/;"	m
aload_1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def aload_1() {$/;"	m
alwaysGc	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def alwaysGc: bool;$/;"	d
alwaysGc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def alwaysGc: bool = CLOptions.RT_TEST_GC.get();$/;"	d
analyze	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyze() {$/;"	m
analyzeField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeField(record: Record, rf: RaField) {$/;"	m
analyzeGetField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeGetField(receiver: RaClass, rf: RaField) {$/;"	m
analyzeLiveClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeLiveClass(rc: RaClass) {$/;"	m
analyzeMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeMethod(rm: RaMethod) {$/;"	m
analyzeOp	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeOp(op: SsaApplyOp, context: IrSpec) {$/;"	m
analyzeRecord	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeRecord(record: Record) {$/;"	m
analyzeValue	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeValue(val: Val) {$/;"	m
analyzeValues	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeValues(graph: SsaGraph) {$/;"	m
analyzeVirtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def analyzeVirtual(rc: RaClass, rm: RaMethod) {$/;"	m
and	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def and(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(0, rd, rn, op); }$/;"	m
and	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def and(rd: MipsReg, rs: MipsReg, rt: MipsReg)  { emit_r3(0x00000014, rd, rs, rt); }$/;"	m
and	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var and: X86Op2;$/;"	d
and	$VIRGIL/lib/util/BitMatrix.v3	/^	def and(that: BitMatrixRow) {$/;"	m
and_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def and_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 4); }$/;"	m
and_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def and_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 4); }$/;"	m
and_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def and_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 4); }$/;"	m
and_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def and_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 4); }$/;"	m
and_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def and_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 4); }$/;"	m
andi	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def andi(rd: MipsReg, rs: MipsReg, imm: u16)    { emit_r2i(0x30000000, rd, rs, imm); }$/;"	m
andi	$VIRGIL/lib/util/BitMatrix.v3	/^	def andi(a: int) {$/;"	m
andnpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andnpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
andnps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andnps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
andpd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def andpd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x54, a, b); }$/;"	m
andpd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andpd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
andpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
andps	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def andps(a: SSEReg, b: SSERm) { emitbb_s_sm(0x0F, 0x54, a, b); }$/;"	m
andps_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andps_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
andps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def andps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
ands	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ands(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(1, rd, rn, op); }$/;"	m
any	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var any = false;$/;"	d
anyReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def anyReg(vreg: VReg) -> int {$/;"	m
anyTrue	$VIRGIL/lib/util/Arrays.v3	/^	def anyTrue<T>(x: Array<T>, y: Array<T>, cond: (T, T) -> bool) -> bool {$/;"	f
appbind	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var appbind: AppBinding;$/;"	d
append	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def append(i: SsaLink) {$/;"	m
append	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def append(i: SsaInstr) {$/;"	m
append	$VIRGIL/lib/util/Arrays.v3	/^	def append<T>(val: T, array: Array<T>) -> Array<T> {$/;"	f
appendFieldInits	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def appendFieldInits(list: List<VstField>, env: VstSsaEnv) {$/;"	m
appendImplicitFieldInits	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def appendImplicitFieldInits(plist: List<ParamDecl>, env: VstSsaEnv) {$/;"	m
appendN	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def appendN(i: SsaLink) {$/;"	m
appendPhiInput	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def appendPhiInput(dest: SsaBlock, index: int) {$/;"	m
appendState	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def appendState(pos: int, buf: TerminalBuffer) -> TerminalBuffer {$/;"	m
appendSuperClause	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def appendSuperClause(sclause: SuperClause, env: VstSsaEnv) {$/;"	m
appendUseVars	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def appendUseVars(buf: StringBuilder, start: int, end: int) {$/;"	m
apply	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def apply(dst: int, op: Operator, args: Array<int>) -> int {$/;"	m
apply	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def apply(f: List<SpecMethod> -> void) {$/;"	m
apply	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def apply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {$/;"	m
apply	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def apply(f: (Addr, int, int) -> void) {$/;"	m
apply	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def apply(f: T -> void) { Lists.apply(list, f); }$/;"	m
apply	$VIRGIL/lib/util/BitMatrix.v3	/^	def apply<T>(row: int, func: (int, T) -> void, arg: T) {$/;"	m
apply	$VIRGIL/lib/util/List.v3	/^	def apply<T>(list: List<T>, func: T -> void) {$/;"	f
apply	$VIRGIL/lib/util/Map.v3	/^	def apply(func: (K, V) -> void);$/;"	m
apply	$VIRGIL/lib/util/Vector.v3	/^	def apply(f: T -> void) {$/;"	m
applyDominatorOptForInput0	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def applyDominatorOptForInput0(obj: SsaInstr, edge: SsaCfEdge, f: SsaInstr -> SsaInstr) {$/;"	m
args	$VIRGIL/aeneas/src/core/Program.v3	/^	var args: Array<string>;		\/\/ input arguments$/;"	d
args	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def args: Array<SsaDfEdge>;$/;"	d
args	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def args = SsaIntArguments.new(prog);$/;"	d
args	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def args: VstList<Expr>;$/;"	d
arith	$VIRGIL/aeneas/src/types/Int.v3	/^	def arith(infix: V3Infix, opcode: Opcode) -> Operator {$/;"	m
arity	$VIRGIL/aeneas/src/types/Type.v3	/^	def arity: int;			\/\/ expected number of type parameters$/;"	d
armcodegen	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def armcodegen: ArmCodeGen;$/;"	d
arr_d	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_d = [type_d];$/;"	d
arr_dd	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_dd = [type_d, type_d];$/;"	d
arr_f	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_f = [type_f];$/;"	d
arr_ff	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_ff = [type_f, type_f];$/;"	d
arr_i	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_i = Int.ARRAY_T;$/;"	d
arr_t	$VIRGIL/aeneas/src/types/Float.v3	/^	def arr_t: Array<Type> = [ft];$/;"	d
arr_v	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_v = TypeUtil.NO_TYPES;$/;"	d
arr_z	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_z = Bool.ARRAY_T;$/;"	d
arr_zz	$VIRGIL/aeneas/src/core/Operator.v3	/^	def arr_zz = Bool.ARRAY_TT;$/;"	d
array	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var array = Array<(SsaInstr, IrMember, SsaInstr)>.new(4);$/;"	d
array	$VIRGIL/aeneas/src/vst/Vst.v3	/^	private var array: Array<T>;$/;"	d
array	$VIRGIL/aeneas/src/wasm/WasmOp.v3	/^	def array = Array<string>.new(256);$/;"	d
array	$VIRGIL/lib/util/Vector.v3	/^	var array: Array<T>;$/;"	d
arrayByteNorm	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	var arrayByteNorm = ArrayNorm.!(norm.norm(V3.arrayByteType));$/;"	d
arrayByteType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def arrayByteType   = stringType;$/;"	d
arrayMap	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def arrayMap = TypeUtil.newTypeMap<WasmArray>();$/;"	d
arrayNorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def arrayNorm: ArrayNorm;$/;"	d
arrayRangeStartConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def arrayRangeStartConst(v: int, arrayType: Type) -> SsaConst {$/;"	m
arrayRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def arrayRep(t: Type) -> Mach_V3Array {$/;"	m
arrayType	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def arrayType() -> JvmArray_Type {$/;"	m
arrayType	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	var arrayType = V3Array.newType(typeParam);$/;"	d
arrayTypeRef	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	private var arrayTypeRef: JvmArray_Type;$/;"	d
arraylength	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def arraylength() {$/;"	m
arrays	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def arrays = Vector<RaArray>.new();$/;"	d
asArray	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def asArray() -> Array<T> {$/;"	m
asField	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def asField() -> IrField { return IrField.!(member); }$/;"	m
asMethod	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def asMethod() -> IrMethod {$/;"	m
asRecord	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def asRecord(i: SsaInstr) -> Record {$/;"	m
asResolvedMethod	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def asResolvedMethod(expr: VarExpr, receiver: Type, meth: VstMethod, memberType: Type) -> ResolvedMember {$/;"	m
asciiLt	$VIRGIL/lib/util/Strings.v3	/^	def asciiLt(a: string, b: string) -> bool {$/;"	f
asm	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def asm: ArmMacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var asm: Arm64MacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def asm: Arm64MacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def asm = IcAssembler.new(code);$/;"	d
asm	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def asm: X86_64MacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var asm: X86_64MacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	var asm: X86MacroAssembler;$/;"	d
asm	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	var asm: X86MacroAssembler;$/;"	d
asmAlloc	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asmAlloc(asm: ArmAssembler, reg: ArmReg) {$/;"	m
asmAlloc	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def asmAlloc(reg: X86_64Gpr) {$/;"	m
asmAlloc	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def asmAlloc(reg: X86Reg) {$/;"	m
asmArrayAlloc	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asmArrayAlloc(asm: ArmAssembler, arrayType: Type, dest: ArmReg, len: ArmReg) {$/;"	m
asmArrayAlloc	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def asmArrayAlloc(arrayType: Type, dest: X86_64Gpr, len: X86_64Gpr) {$/;"	m
asmArrayAlloc	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def asmArrayAlloc(arrayType: Type, dest: X86Reg, len: X86Reg) {$/;"	m
asm_add_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_add_i(dest: int, a: int, imm: int, v: void) {$/;"	m
asm_alloc_rt	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asm_alloc_rt(gen: ArmCodeGen, lp: int, source: Source) {$/;"	m
asm_alloc_rt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_alloc_rt(lp: int, source: Source) {$/;"	m
asm_alloc_test	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asm_alloc_test(gen: ArmCodeGen, dest: int, sz: int, source: Source) {$/;"	m
asm_alloc_test	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_alloc_test(dest: int, sz: int, source: Source) {$/;"	m
asm_br	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_br(cond: X86Cond, target: SsaBlock) {$/;"	m
asm_brthrow	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_brthrow(cond: X86Cond, ex: string, source: Source) {$/;"	m
asm_call	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_call(conv: MachCallConv, lp: int, target: Addr, source: Source) {$/;"	m
asm_caller_ip	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_caller_ip(dst: int) {$/;"	m
asm_caller_sp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_caller_sp(dst: int) {$/;"	m
asm_cmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_cmp(a: int, b: int) {$/;"	m
asm_cmp_a	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_cmp_a(a: int, addr: Addr) {$/;"	m
asm_cmp_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_cmp_i(a: int, imm: int) {$/;"	m
asm_cmpswpx	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_cmpswpx(m: (X86Assembler, X86Rm, X86Reg) -> void, dest: int, base: int, scale: byte, disp: int, val: int, canTrap: bool, source: Source) {$/;"	m
asm_cmpswpx_abs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_cmpswpx_abs(m: (X86Assembler, X86Rm, X86Reg) -> void, dest: int, addr: Addr, val: int) {$/;"	m
asm_entry	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_entry(defs: Array<int>) {$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asm_exit_code(asm: ArmAssembler, code: int);$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def asm_exit_code(code: int);$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def asm_exit_code(code: int);$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def asm_exit_code(code: int) {$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def asm_exit_code(code: int) {$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def asm_exit_code(code: int);$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def asm_exit_code(code: int) {$/;"	m
asm_exit_code	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def asm_exit_code(code: int) {$/;"	m
asm_exit_r	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def asm_exit_r(asm: ArmAssembler, loc: ArmReg);$/;"	m
asm_exit_r	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def asm_exit_r(r: X86_64Gpr);$/;"	m
asm_exit_r	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def asm_exit_r(r: X86_64Gpr);$/;"	m
asm_exit_r	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def asm_exit_r(r: X86_64Gpr) {$/;"	m
asm_exit_r	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def asm_exit_r(r: X86_64Gpr) {$/;"	m
asm_exit_rm	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def asm_exit_rm(loc: X86Rm);$/;"	m
asm_exit_rm	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def asm_exit_rm(rm: X86Rm) {$/;"	m
asm_exit_rm	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def asm_exit_rm(rm: X86Rm) {$/;"	m
asm_icall	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_icall(conv: MachCallConv, lp: int, addr: int, source: Source) {$/;"	m
asm_idiv	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_idiv(source: Source, zeroCheck: bool, negCheck: bool, a: int, div: bool) {$/;"	m
asm_imul	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_imul(dest: int, a: int, b: int, v: void) {$/;"	m
asm_imul_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_imul_i(dest: int, a: int, imm: int, v: void) {$/;"	m
asm_int80	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_int80() {$/;"	m
asm_int80_flags	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_int80_flags(flags: VReg) {$/;"	m
asm_lea	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_lea(dest: int, base: int, scale: byte, disp: int) {$/;"	m
asm_loada	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loada(m: (X86Assembler, X86Reg, X86Rm) -> void, dest: int, addr: Addr) {$/;"	m
asm_loada_disp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loada_disp(m: (X86Assembler, X86Reg, X86Rm) -> void, dest: int, addr: Addr, disp: int) {$/;"	m
asm_loada_disp_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loada_disp_sse(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, addr: Addr, disp: int) {$/;"	m
asm_loada_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loada_sse(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, addr: Addr) {$/;"	m
asm_loadx	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loadx(m: (X86Assembler, X86Reg, X86Rm) -> void, dest: int, base: int, scale: byte, disp: int, canTrap: bool, source: Source) {$/;"	m
asm_loadx_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_loadx_sse(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, base: int, scale: byte, disp: int, canTrap: bool, source: Source) {$/;"	m
asm_movd_l_l	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_movd_l_l(src: int, dst: int) {$/;"	m
asm_neg	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_neg(dest: int, a: int, v: void) {$/;"	m
asm_nop	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_nop() {$/;"	m
asm_not	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_not(dest: int, a: int, v: void) {$/;"	m
asm_op2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_op2(m: X86Assembler -> X86Op2, dest: int, a: int, b: int, v: void) {$/;"	m
asm_op2_a	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_op2_a(m: X86Assembler -> X86Op2, dest: int, a: int, addr: Addr, v: void) {$/;"	m
asm_op2_comm	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_op2_comm(m: X86Assembler -> X86Op2, dest: int, a: int, b: int, v: void) {$/;"	m
asm_op2_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_op2_i(m: X86Assembler -> X86Op2, dest: int, a: int, imm: int, v: void) {$/;"	m
asm_phi_resolve	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_phi_resolve(pos: int) {$/;"	m
asm_ret	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_ret() {$/;"	m
asm_set	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_set(cond: X86Cond, a: int) {$/;"	m
asm_sext	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sext(dest: int, a: int, size: int) {$/;"	m
asm_sh	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sh(shifter: X86Shifter, dest: int, cl: int, a: int, v: void) {$/;"	m
asm_sh_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sh_i(shifter: X86Shifter, dest: int, a: int, imm: int, v: void) {$/;"	m
asm_sse_bit_eq	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_bit_eq(dest: int, a: int, b: int, isDouble: bool) {$/;"	m
asm_sse_cmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_cmp(cond: X86Cond, dest: int, a: int, b: int, isDouble: bool) {$/;"	m
asm_sse_cvt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_cvt(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, a: int) {$/;"	m
asm_sse_f2i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_f2i(m: (X86MacroAssembler, X86Reg, SSERm) -> void, dest: int, a: int) {$/;"	m
asm_sse_f2l	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_f2l(m: (X86MacroAssembler, X86Rm, X86Rm, SSERm, bool) -> void, il: int, ih: int, a: int, isDouble: bool) {$/;"	m
asm_sse_fabs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_fabs(dest: int, a: int, isDouble: bool, v: void) {$/;"	m
asm_sse_i2f	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_i2f(m: (X86MacroAssembler, SSEReg, X86Rm) -> void, dest: int, a: int) {$/;"	m
asm_sse_l2f	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_l2f(m: (X86MacroAssembler, SSEReg, X86Rm, X86Rm, bool) -> void, dest: int, a: int, b: int, isDouble: bool) {$/;"	m
asm_sse_op2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_op2(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, a: int, b: int, v: void) {$/;"	m
asm_sse_round	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_round(m: (X86Assembler, SSEReg, SSERm, RoundingMode) -> void, dest: int, a: int,$/;"	m
asm_sse_sqrt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_sqrt(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, a: int) {$/;"	m
asm_sse_trunc	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_trunc(m: (X86MacroAssembler, X86Reg, SSERm) -> void, dest: int, a: int) {$/;"	m
asm_sse_view_double	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_view_double(m: (X86Assembler, SSEReg, SSERm) -> void, dest: int, il: int, ih: int) {$/;"	m
asm_sse_view_float	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_view_float(m: (X86Assembler, SSEReg, X86Rm) -> void, dest: int, a: int) {$/;"	m
asm_sse_view_int	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_view_int(m: (X86Assembler, X86Rm, SSEReg) -> void, dest: int, a: int) {$/;"	m
asm_sse_view_long	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_sse_view_long(m: (X86Assembler, SSERm, SSEReg) -> void, il: int, ih: int, a: int) {$/;"	m
asm_storex	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_storex(m: (X86Assembler, X86Rm, X86Reg) -> void, base: int, scale: byte, disp: int, val: int, canTrap: bool, source: Source) {$/;"	m
asm_storex_abs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_storex_abs(m: (X86Assembler, X86Rm, X86Reg) -> void, addr: Addr, val: int) {$/;"	m
asm_storex_abs_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_storex_abs_sse(m: (X86Assembler, SSERm, SSEReg) -> void, addr: Addr, val: int) {$/;"	m
asm_storex_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_storex_i(m: (X86Assembler, X86Rm, int) -> void, base: int, scale: byte, disp: int, imm: int, canTrap: bool, source: Source) {$/;"	m
asm_storex_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_storex_sse(m: (X86Assembler, SSERm, SSEReg) -> void, base: int, scale: byte, disp: int, val: int, canTrap: bool, source: Source) {$/;"	m
asm_tableswitch	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_tableswitch(sw: SsaSwitch, succ: Array<SsaCfEdge>, val: int) {$/;"	m
asm_test_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_test_i(base: int, scale: byte, disp: int, imm: int, canTrap: bool, source: Source) {$/;"	m
asm_throw	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_throw(source: Source, ex: string) {$/;"	m
asm_udiv	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_udiv(source: Source, zeroCheck: bool, a: int) {$/;"	m
asm_wadd	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_wadd(dl: int, dh: int, al: int, ah: int, bl: int, bh: int) {$/;"	m
asm_wdiv	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_wdiv(op: WideDivision, source: Source) {$/;"	m
asm_wmul	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_wmul(dl: int, dh: int, k: int, al: int, ah: int, bl: int, bh: int) {$/;"	m
asm_wsh	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_wsh(shifter: X86Shifter, dl: int, dh: int, al: int, ah: int, sl: int, sh: int) {$/;"	m
asm_wsub	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def asm_wsub(dl: int, dh: int, al: int, ah: int, bl: int, bh: int) {$/;"	m
asmls	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def asmls(logAlign: int, a: Array<Operand>, offsetOperand: int) {$/;"	m
asri	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def asri(rd: ArmReg, rm: ArmReg, imm: u5) { mov(rd, ArmOperand.RegSarImm(rm, imm)); }$/;"	m
asrr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def asrr(rd: ArmReg, rm: ArmReg, sh: ArmReg) { mov(rd, ArmOperand.RegSarReg(rm, sh)); }$/;"	m
assemble	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def assemble(opcode: int, a: Array<Operand>) {$/;"	m
assemble	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def assemble(opcode: int, x: Array<Operand>) {$/;"	m
assemble	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def assemble(opcode: int, x: Array<Operand>);$/;"	m
assemble	$VIRGIL/aeneas/src/util/Paths.v3	/^	def assemble(dir: string, fileName: string, ext: string) -> string {$/;"	f
assemble	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def assemble(opcode: int, a: Array<Operand>) {$/;"	m
assemble	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble(opcode: int, a: Array<Operand>) {$/;"	m
assemble2_op	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def assemble2_op(opcode: int, a: Array<Operand>, op: ArmOperand) {$/;"	m
assemble3_op	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def assemble3_op(opcode: int, a: Array<Operand>, op: ArmOperand) {$/;"	m
assembleInstrs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def assembleInstrs() {$/;"	m
assemble_m	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_m(opcode: int, a: X86_64Addr) {$/;"	m
assemble_m_i	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_m_i(opcode: int, a: X86_64Addr, val: Val) {$/;"	m
assemble_m_r	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_m_r(opcode: int, a: X86_64Addr, b: X86_64Gpr) {$/;"	m
assemble_m_s	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_m_s(opcode: int, a: X86_64Addr, b: X86_64Xmmr) {$/;"	m
assemble_none	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_none(opcode: int, a: Array<Operand>) {$/;"	m
assemble_offl	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def assemble_offl(opcode: int, a: Array<Operand>, off: ArmOffset) {$/;"	m
assemble_offs	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def assemble_offs(opcode: int, a: Array<Operand>, off: ArmSmallOffset) {$/;"	m
assemble_r	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_r(opcode: int, a: X86_64Gpr) {$/;"	m
assemble_r_i	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_r_i(opcode: int, a: X86_64Gpr, val: Val) {$/;"	m
assemble_r_m	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_r_m(opcode: int, a: X86_64Gpr, b: X86_64Addr) {$/;"	m
assemble_r_r	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_r_r(opcode: int, a: X86_64Gpr, b: X86_64Gpr) {$/;"	m
assemble_r_s	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_r_s(opcode: int, a: X86_64Gpr, b: X86_64Xmmr) {$/;"	m
assemble_s_m	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_s_m(opcode: int, a: X86_64Xmmr, b: X86_64Addr) {$/;"	m
assemble_s_r	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_s_r(opcode: int, a: X86_64Xmmr, b: X86_64Gpr) {$/;"	m
assemble_s_s	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def assemble_s_s(opcode: int, a: X86_64Xmmr, b: X86_64Xmmr) {$/;"	m
assignDef	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def assignDef(p: LsraDef) {$/;"	m
assignEnd	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def assignEnd(p: LsraPoint) {$/;"	m
assignInterval	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def assignInterval(i: Interval) -> this {$/;"	m
assignKill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def assignKill(p: LsraKill) {$/;"	m
assignParams	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def assignParams() {$/;"	m
assignPatternVal	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def assignPatternVal(mv: MatchStmtVerifier, pat: MatchPattern, val: Val) {$/;"	m
assignRegs	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def assignRegs() {$/;"	m
assignUses	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def assignUses(p: LsraUse) {$/;"	m
assignValues	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def assignValues() {$/;"	m
assignments	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var assignments: HashMap<CaseField, (int, Interval)>;$/;"	d
astore	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def astore(kind: JvmKind) {$/;"	m
atContents	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atContents = V3Op.newPtrAtContents(rangeType, ptrType);$/;"	d
atElem	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atElem = V3Op.newPtrAtRangeElem(rangeType, Int.TYPE, ptrType);$/;"	d
atEnd	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atEnd = V3Op.newPtrAtEnd(TypeUtil.REF_TYPE_PARAM.head, ptrType);$/;"	d
atEnd	$VIRGIL/lib/util/DataWriter.v3	/^	def atEnd() -> this {$/;"	m
atLength	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atLength = V3Op.newPtrAtLength(arrayType, ptrType);$/;"	d
atLimit	$VIRGIL/lib/util/DataReader.v3	/^	def atLimit() -> this {$/;"	m
atObject	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atObject = V3Op.newPtrAtObject(TypeUtil.REF_TYPE_PARAM.head, ptrType);$/;"	d
atRef	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def atRef = V3Op.newPtrAtRef(TypeUtil.LAYOUT_TYPE_PARAM.head, ptrType);$/;"	d
athrow	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def athrow() {$/;"	m
atl	$VIRGIL/lib/util/DataReader.v3	/^	def atl(npos: int, nlimit: int) -> this {$/;"	m
atoffset	$VIRGIL/lib/util/DataReader.v3	/^	def atoffset(npos_offset: int) -> this {$/;"	m
attach	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def attach(jmeth: JvmMethod) {$/;"	m
attachToSpecMethods	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def attachToSpecMethods() {$/;"	m
attribute_name_index	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var attribute_name_index: int;$/;"	d
attributes	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var attributes: Array<JvmAttribute>;$/;"	d
attrs	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def attrs   = Vector<JvmAttribute>.new(); \/\/ XXX: only code attr?$/;"	d
available	$VIRGIL/lib/util/DataReader.v3	/^	def available() -> int {$/;"	m
availableColor	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def availableColor = regSet.regSets[regSet.regClasses[RegClass.REF.tag]].length - 2;$/;"	d
balance	$VIRGIL/lib/util/Map.v3	/^	private def balance() {$/;"	m
base	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private var base: int;$/;"	d
baseName	$VIRGIL/aeneas/src/util/Paths.v3	/^	def baseName(fileName: string) -> string {$/;"	f
basename	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def basename(filepath: string) -> (string, string) {$/;"	m
bcount	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var bcount: Array<Array<int>>;	\/\/ per-branch, per-target count$/;"	d
before	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var before: List<(IcInterpreter, int) -> void>;$/;"	d
before	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def before(i: IcInterpreter, probeIp: int) {$/;"	m
before	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var before: MoveResolver;	\/\/ phys -> phys moves, before$/;"	d
beforeEntry	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def beforeEntry(i: IcInterpreter, probeIp: int) {$/;"	m
begin	$VIRGIL/aeneas/src/util/Progress.v3	/^	def begin(testCase: string) {$/;"	m
beginRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def beginRefMap(slots: int, max: int) {$/;"	m
beq	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def beq(rs: MipsReg, rt: MipsReg, off: i16)  { emit_r2i(0x10000000, rs, rt, u16.!(off)); }$/;"	m
beql	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def beql(rs: MipsReg, rt: MipsReg, off: i16) { emit_r2i(0x30000000, rs, rt, u16.!(off)); }$/;"	m
bestCallVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def bestCallVirtual(spec: IrSpec) -> Operator {$/;"	f
bestGetSelector	$VIRGIL/aeneas/src/core/Operator.v3	/^	def bestGetSelector(spec: IrSpec) -> Operator {$/;"	f
bestGetVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def bestGetVirtual(spec: IrSpec) -> Operator {$/;"	f
bfBlocks	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def bfBlocks(marker: SsaMarker) -> Array<SsaBlock> {$/;"	m
bgBlue	$VIRGIL/lib/term/Vt100.v3	/^	def bgBlue = esc("[0;44m");$/;"	d
bgCyan	$VIRGIL/lib/term/Vt100.v3	/^	def bgCyan = esc("[0;46m");$/;"	d
bgGreen	$VIRGIL/lib/term/Vt100.v3	/^	def bgGreen = esc("[0;42m");$/;"	d
bgMagenta	$VIRGIL/lib/term/Vt100.v3	/^	def bgMagenta = esc("[0;45m");$/;"	d
bgRed	$VIRGIL/lib/term/Vt100.v3	/^	def bgRed = esc("[0;41m");$/;"	d
bgWhite	$VIRGIL/lib/term/Vt100.v3	/^	def bgWhite = esc("[0;46m");$/;"	d
bgYellow	$VIRGIL/lib/term/Vt100.v3	/^	def bgYellow = esc("[0;43m");$/;"	d
bgez	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgez(rs: MipsReg, off: i16)    { emit_r1(0x02010000, rs, u16.!(off)); }$/;"	m
bgezal	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgezal(rs: MipsReg, off: i16)  { emit_r1(0x02110000, rs, u16.!(off)); }$/;"	m
bgezall	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgezall(rs: MipsReg, off: i16) { emit_r1(0x02130000, rs, u16.!(off)); }$/;"	m
bgezl	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgezl(rs: MipsReg, off: i16)   { emit_r1(0x02030000, rs, u16.!(off)); }$/;"	m
bgtz	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgtz(rs: MipsReg, off: i16)    { emit_r1(0x1b000000, rs, u16.!(off)); }$/;"	m
bgtzl	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bgtzl(rs: MipsReg, off: i16)   { emit_r1(0x3b000000, rs, u16.!(off)); }$/;"	m
bigEndIndex	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def bigEndIndex() -> int {$/;"	m
bigEndian	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def bigEndian: bool;$/;"	d
bigEndian	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def bigEndian: bool;		\/\/ true if data is loaded\/stored in big endian$/;"	d
bind	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def bind(label: Label) {$/;"	m
bind	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def bind(addr: Addr) {$/;"	m
bind	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def bind(r: Expr, b: VarBinding, t: Type) -> VarBinding {$/;"	m
bind	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def bind(label: Label) {$/;"	m
bind	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bind(label: X86_64Label) {$/;"	m
bind	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	private def bind() -> NetResult<void> {$/;"	m
bindInstOp	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def bindInstOp(expr: VarExpr, op: Operator, typeParams: List<TypeParamType>) -> VarBinding {$/;"	m
bindPatternVariables	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def bindPatternVariables(mv: MatchStmtVerifier, pat: MatchPattern) {$/;"	m
bindShape	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def bindShape(expr: VarExpr, receiver: Expr, etype: Type, result: LookupResult) -> VarBinding {$/;"	m
bindSize	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def bindSize(addr: Addr) {$/;"	m
bindTypeCon	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def bindTypeCon() {$/;"	m
bindVar	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def bindVar(varDecl: VarDecl) {$/;"	m
bindVar	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def bindVar(name: string, v: VarDecl) {$/;"	m
binding	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var binding: Type;$/;"	d
binop	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def binop(opcode: byte) {$/;"	m
binop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def binop(i: SsaApplyOp) -> Val {$/;"	m
binopSig	$VIRGIL/aeneas/src/types/Float.v3	/^	def binopSig = Function.sig(tupleType, ft);$/;"	d
binopSig	$VIRGIL/aeneas/src/types/Int.v3	/^	def binopSig = Function.sig(tupleType, it);$/;"	d
binopTypes	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	private def binopTypes = [t, t];$/;"	d
bitPos	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var bitPos: int;		\/\/ used in verification$/;"	d
bitWidth	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var bitWidth: byte;$/;"	d
bitmap	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def bitmap = BitMatrix.new(1, count);$/;"	d
bits	$VIRGIL/lib/util/BitMatrix.v3	/^	private var bits = Array<int>.new(numrows * width); \/\/ array that stores the data$/;"	d
blez	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def blez(rs: MipsReg, off: i16)    { emit_r1(0x18000000, rs, u16.!(off)); }$/;"	m
blezl	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def blezl(rs: MipsReg, off: i16)   { emit_r1(0x38000000, rs, u16.!(off)); }$/;"	m
block	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var block: SsaBlock;$/;"	d
block	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def block: SsaBlock;$/;"	d
block	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	var block: SsaBlock;$/;"	d
block	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	var block: SsaBlock;$/;"	d
block	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var block: SsaBlock;$/;"	d
block	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def block = SsaBlock.new();$/;"	d
blockColor	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def blockColor() -> this {$/;"	m
blockEnd	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var blockEnd: ArchInstr;$/;"	d
blockEndMap	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var blockEndMap: PartialMap<SsaBlock, SsaBlock>;$/;"	d
blockInfo	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def blockInfo = LazyMap<SsaBlock, SsaIcBlock>.new(SsaBlock.uid, SsaBlock.==, SsaIcBlock.new);$/;"	d
blockMap	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def blockMap = LazyMap<SsaBlock, SsaJvmBlock>.new(SsaBlock.uid, SsaBlock.==, SsaJvmBlock.new);$/;"	d
blockQueue	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var blockQueue: Vector<(SsaBlock, SsaBlock)>;$/;"	d
blockReloads	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var blockReloads: Array<Vector<VReg>>;$/;"	d
blockStartMap	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var blockStartMap: PartialMap<SsaBlock, SsaBlock>;$/;"	d
blockWeight	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var blockWeight: Array<int>;$/;"	d
blocks	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var blocks: List<SsaJvmBlock>; \/\/ block queue$/;"	d
blocks	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var blocks: SsaBlockOrder;$/;"	d
blocks	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def blocks = SsaBlockOrder.new(context.graph);$/;"	d
blocks	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var blocks: int;$/;"	d
blocks	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def blocks = Vector<SsaBlock>.new();$/;"	d
blocks	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	var blocks: Vector<SsaBlockInfo>;$/;"	d
bltz	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bltz(rs: MipsReg, off: i16)    { emit_r1(0x38000000, rs, u16.!(off)); }$/;"	m
bltzal	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bltzal(rs: MipsReg, off: i16)  { emit_r1(0x04100000, rs, u16.!(off)); }$/;"	m
bltzall	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bltzall(rs: MipsReg, off: i16) { emit_r1(0x04120000, rs, u16.!(off)); }$/;"	m
bltzl	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bltzl(rs: MipsReg, off: i16)   { emit_r1(0x42020000, rs, u16.!(off)); }$/;"	m
blue	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def blue<T>(fmt: string, a: T) { color(CTRL_BLUE, fmt, a); }$/;"	f
bne	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bne(rs: MipsReg, rt: MipsReg, off: i16) { emit_r2i(0x14000000, rs, rt, u16.!(off)); }$/;"	m
bnel	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def bnel(rs: MipsReg, rt: MipsReg, off: i16) { emit_r2i(0x54000000, rs, rt, u16.!(off)); }$/;"	m
body	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def body: Stmt;$/;"	d
boolConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def boolConst(v: bool) -> SsaConst {$/;"	m
boolbinop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def boolbinop(i: SsaApplyOp) -> int {$/;"	m
bound	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var bound: SsaInstr;	\/\/ value of bound$/;"	d
bound	$VIRGIL/aeneas/src/util/Label.v3	/^	def bound() -> bool { return pos >= 0; }$/;"	m
bound	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bound() -> bool { return pos >= 0; }$/;"	m
bound0	$VIRGIL/aeneas/src/types/Function.v3	/^	private var bound0: Signature;$/;"	d
boundIvInequality	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def boundIvInequality(iv: SsaLinearIv, op: BoundOp, cond: SsaInstr, condTrue: bool) {$/;"	m
boundMap	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var boundMap: Array<int>;  \/\/ which expressions are bound for partial applications$/;"	d
boundOp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var boundOp: BoundOp;	\/\/ operator of bound$/;"	d
boundOp	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def boundOp(p: ParserState, infix: V3Infix, op: Operator) -> InfixOp {$/;"	f
boundType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var boundType: Type;$/;"	d
boundsCheck	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def boundsCheck(facts: Fact.set) -> bool {$/;"	m
boundsCheck	$VIRGIL/rt/x86-64-darwin/System.v3	/^	private def boundsCheck<T>(array: Array<T>, start: int, len: int) {$/;"	f
boundscheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def boundscheck(i: SsaApplyOp) -> SsaInstr {$/;"	m
box	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def box(v: long) -> Val {$/;"	m
box	$VIRGIL/aeneas/src/types/Bool.v3	/^	def box(val: bool) -> Box<bool> {$/;"	f
box	$VIRGIL/aeneas/src/types/Byte.v3	/^	def box(val: byte) -> Val {$/;"	f
box	$VIRGIL/aeneas/src/types/Int.v3	/^	def box(val: long) -> Box<long> {$/;"	f
boxL	$VIRGIL/aeneas/src/types/Int.v3	/^	def boxL(v: long) -> Val {$/;"	m
boxString	$VIRGIL/aeneas/src/types/Byte.v3	/^	def boxString(str: Array<byte>, prog: Program) -> Record {$/;"	f
boxd	$VIRGIL/aeneas/src/core/Eval.v3	/^def boxd(d: double) -> Val { return Float64Val.new(u64.view(d)); }$/;"	f
boxf	$VIRGIL/aeneas/src/core/Eval.v3	/^def boxf(f: float) -> Val { return Float32Val.new(u32.view(f)); }$/;"	f
boxing	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var boxing: Boxing;$/;"	d
bps	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def bps = Vector<Breakpoint>.new();$/;"	d
branchValue	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def branchValue(op: byte) {$/;"	m
branch_bw	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def branch_bw(opcode: byte, pos: int) {$/;"	m
branch_fw	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def branch_fw(opcode: byte) -> int {$/;"	m
branches	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var branches: List<(SsaBlock, int)>;$/;"	d
branches	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	var branches: List<(int, SsaBlock)>; \/\/ XXX: pull branches up to MachCodeGen?$/;"	d
breakpoint	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var breakpoint: bool;$/;"	d
brk	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def brk(code: u20) { w.put_b32be(0x0000000d | int.view(code) << 6); }$/;"	m
bsf_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bsf_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
bsf_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bsf_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
bsr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def bsr(a: X86Reg, b: X86Rm) { emitbb_rm(0x0f, 0xBD, b, a.index); }$/;"	m
bsr_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bsr_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
bsr_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def bsr_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
btr_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def btr_m_i(a: X86_64Addr, imm: u6) -> this {$/;"	m
btr_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def btr_r_i(a: X86_64Gpr, imm: u6) -> this {$/;"	m
buf	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def buf = StringBuilder.new();$/;"	d
buf	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var buf = ArchInstrBuffer.new(codegen, codegen.mach.prog, regSet);$/;"	d
buf	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	var buf = ArchInstrBuffer.new(codegen, codegen.mach.prog, regSet);$/;"	d
buf	$VIRGIL/aeneas/src/mach/RegState.v3	/^	var buf = ArchInstrBuffer.new(codegen, codegen.mach.prog, regSet);$/;"	d
buf	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/util/Terminal.v3	/^	private def buf = TerminalBuffer.new();$/;"	d
buf	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def buf = DataWriter.new().grow(100);$/;"	d
buf	$VIRGIL/lib/util/StringBuilder.v3	/^	def var buf: Array<byte>; \/\/ TODO: keep private$/;"	d
bufSize	$VIRGIL/lib/util/IO.v3	/^	private def bufSize: int;$/;"	d
buffer	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var buffer: Buffer;$/;"	d
buffer	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def buffer = Vector<SsaInstr>.new();  \/\/ reusable input buffer$/;"	d
build	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def build(newMethod: IrMethod) {$/;"	m
build	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def build() -> IrClass {$/;"	m
build	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def build(); \/\/ subclasses generate code$/;"	m
build	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def build(compiler: Compiler, config: MachLoweringConfig) {$/;"	m
buildAbstractClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildAbstractClass(invoke_meth: JvmMethod) {$/;"	m
buildClass	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def buildClass(decl: VstCompound) -> IrClass {$/;"	m
buildClassClosure	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildClassClosure(invoke_meth: JvmMethod) {$/;"	m
buildComponentClosure	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildComponentClosure(invoke_meth: JvmMethod) {$/;"	m
buildData	$VIRGIL/aeneas/src/main/Version.v3	/^	var buildData: string;$/;"	d
buildDescriptor	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def buildDescriptor() -> string;$/;"	m
buildField	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildField(f: IrField) {$/;"	m
buildFile	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def buildFile(file: VstFile) {$/;"	m
buildGraph	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def buildGraph(block: SsaBlock, cur: ArchInstr) {$/;"	m
buildGraphDefLive	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def buildGraphDefLive(vreg: VReg) {$/;"	m
buildGraphDefNotLive	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def buildGraphDefNotLive(vreg: VReg) {$/;"	m
buildGraphUseLive	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def buildGraphUseLive(vreg: VReg) {$/;"	m
buildHeapInitializer	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildHeapInitializer() {$/;"	m
buildInit	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildInit(f: IrField) {$/;"	m
buildIntervals	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def buildIntervals() -> LsraPoint {$/;"	m
buildMainMethodBridge	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildMainMethodBridge(jname: string, jsig: JvmSig, args: Type, rt: Type) {$/;"	m
buildMembers	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def buildMembers() {$/;"	m
buildMethod	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildMethod(m: IrMethod) {$/;"	m
buildNew	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildNew(m: IrMethod) {$/;"	m
buildNewTypeArgs	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def buildNewTypeArgs(list: List<TypeArgs>) -> TypeArgs {$/;"	m
buildOpClosure	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def buildOpClosure(context: SsaContext, ssa: SsaBuilder, op: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {$/;"	m
buildOpMethod	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def buildOpMethod(compiler: Compiler, op: Operator, facts: Fact.set) -> IrSpec {$/;"	m
buildStackMap	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def buildStackMap(codeOffset: int, outgoing: MachCallConv, lp: int) -> int {$/;"	m
buildStackMap	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def buildStackMap(off: int, conv: MachCallConv, lp: int) -> int {$/;"	m
buildTagMethod	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def buildTagMethod() {$/;"	m
buildTypeEnv	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def buildTypeEnv(parent: TypeEnv, typeParams: List<TypeParamType>) -> TypeEnv {$/;"	m
builderOf	$VIRGIL/lib/util/Strings.v3	/^	def builderOf(str: string) -> StringBuilder {$/;"	f
bwCache	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var bwCache = TypeUtil.newTypeMap<byte>();$/;"	d
byCalls	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def byCalls(that: IcMethodProf) -> bool {$/;"	m
byMaximum	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def byMaximum(a: (IrMethod, u64), b: (IrMethod, u64)) -> bool {$/;"	m
byTime	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def byTime(a: (IrMethod, (int, int)), b: (IrMethod, (int, int))) -> bool {$/;"	m
byTotal	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def byTotal(that: IcMethodProf) -> bool {$/;"	m
byt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def byt(a: SsaInstr) -> int {$/;"	m
byteOffset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var byteOffset: int = -1;$/;"	d
byteSize	$VIRGIL/aeneas/src/types/Float.v3	/^	def byteSize() -> int {$/;"	m
byteSize	$VIRGIL/aeneas/src/types/Int.v3	/^	def byteSize() -> int {$/;"	m
byteSize	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def byteSize() -> int {$/;"	m
byteSize	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var byteSize: int;$/;"	d
bytes	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var bytes: Array<byte>;$/;"	d
cache	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def cache = TypeUtil.newTypeMap<IntNorm>();$/;"	d
cache	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	private var cache: Pointer_OpCache;$/;"	d
cache	$VIRGIL/aeneas/src/types/Float.v3	/^	private var cache: FloatOpCache;$/;"	d
cache	$VIRGIL/aeneas/src/types/Int.v3	/^	private var cache: IntOpCache;$/;"	d
cache	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	private def cache = Array<IntRepType>.new(16);$/;"	d
cache	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	private var cache: V3EnumSet_OpCache;$/;"	d
cache	$VIRGIL/lib/util/Map.v3	/^	private var cache: Bucket<K, V>;	\/\/ cache for last entry get\/set$/;"	d
cacheVstFile	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var cacheVstFile: VstFile;$/;"	d
cachedSpec	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	private var cachedSpec: IrSpec;$/;"	d
calc_offset	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def calc_offset(frame: MachFrame, loc: int, isSSE: bool) -> int {$/;"	m
calculate	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def calculate(data: Array<byte>) -> int {$/;"	f
call	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def call(i_old: SsaApplyOp, funcRep: Mach_FuncRep, args: Array<SsaInstr>) {$/;"	m
call	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def call: SsaApplyOp;$/;"	d
call	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def call(off: int) { emitbd(0xE8, off); } \/\/ relative call$/;"	m
callConv	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var callConv: MachCallConv;$/;"	d
call_addr	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def call_addr(addr: Addr) {$/;"	m
call_addr	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def call_addr(addr: Addr) {$/;"	m
call_cycles_add	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_cycles_add(amount: i64);							\/\/ U Ry Rt T$/;"	f
call_cycles_add128	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_cycles_add128(amount_high: i64, amount_low: i64);				\/\/ U Ry Rt T$/;"	f
call_data_append	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_data_append(src: i32, size: i32);						\/\/ U Ry Rt T$/;"	f
call_new	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_new(										\/\/ U Ry Rt T$/;"	f
call_on_cleanup	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_on_cleanup(fun: i32, env: i32);						\/\/ U Ry Rt T$/;"	f
call_perform	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def call_perform() -> i32;								\/\/ U Ry Rt T$/;"	f
call_rel_far	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def call_rel_far(label: X86_64Label) -> this {$/;"	m
calld	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def calld(off: int) -> this { emitbd(0x9A, off); } \/\/ direct call$/;"	m
calld	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def calld(off: int) { emitbd(0x9A, off); } \/\/ direct call$/;"	m
calld_addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def calld_addr(m: X86_64Addr) -> this {$/;"	m
calleeParam	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def calleeParam(i: int) -> int {$/;"	m
calleeRet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def calleeRet(i: int) -> int {$/;"	m
calleeStart	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def calleeStart: int;$/;"	d
callerBlock	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var callerBlock: SsaBlock;$/;"	d
callerFrame	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def callerFrame(i: Pointer, s: Pointer, frameWords: int) -> (Pointer, Pointer) {$/;"	f
callerParam	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def callerParam(i: int) -> int {$/;"	m
callerRet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def callerRet(i: int) -> int {$/;"	m
callerStart	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def callerStart: int;$/;"	d
callr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def callr(off: int) -> this { emitbd(0xE8, off); } \/\/ relative call$/;"	m
callr_addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def callr_addr(m: X86_64Addr) -> this {$/;"	m
callr_v3	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def callr_v3(addr: Addr) -> this {$/;"	m
calls	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var calls: int;			\/\/ invocation count$/;"	d
calls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var calls: Array<SpecEdge>;$/;"	d
canAccessMember	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def canAccessMember(decl: VstMember) -> bool {$/;"	m
canCover	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def canCover(i: SsaInstr) -> bool {$/;"	m
canDistinguish	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def canDistinguish(state: Array<ScalarPattern>, elements: Array<bool>) -> bool {$/;"	m
canDistinguish	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def canDistinguish(active: Array<bool>) {$/;"	m
canister_cycle_balance	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_cycle_balance() -> i64;							\/\/ *$/;"	f
canister_cycle_balance128	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_cycle_balance128(dst: i32);						\/\/ *$/;"	f
canister_self_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_self_copy(dst: i32, offset: i32, size: i32);				\/\/ *$/;"	f
canister_self_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_self_size() -> i32;							\/\/ *$/;"	f
canister_status	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_status() -> i32;								\/\/ *$/;"	f
canister_version	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def canister_version() -> i64;								\/\/ *  $/;"	f
cases	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	var cases: Array<Array<PackingField>>;$/;"	d
cases	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var cases: Array<VstCaseMember>;$/;"	d
cast	$VIRGIL/lib/util/StringBuilder.v3	/^def cast<F, T>(p: F) -> T {$/;"	f
cdq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cdq() -> this { emitb(0x99); }$/;"	m
cdq	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cdq() { emitb(0x99); } \/\/ convert doubleword to quadword$/;"	m
center	$VIRGIL/lib/util/StringBuilder.v3	/^	def center(ch: byte, nchars: int, len: int) -> this {$/;"	m
certified_data_set	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def certified_data_set(src: i32, size: i32);						\/\/ I G U Ry Rt T$/;"	f
cfgr	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def cfgr = CfgRestructurer.new();$/;"	d
cfopt	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var cfopt: SsaCfOptimizer;$/;"	d
char	$VIRGIL/lib/util/TextReader.v3	/^	def var char: byte;			\/\/ current byte$/;"	d
check	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def check(cond: bool, msg: string, i: SsaLink) {$/;"	m
check2	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def check2(cond: bool, msg: string, i: SsaLink, j: SsaLink) {$/;"	m
checkAbs	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def checkAbs(m: X86_64Addr) -> int {$/;"	m
checkAndMark	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def checkAndMark(i: SsaLink) {$/;"	m
checkAndPruneGraph	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def checkAndPruneGraph() -> bool {$/;"	m
checkDistinguishable	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def checkDistinguishable(state: Array<ScalarPattern>) -> bool {$/;"	m
checkDistinguishable	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def checkDistinguishable() -> bool {$/;"	m
checkEnumPattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkEnumPattern(mv: MatchStmtVerifier, pat: MatchPattern) {$/;"	m
checkFact	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def checkFact(set: Fact.set) -> bool { return facts >= set; }$/;"	m
checkField	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkField(decl: VstField) {$/;"	m
checkFloatRoundITypeArg	$VIRGIL/aeneas/src/types/Float.v3	/^def checkFloatRoundITypeArg(tv: TypeVarType, t: Type) -> Type {$/;"	f
checkFloatViewTypeArg	$VIRGIL/aeneas/src/types/Float.v3	/^def checkFloatViewTypeArg(width: int, tv: TypeVarType, t: Type) -> Type {$/;"	f
checkGraphSize	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^def checkGraphSize(ssa: SsaGraph, maxBlocks: int, maxInstrs: int) -> bool {$/;"	f
checkIndexedRead	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkIndexedRead(expr: IndexExpr, outer: Type) -> Type {$/;"	m
checkIndexedWrite	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkIndexedWrite(expr: IndexExpr, outer: Type) -> Type {$/;"	m
checkInputs	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^def checkInputs(inputs: Array<SsaInstr>) {$/;"	f
checkIntOpTypeArg	$VIRGIL/aeneas/src/types/Int.v3	/^def checkIntOpTypeArg(op: string, tv: TypeVarType, t: Type) -> Type {$/;"	f
checkIntViewTypeArg	$VIRGIL/aeneas/src/types/Int.v3	/^def checkIntViewTypeArg(width: int, tv: TypeVarType, t: Type) -> Type {$/;"	f
checkLayoutCycle	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkLayoutCycle(decl: VstLayout) {$/;"	m
checkLayoutField	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkLayoutField(decl: VstLayoutField) {$/;"	m
checkLayoutTypeArg	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^def checkLayoutTypeArg(tv: TypeVarType, t: Type) -> Type {$/;"	f
checkMemberInit	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def checkMemberInit(expr: VarExpr, binding: VarBinding) -> VarBinding {$/;"	m
checkMethod	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkMethod(decl: VstMethod) {$/;"	m
checkMethodOverride	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkMethodOverride(decl: VstMethod, binding: ResolvedMember) {$/;"	m
checkMethodParam	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkMethodParam(param: ParamDecl, map: Map<string, Decl>) {$/;"	m
checkN	$VIRGIL/lib/util/DataReader.v3	/^	def checkN(length: int) -> bool {$/;"	m
checkNew	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkNew(decl: VstNew) {$/;"	m
checkNewParam	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkNewParam(param: ParamDecl, mdecl: VstNew, map: Map<string, Decl>) {$/;"	m
checkNoTypeVars	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^def checkNoTypeVars(t: Type) {$/;"	f
checkNoTypeVarsInOp	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^def checkNoTypeVarsInOp(op: Operator) {$/;"	f
checkOpenness	$VIRGIL/aeneas/src/core/Operator.v3	/^	def checkOpenness() -> Open {$/;"	m
checkPackingExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkPackingExpr(env: VarEnvironment, expr: VstPackingExpr, bitWidth: byte) {$/;"	m
checkParam	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkParam(param: ParamDecl, map: Map<string, Decl>) {$/;"	m
checkRefTypeArg	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^def checkRefTypeArg(tv: TypeVarType, t: Type) -> Type {$/;"	f
checkStackHeight	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def checkStackHeight(block: SsaBlock) {$/;"	m
checkTypeCastTypeArg	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^def checkTypeCastTypeArg(tv: TypeVarType, t: Type, toType: Type) -> Type {$/;"	f
checkTypeCon	$VIRGIL/aeneas/src/types/Function.v3	/^	private def checkTypeCon(ftype: Type) -> Type {$/;"	f
checkTypeQueryTypeArg	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^def checkTypeQueryTypeArg(tv: TypeVarType, t: Type, toType: Type) -> Type {$/;"	f
checkUseOrder	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def checkUseOrder(pos: int, usepos: int, max: int) {$/;"	m
checkVarDecl	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkVarDecl(varDecl: VarDecl) {$/;"	m
checkVariantPattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkVariantPattern(mv: MatchStmtVerifier, pat: MatchPattern) {$/;"	m
checkWrite	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def checkWrite(left: Expr) -> Type {$/;"	m
check_leb_ext	$VIRGIL/lib/util/DataReader.v3	/^	private def check_leb_ext(b: byte, signed: bool, shift: u3, msg: string) {$/;"	m
checkcast	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def checkcast(jtype: JvmType) {$/;"	m
children	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def children = Vector<DwarfDie>.new();$/;"	d
children	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var children: List<RaClass>;		\/\/ list of all child classes$/;"	d
children	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var children: List<VariantNorm>;$/;"	d
children	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var children: List<CctNode<F>>;	\/\/ children of this node$/;"	d
chmod	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def chmod(args: Arguments) -> Result {$/;"	m
chmod	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def chmod(fileName: string, mode: int) {$/;"	f
chooseRegister	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def chooseRegister(constraint: int) -> int {$/;"	m
chunks	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var chunks: List<Array<byte>>;$/;"	d
classCpe	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var classCpe: JvmCpe_Class; \/\/ for performance, the class that uses this UTF8$/;"	d
classDecl	$VIRGIL/aeneas/src/v3/V3.v3	/^	def classDecl(t: Type) -> VstClass {$/;"	f
classDecl	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def classDecl: VstClass;$/;"	d
classDecl	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var classDecl: VstClass;$/;"	d
classFieldOffset	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def classFieldOffset(f: IrSpec) -> int {$/;"	m
classIdRange	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def classIdRange(t: Type) -> (int, int) {$/;"	m
classMap	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def classMap = TypeUtil.newTypeMap<IrClass>();$/;"	d
classMap	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def classMap = Strings.newMap<JvmClass>();$/;"	d
classQueue	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def classQueue = Vector<JvmClassGen>.new();$/;"	d
classTable	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def classTable = TableIndex<VstCompound, (int, int)>.new(hashVstCompound);$/;"	d
classType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def classType: Type;$/;"	d
classType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var classType: ClassType;$/;"	d
classes	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def classes = Vector<IrClass>.new();$/;"	d
classes	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def classes = Vector<RaClass>.new();$/;"	d
classes	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def classes = Vector<VstClass>.new();$/;"	d
clean	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def clean() {$/;"	m
clear	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def clear() {$/;"	m
clear	$VIRGIL/lib/util/BitMatrix.v3	/^	def clear(row: int, col: int) -> bool {$/;"	m
clear	$VIRGIL/lib/util/DataWriter.v3	/^	def clear() -> this {$/;"	m
clear	$VIRGIL/lib/util/Stack.v3	/^	def clear() {$/;"	m
clear	$VIRGIL/lib/util/Vector.v3	/^	def clear() -> this {$/;"	m
clearMark	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def clearMark() { this.mark = -1; }$/;"	m
clearMark	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def clearMark() { block.mark = -1; }$/;"	m
clearMark	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def clearMark(i: SsaLink);$/;"	m
clearRow	$VIRGIL/lib/util/BitMatrix.v3	/^	def clearRow(row: int) {$/;"	m
clinit_code	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var clinit_code: JvmCodeBuilder;$/;"	d
clinit_meth	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var clinit_meth: JvmMethod;$/;"	d
close	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def close() {$/;"	m
close	$VIRGIL/lib/util/IO.v3	/^	def close() {$/;"	m
closeAllFiles	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def closeAllFiles() {$/;"	m
closure	$VIRGIL/lib/util/WorkQueue.v3	/^def closure<A, B>(func: A -> B, a: A, v: void) { func(a); }$/;"	f
closureAdapters	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def closureAdapters = TypeUtil.newTypePairMap<JvmV3ClosureAdapterGen>();$/;"	d
closureClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var closureClass: JvmClass;$/;"	d
closureMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def closureMethod(m: RaMethod) -> RaMethod {$/;"	m
closures	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	var closures: Array<IrClass>;$/;"	d
cmdoffset	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var cmdoffset: int;$/;"	d
cmds	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def cmds = Vector<MachO_LoadCmd>.new();$/;"	d
cmdsize	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var cmdsize: int;$/;"	d
cmn	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def cmn(rn: ArmReg, op: ArmOperand) { data2_0(23, rn, op); }$/;"	m
cmov	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	private def cmov(a: X86Reg, b: X86Rm, sop: int) { emitbb_rm(0x0f, sop, b, a.index); }$/;"	m
cmov_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmov_m(cond: X86_64Cond, a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
cmov_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmov_r(cond: X86_64Cond, a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
cmova	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmova (a: X86Reg, b: X86Rm) { cmov(a, b, 0x47); }$/;"	m
cmovc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovc (a: X86Reg, b: X86Rm) { cmov(a, b, 0x42); }$/;"	m
cmovg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovg (a: X86Reg, b: X86Rm) { cmov(a, b, 0x4F); }$/;"	m
cmovge	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovge(a: X86Reg, b: X86Rm) { cmov(a, b, 0x4D); }$/;"	m
cmovl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovl (a: X86Reg, b: X86Rm) { cmov(a, b, 0x4C); }$/;"	m
cmovle	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovle(a: X86Reg, b: X86Rm) { cmov(a, b, 0x4E); }$/;"	m
cmovna	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovna(a: X86Reg, b: X86Rm) { cmov(a, b, 0x46); }$/;"	m
cmovnc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovnc(a: X86Reg, b: X86Rm) { cmov(a, b, 0x43); }$/;"	m
cmovno	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovno(a: X86Reg, b: X86Rm) { cmov(a, b, 0x41); }$/;"	m
cmovnp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovnp(a: X86Reg, b: X86Rm) { cmov(a, b, 0x4B); }$/;"	m
cmovns	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovns(a: X86Reg, b: X86Rm) { cmov(a, b, 0x49); }$/;"	m
cmovnz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovnz(a: X86Reg, b: X86Rm) { cmov(a, b, 0x45); }$/;"	m
cmovo	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovo (a: X86Reg, b: X86Rm) { cmov(a, b, 0x40); }$/;"	m
cmovp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovp (a: X86Reg, b: X86Rm) { cmov(a, b, 0x4A); }$/;"	m
cmovs	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovs (a: X86Reg, b: X86Rm) { cmov(a, b, 0x48); }$/;"	m
cmovx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovx(cond: X86Cond, a: X86Reg, b: X86Rm) { cmov(a, b, 0x40 + cond.index); }$/;"	m
cmovz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmovz (a: X86Reg, b: X86Rm) { cmov(a, b, 0x44); }$/;"	m
cmp	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def cmp(a: (IcMethod, int), b: (IcMethod, int)) -> bool {$/;"	m
cmp	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def cmp(a: (IrMethod, int, int), b: (IrMethod, int, int)) -> bool {$/;"	m
cmp	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def cmp(rn: ArmReg, op: ArmOperand) { data2_0(21, rn, op); }$/;"	m
cmp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var cmp: X86Op2;$/;"	d
cmpSig	$VIRGIL/aeneas/src/types/Float.v3	/^	def cmpSig = Function.sig(tupleType, Bool.TYPE);$/;"	d
cmpSig	$VIRGIL/aeneas/src/types/Int.v3	/^	def cmpSig = Function.sig(tupleType, Bool.TYPE);$/;"	d
cmp_fp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cmp_fp(cond: X86Cond, dest: X86Reg, a: SSEReg, b: SSERm, isDouble: bool) {$/;"	m
cmp_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmp_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 7); }$/;"	m
cmp_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmp_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 7); }$/;"	m
cmp_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmp_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 7); }$/;"	m
cmp_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmp_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 7); }$/;"	m
cmp_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmp_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 7); }$/;"	m
cmpb_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpb_m_i(a: X86_64Addr, i: int\/*XXX:byte*\/) -> this { \/\/ XXX: factor out common routine$/;"	m
cmpb_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpb_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {  \/\/ XXX: factor out common routine$/;"	m
cmpb_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpb_r_i(a: X86_64Gpr, i: int\/*XXX:byte*\/) -> this { \/\/ XXX: factor out common routine$/;"	m
cmpb_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpb_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {  \/\/ XXX: factor out common routine$/;"	m
cmpb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpb_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  {  \/\/ XXX: factor out common routine$/;"	m
cmpd_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def cmpd_r_i_i(rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
cmpd_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def cmpd_r_r_sh_i(rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u5) -> this {$/;"	m
cmpeqpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpeqpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpeqps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpeqps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpeqsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpeqsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x0); }$/;"	m
cmpeqss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpeqss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x0); }$/;"	m
cmplepd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmplepd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpleps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpleps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmplesd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmplesd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x2); }$/;"	m
cmpless	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpless(a: SSEReg, b: SSERm) { cmpss(a, b, 0x2); }$/;"	m
cmpltpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpltpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpltps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpltps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpltsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpltsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x1); }$/;"	m
cmpltss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpltss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x1); }$/;"	m
cmpneqpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpneqpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpneqps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpneqps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpneqsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpneqsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x4); }$/;"	m
cmpneqss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpneqss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x4); }$/;"	m
cmpnlesd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpnlesd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x6); }$/;"	m
cmpnless	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpnless(a: SSEReg, b: SSERm) { cmpss(a, b, 0x6); }$/;"	m
cmpnltsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpnltsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x5); }$/;"	m
cmpnltss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpnltss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x5); }$/;"	m
cmpordsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpordsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x7); }$/;"	m
cmpordss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpordss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x7); }$/;"	m
cmppd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmppd_s_s(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpps_s_s(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpq_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def cmpq_r_i_i(rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
cmpq_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def cmpq_r_r_sh_i(rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u6) -> this {$/;"	m
cmpsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	private def cmpsd(a: SSEReg, b: SSERm, c: byte) {$/;"	m
cmpsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpsd_s_m(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cmpsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpsd_s_s(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	private def cmpss(a: SSEReg, b: SSERm, c: byte) {$/;"	m
cmpss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpss_s_m(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cmpss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpss_s_s(cmp: SSECmp, a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpunordpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpunordpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpunordps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpunordps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cmpunordsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpunordsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x3); }$/;"	m
cmpunordss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpunordss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x3); }$/;"	m
cmpxchg_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchg_m_r(b: X86_64Addr, a: X86_64Gpr) -> this {$/;"	m
cmpxchg_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchg_r_r(b: X86_64Gpr, a: X86_64Gpr) -> this {$/;"	m
cmpxchgb_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchgb_m_r(b: X86_64Addr, a: X86_64Gpr) -> this {$/;"	m
cmpxchgb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchgb_r_r(b: X86_64Gpr, a: X86_64Gpr) -> this {$/;"	m
cmpxchgw_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchgw_m_r(b: X86_64Addr, a: X86_64Gpr) -> this {$/;"	m
cmpxchgw_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cmpxchgw_r_r(b: X86_64Gpr, a: X86_64Gpr) -> this {$/;"	m
cmpxchngb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpxchngb(b: X86Rm, a: X86Reg) { emitbb_rm(0x0F, 0xB0, b, a.index); } \/\/ compare and exchange byte$/;"	m
cmpxchngd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpxchngd(b: X86Rm, a: X86Reg) { emitbb_rm(0x0F, 0xB1, b, a.index); } \/\/ compare and exchange doubleword$/;"	m
cmpxchngw	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cmpxchngw(b: X86Rm, a: X86Reg) { \/\/ compare and exchange word$/;"	m
coalesce	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var coalesce: int;$/;"	d
code	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def code = Abbrev_code++; \/\/ unique code for abbrev tag$/;"	d
code	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var code: Array<IcInstr>;	\/\/ current code$/;"	d
code	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var code = Array<byte>.new(20); \/\/ TUNABLE: initial size of JvmCodeBuilder buffer$/;"	d
code	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var code: Array<byte>;$/;"	d
code	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def code: AddressSpace;$/;"	d
code	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def code = Vector<MachInstr>.new();$/;"	d
code	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def code = Vector<IcInstr>.new();$/;"	d
code	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def code = Vector<CfgInstr>.new();$/;"	d
codeOffset	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def codeOffset() -> int {$/;"	m
codeOffset	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def codeOffset() -> int {$/;"	m
codePages	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def codePages() -> int {$/;"	m
codePointerSize	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^var codePointerSize: u8;$/;"	d
codeRegion	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def codeRegion    = Region.new("code", code);$/;"	d
codeRegion	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def codeRegion = mach.codeRegion;$/;"	d
codeSize	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var codeSize: long;$/;"	d
codeStart	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var codeStart: long;$/;"	d
codeStart	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var codeStart: int = -1;$/;"	d
codeStart	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var codeStart: int;$/;"	d
codeStartOffset	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def codeStartOffset: int;$/;"	d
codeStartOffset	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def codeStartOffset: int;$/;"	d
codegen	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var codegen: SsaArm64Gen;$/;"	d
codegen	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var codegen: SsaMachGen;$/;"	d
codegen	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var codegen: SsaX86_64Gen;$/;"	d
color	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var color: bool = false; \/\/ whether a node requires a color even without use$/;"	d
color	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var color: byte;		\/\/ used in traversing the graph$/;"	d
color	$VIRGIL/aeneas/src/util/Terminal.v3	/^	var color: string;$/;"	d
colorGraph	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def colorGraph() {$/;"	m
colorVerbose	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def colorVerbose = false;$/;"	d
coloring	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var coloring: Array<byte>;$/;"	d
column	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def column: u32;$/;"	d
column	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def column(at: int) -> int {$/;"	m
column	$VIRGIL/lib/util/TextReader.v3	/^	def var column: int;			\/\/ current column$/;"	d
com	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def com(a: Arm64Cond, b: Arm64Cond) {$/;"	f
com	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def com(a: X86_64Cond, b: X86_64Cond) {$/;"	f
com	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def com(a: X86Cond, b: X86Cond) {$/;"	f
combineInterfere	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def combineInterfere(x_: int, y_: int) -> Vector<int> {$/;"	m
commonDominator	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var commonDominator: SsaBlock;$/;"	d
commonDominator	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def commonDominator(a: SsaBlockInfo, b: SsaBlockInfo) -> SsaBlockInfo {$/;"	m
commonSuperClass	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def commonSuperClass(ct1: ClassType, ct2: ClassType) -> (ClassType, ClassType) {$/;"	f
commute	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def commute() -> BoundOp {$/;"	m
commute	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def commute(op: Operator) -> Operator {$/;"	m
commute	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def commute() -> ArmCond {$/;"	m
commute	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	var commute: Arm64Cond;$/;"	d
commute	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var commute: X86_64Cond;$/;"	d
commute	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var commute: X86Cond;$/;"	d
commute	$VIRGIL/lib/util/Functions.v3	/^	def commute<A, B, R>(f: (A, B) -> R) -> (B, A) -> R {$/;"	f
commute0	$VIRGIL/lib/util/Functions.v3	/^	private def commute0<A, B, R>(f: (A, B) -> R, b: B, a: A) -> R {$/;"	f
compRecords	$VIRGIL/aeneas/src/core/Program.v3	/^	var compRecords: Array<Record>;$/;"	d
compare	$VIRGIL/aeneas/src/types/Int.v3	/^	def compare(infix: V3Infix, opcode: Opcode) -> Operator {$/;"	m
compareFieldOffset	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def compareFieldOffset(a: VstLayoutField, b: VstLayoutField) -> bool {$/;"	m
compareIndex	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	private def compareIndex(a: (int, int), b: (int, int)) -> bool {$/;"	m
compareIntType	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def compareIntType(t: Type) -> IntType {$/;"	m
compareTypeArgs	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def compareTypeArgs(rm: RaMethod, typeArgs: Array<Type>) -> bool {$/;"	m
compilationDir	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def compilationDir = DwarfDir.new(CLOptions.DWARF_CWD.val, 0u);$/;"	d
compile	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def compile(args: Array<string>) -> Program {$/;"	f
compile	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def compile() -> bool {$/;"	m
compileAndRun	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def compileAndRun(args: Array<string>) -> int {$/;"	f
compileMultiple	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def compileMultiple(args: Array<string>) -> bool {$/;"	f
compileOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def compileOpt = OptionGroup.new("COMPILE", options);$/;"	d
compiler	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def compiler = compilation.compiler;$/;"	d
complexRecordMap	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var complexRecordMap = V3.newRecordMap<Array<Val>>();$/;"	d
componentDecl	$VIRGIL/aeneas/src/v3/V3.v3	/^	def componentDecl(t: Type) -> VstComponent {$/;"	f
componentDecl	$VIRGIL/aeneas/src/v3/V3Component.v3	/^	def componentDecl: VstComponent;$/;"	d
componentFieldPtr	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def componentFieldPtr(f: IrSpec) -> SsaInstr {$/;"	m
componentFieldPtr	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def componentFieldPtr(f: IrSpec) -> Val {$/;"	m
componentType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def componentType: Type;$/;"	d
components	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def components = Vector<VstComponent>.new();$/;"	d
compound	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def compound: VstCompound;$/;"	d
compound	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def compound: VstCompound;$/;"	d
compute	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	private def compute(paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {$/;"	f
compute	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def compute(mach: MachProgram, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {$/;"	f
compute	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def compute(mach: MachProgram, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {$/;"	f
compute	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	private def compute(mach: MachProgram, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {$/;"	f
computeArgLoads	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def computeArgLoads(args: Array<SsaDfEdge>) {$/;"	m
computeBlockWeight	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def computeBlockWeight(weight: int, start: int, end: int) -> int {$/;"	m
computeCast	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def computeCast(xt: Type, yt: Type) -> Conversion {$/;"	f
computeConversion	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def computeConversion(xt: Type, yt: Type) -> Conversion {$/;"	f
computeDominators	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def computeDominators() {$/;"	m
computeFrameSize	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def computeFrameSize(frame: MachFrame) -> MachFrame {$/;"	m
computeInstrEffect	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def computeInstrEffect(block: SsaBlock, index: int, i: SsaInstr) {$/;"	m
computeInstrTotal	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def computeInstrTotal(pm: IcMethodProf) {$/;"	m
computeLiveoutForBlock	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def computeLiveoutForBlock(block: SsaBlock) {$/;"	m
computeMaximum	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def computeMaximum(meth: IrMethod) -> (IrMethod, u64) {$/;"	m
computeOrderWithLoops	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	private def computeOrderWithLoops() {$/;"	m
computeVarRefSlotIndex	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def computeVarRefSlotIndex() {$/;"	m
computingLiveness	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var computingLiveness: bool;$/;"	d
concat	$VIRGIL/lib/util/Arrays.v3	/^	def concat<T>(a: Array<T>, b: Array<T>) -> Array<T> {$/;"	f
cond	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def cond: X86Cond;$/;"	d
cond	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	private var cond: ArmCond = ArmCond.AL;$/;"	d
configureCompiler	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def configureCompiler(compiler: Compiler) {}$/;"	m
configureCompiler	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureCompiler	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureCompiler	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def configureCompiler(compiler: Compiler) { }$/;"	m
configureCompiler	$VIRGIL/aeneas/src/os/Linux.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureCompiler	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureCompiler	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureCompiler	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def configureCompiler(compiler: Compiler) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def configureProgram(prog: Program) { }$/;"	m
configureProgram	$VIRGIL/aeneas/src/os/Linux.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/ssa/SsaTarget.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def configureProgram(prog: Program) {$/;"	m
configureProgram	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def configureProgram(prog: Program) {$/;"	m
connect	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def connect(nd: SsaBlock) {$/;"	m
connect	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def connect(sockfd: int, sockAddr: Array<byte>) -> NetResult<void> {$/;"	f
connectI	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def connectI(nd: SsaBlock, index: int) {$/;"	m
cons1	$VIRGIL/lib/util/List.v3	/^	def cons1<T>(elem1: T) -> List<T> {$/;"	f
cons2	$VIRGIL/lib/util/List.v3	/^	def cons2<T>(elem1: T, elem2: T) -> List<T> {$/;"	f
cons3	$VIRGIL/lib/util/List.v3	/^	def cons3<T>(elem1: T, elem2: T, elem3: T) -> List<T> {$/;"	f
constraint	$VIRGIL/aeneas/src/types/Type.v3	/^	def constraint: (TypeVarType, Type) -> Type;$/;"	d
constructor	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var constructor: VstNew;$/;"	d
consts	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def consts = Vector<Val>.new();$/;"	d
contBlock	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var contBlock: SsaBuilder;$/;"	d
contEnd	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var contEnd: SsaEnd;$/;"	d
contInstrs	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def contInstrs = call.next;$/;"	d
contains	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def contains(bi: SsaBlockInfo) -> bool {$/;"	m
contains	$VIRGIL/lib/util/Token.v3	/^	def contains(line: int, column: int) -> bool {$/;"	m
containsCallIndirect	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var containsCallIndirect = false;$/;"	d
contents	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def contents = Vector<(Addr, int, int)>.new();$/;"	d
context	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def context: SsaContext;$/;"	d
context	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var context: SsaContext; \/\/ Assign by SsaX86_64Gen$/;"	d
context	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def context = SsaContext.new(ra.compiler, ra.prog);$/;"	d
context	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def context = SsaContext.new(compiler, prog);$/;"	d
context	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def context = SsaContext.new(compiler, prog);$/;"	d
context	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def context: SsaContext;$/;"	d
context	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def context: SsaContext;$/;"	d
context	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def context: SsaContext;		\/\/ compiler, program, method, etc$/;"	d
context	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	var context: SsaContext;$/;"	d
context	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var context: SsaContext;$/;"	d
convert	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def convert(i: SsaConst, t: Type) -> SsaInstr {$/;"	m
convert_d	$VIRGIL/aeneas/src/core/Eval.v3	/^def convert_d(itt: IntType, d: double) -> (Val, \/*saturated*\/bool, \/*rounded*\/bool) {$/;"	f
copy	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def copy() -> ScalarPattern { return ScalarPattern.new(Arrays.dup(bits)); }$/;"	m
copy	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def copy() -> VariantSolution {$/;"	m
copy	$VIRGIL/aeneas/src/main/Error.v3	/^	def copy(that: ErrorGen) {$/;"	m
copy	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def copy() -> SsaBlockState {$/;"	m
copy	$VIRGIL/aeneas/src/types/Type.v3	/^	def copy(ntypes: Array<Type>) -> TypeArgs {$/;"	m
copy	$VIRGIL/lib/util/Arrays.v3	/^	def copy<T>(src: Array<T>, dst: Array<T>) -> Array<T>{$/;"	f
copy	$VIRGIL/lib/util/BitMatrix.v3	/^	def copy(that: BitMatrixRow) {$/;"	m
copy	$VIRGIL/lib/util/DataWriter.v3	/^	def copy() -> Array<byte> {$/;"	m
copy	$VIRGIL/lib/util/Token.v3	/^	def copy(image: string) -> Token {$/;"	m
copy	$VIRGIL/lib/util/Vector.v3	/^	def copy() -> Array<T> {$/;"	m
copyInputs	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def copyInputs(i: SsaInstr, prepend: SsaInstr, start: int) -> Array<SsaInstr> {$/;"	m
copyInto	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def copyInto(d: FpSketch) -> FpSketch {$/;"	m
copyInto	$VIRGIL/lib/util/Arrays.v3	/^	def copyInto<T>(src: Array<T>, dst: Array<T>, destIndex: int) {$/;"	f
copyMap	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def copyMap<T, U>(x: HashMap<T, U>) -> HashMap<T, U> {$/;"	f
copySystemClasses	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def copySystemClasses() {$/;"	m
copyi	$VIRGIL/lib/util/BitMatrix.v3	/^	def copyi(a: int) {$/;"	m
count	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def count(icm: IcMethod) -> int {$/;"	m
count	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var count = 0;$/;"	d
count	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var count: int;			\/\/ number of invocations$/;"	d
count	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def count() -> int {$/;"	m
count	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	private var count: int;$/;"	d
count	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def count(m: IrMethod) -> (IrMethod, int, int) {$/;"	m
count	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	var count: u64;$/;"	d
count	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var count: int;$/;"	d
count	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	var count = 0;$/;"	d
count	$VIRGIL/lib/util/BitMatrix.v3	/^	def count(row: int) -> int {$/;"	m
countDown	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def countDown(limit: int) -> int {$/;"	m
countMarks	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def countMarks() -> u31;$/;"	m
countVals	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def countVals(facts: RaFact.set) -> int {$/;"	f
cover	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def cover(optag: u8, i: SsaInstr) -> SsaApplyOp {$/;"	m
covered	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var covered: Array<MatchPattern>;$/;"	d
cp_index	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var cp_index: int;$/;"	d
cpes	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def cpes    = Vector<JvmCpe>.new();$/;"	d
cpu	$VIRGIL/lib/term/Animator.v3	/^	var cpu: u32;  \/\/ CPU load due to animation; 1000 = 100%$/;"	d
cpusubtype	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var cpusubtype: int;$/;"	d
cputype	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var cputype: int;$/;"	d
cqo	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cqo() -> this { emitbb(REX_BYTE | REX_W, 0x99); }$/;"	m
crc	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var crc: int = -1;$/;"	d
create	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def create(ERROR: ErrorGen) {$/;"	m
create	$VIRGIL/aeneas/src/types/Type.v3	/^	def create(nested: List<Type>) -> Type {$/;"	m
create	$VIRGIL/lib/util/Map.v3	/^	def create: K -> V;$/;"	d
create0	$VIRGIL/aeneas/src/types/Type.v3	/^	def create0() -> Type {$/;"	m
create1	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def create1(t: Type) -> Type {$/;"	m
create1	$VIRGIL/aeneas/src/types/Type.v3	/^	def create1(t: Type) -> Type {$/;"	m
create32	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def create32(w: DataWriter) -> X86_64Assembler {$/;"	f
create64	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def create64(w: DataWriter) -> X86_64Assembler {$/;"	f
createClosureClass	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def createClosureClass(context: SsaContext, numBound: int) -> IrClass {$/;"	m
createClosureMethod	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def createClosureMethod(context: SsaContext, ic: IrClass, op: Operator, abstracter: TypeParamAbstracter, indexMap: Array<int>) -> IrMethod {$/;"	m
createComplexArrayRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def createComplexArrayRecord(r: Record, rt: ArrayNorm) -> Array<Record> {$/;"	m
createGlobalIrClass	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def createGlobalIrClass() -> Type {$/;"	m
createInitialSpec	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def createInitialSpec(rm: RaMethod) {$/;"	m
createIrClass	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def createIrClass(rc: RaClass) {$/;"	m
createIrMethod	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def createIrMethod(receiver: Type, typeArgs: TypeArgs, sig: Signature) -> IrMethod {$/;"	m
createNewIrMethod	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def createNewIrMethod(rm: RaMethod) {$/;"	m
createSpecs	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def createSpecs(rc: RaClass) {$/;"	m
createSsa	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def createSsa(context: SsaContext, receiver: Type, meth: IrMethod) -> SsaBuilder {$/;"	m
createVirtualSpec	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def createVirtualSpec(rc: RaClass, list: List<RaMethod>) {$/;"	m
csp	$VIRGIL/lib/util/StringBuilder.v3	/^	def csp() -> this {$/;"	m
ctype	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def ctype: Type;			\/\/ type corresponding to this class$/;"	d
cur	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var cur = root;$/;"	d
cur	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	var cur: ArchInstr;$/;"	d
curBits	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var curBits: int;$/;"	d
curBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var curBlock: SsaBlock;$/;"	d
curBlock	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var curBlock: SsaBuilder;$/;"	d
curBlock	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	var curBlock: SsaBuilder;$/;"	d
curBlock	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var curBlock: SsaBuilder;$/;"	d
curBlockStart	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var curBlockStart: int;$/;"	d
curByte	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var curByte: byte;$/;"	d
curByte	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	var curByte: byte;			\/\/ current character$/;"	d
curCol	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	var curCol: int;			\/\/ current column$/;"	d
curExtended	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var curExtended: int;$/;"	d
curFrame	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var curFrame: IcFrame;			\/\/ current frame$/;"	d
curFrame	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var curFrame: MachFrame;$/;"	d
curHeight	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var curHeight: int;		\/\/ current stack height$/;"	d
curLine	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	var curLine: int;			\/\/ current line number$/;"	d
curMethod	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var curMethod: VstMethod;$/;"	d
curNode	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var curNode = rootNode;			\/\/ current node$/;"	d
curPoint	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var curPoint: LsraPoint;$/;"	d
curPos	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	var curPos: int;			\/\/ current position$/;"	d
curProf	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var curProf: IcMethodProf;		\/\/ current profiling information$/;"	d
curRep	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var curRep = Vector<Scalar.set>.new();$/;"	d
curRow	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var curRow: BitMatrixRow;$/;"	d
curSlots	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var curSlots: int;$/;"	d
curSoln	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var curSoln: VariantSolution;$/;"	d
curUse	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var curUse: int;$/;"	d
curUsed	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var curUsed = Vector<byte>.new();$/;"	d
curValMoves	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var curValMoves: List<(Val, int)>;$/;"	d
curVreg	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def curVreg = Array<VReg>.new(regSet.physRegs);$/;"	d
curWeight	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var curWeight: int;$/;"	d
cur_pos	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var cur_pos: int;$/;"	d
cur_stack	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var cur_stack: int;$/;"	d
current	$VIRGIL/aeneas/src/util/Progress.v3	/^	var current: string;$/;"	d
cursor	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private var cursor = 1;$/;"	d
cursor	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var cursor: int;$/;"	d
cursor	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var cursor: ArchInstr;$/;"	d
cursor	$VIRGIL/aeneas/src/mach/RegState.v3	/^	var cursor: int; \/\/ point to next free slot in allocated$/;"	d
cursor	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	var cursor: int;$/;"	d
cursor	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private var cursor = 1;$/;"	d
cvt_d2ui	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_d2ui(dest: X86Reg, a: SSERm) {$/;"	m
cvt_f2ui	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_f2ui(dest: X86Reg, a: SSERm) {$/;"	m
cvt_fp2l	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_fp2l(il: X86Rm, ih: X86Rm, a: SSERm, isDouble: bool) {$/;"	m
cvt_fp2ul	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_fp2ul(il: X86Rm, ih: X86Rm, a: SSERm, isDouble: bool) {$/;"	m
cvt_l2fp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_l2fp(dest: SSEReg, a: X86Rm, b: X86Rm, isDouble: bool) {$/;"	m
cvt_ui2d	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_ui2d(dest: SSEReg, a: X86Rm) {$/;"	m
cvt_ui2f	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_ui2f(dest: SSEReg, a: X86Rm) {$/;"	m
cvt_ul2fp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def cvt_ul2fp(dest: SSEReg, a: X86Rm, b: X86Rm, isDouble: bool) {$/;"	m
cvtdq2pd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtdq2pd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtdq2ps_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtdq2ps_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cvtdq2ps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtdq2ps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtpd2ps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtpd2ps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtps2pd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtps2pd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtsd2si	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtsd2si(a: X86Reg, b: SSERm) {$/;"	m
cvtsd2si_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsd2si_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
cvtsd2si_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsd2si_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
cvtsd2ss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtsd2ss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5A, a, b); }$/;"	m
cvtsd2ss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsd2ss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cvtsd2ss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsd2ss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtsi2sd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtsi2sd(a: SSEReg, b: X86Rm) {$/;"	m
cvtsi2sd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsi2sd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cvtsi2sd_s_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsi2sd_s_r(a: X86_64Xmmr, b: X86_64Reg) -> this {$/;"	m
cvtsi2ss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtsi2ss(a: SSEReg, b: X86Rm) {$/;"	m
cvtsi2ss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsi2ss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cvtsi2ss_s_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtsi2ss_s_r(a: X86_64Xmmr, b: X86_64Reg) -> this {$/;"	m
cvtss2sd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtss2sd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5A, a, b); }$/;"	m
cvtss2sd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtss2sd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
cvtss2sd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtss2sd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvtss2si	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvtss2si(a: X86Reg, b: SSERm) {$/;"	m
cvtss2si_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtss2si_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
cvtss2si_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvtss2si_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
cvttpd2dq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttpd2dq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvttps2dq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttps2dq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
cvttsd2si	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvttsd2si(a: X86Reg, b: SSERm) {$/;"	m
cvttsd2si_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttsd2si_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
cvttsd2si_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttsd2si_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
cvttss2si	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def cvttss2si(a: X86Reg, b: SSERm) {$/;"	m
cvttss2si_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttss2si_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
cvttss2si_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def cvttss2si_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
cyan	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def cyan(fmt: string, a: int) {$/;"	m
cyan	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def cyan<T>(fmt: string, a: T) { color(CTRL_CYAN, fmt, a); }$/;"	f
cycles	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var cycles: List<JvmHI_CycleRef>;$/;"	d
cyclicFieldTypeInference	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def cyclicFieldTypeInference(fdecl: VstField) -> Type {$/;"	m
d2f	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def d2f() {$/;"	m
d2i	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def d2i() {$/;"	m
d2i_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def d2i_fixup() {$/;"	m
d2l	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def d2l() {$/;"	m
d2l_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def d2l_fixup() {$/;"	m
d2ui_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def d2ui_fixup() {$/;"	m
d2ul	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def d2ul() {$/;"	m
d2ul_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def d2ul_fixup() {$/;"	m
d_suffix	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var d_suffix: bool;$/;"	d
darwinComponent32	$VIRGIL/aeneas/src/x86/DarwinModule.v3	/^	def darwinComponent32 = Kernel_TypeCon.new(Kernel.DARWIN, Tuple.newType(Lists.cons3(Int.TYPE, Int.TYPE, Int.TYPE)));$/;"	d
darwinComponent64	$VIRGIL/aeneas/src/x86/DarwinModule.v3	/^	def darwinComponent64 = Kernel_TypeCon.new(Kernel.DARWIN, Tuple.newType(Lists.cons2(Long.TYPE, Long.TYPE)));$/;"	d
darwinFileStream	$VIRGIL/rt/x86-64-darwin/System.v3	/^def darwinFileStream(fd: int) -> NativeFileStream {$/;"	f
darwinWrite	$VIRGIL/rt/x86-64-darwin/System.v3	/^def darwinWrite(fd: int, buf: Pointer, len: int) -> int {$/;"	f
data	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def data: AddressSpace;$/;"	d
data	$VIRGIL/aeneas/src/os/Linux.v3	/^	def data = ElfSectionHeader.new();$/;"	d
data	$VIRGIL/lib/util/DataReader.v3	/^	def var data: Range<byte>;		\/\/ array containing data$/;"	d
data	$VIRGIL/lib/util/DataWriter.v3	/^	def var data: Array<byte>;		\/\/ array containing data$/;"	d
data	$VIRGIL/lib/util/TextReader.v3	/^	def data: Array<byte>;			\/\/ array containing data$/;"	d
data1_1	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def data1_1(opcode: u8, rd: ArmReg, op: ArmOperand) {$/;"	m
data2_0	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def data2_0(opcode: u8, rn: ArmReg, op: ArmOperand) {$/;"	m
data2_1	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def data2_1(opcode: u8, rd: ArmReg, rn: ArmReg, op: ArmOperand) {$/;"	m
dataRegion	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def dataRegion    = Region.new("data", data);$/;"	d
data_certificate_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def data_certificate_copy(dst: i32, offset: i32, size: i32);				\/\/ *$/;"	f
data_certificate_present	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def data_certificate_present() -> i32;							\/\/ *$/;"	f
data_certificate_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def data_certificate_size() -> i32;							\/\/ *$/;"	f
dconst	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dconst(val: u64) {$/;"	m
deallocate	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def deallocate = Vector<bool>.new();$/;"	d
debug	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var debug: bool;$/;"	d
debug	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var debug = CLOptions.PRINT_STACKMAP.get();$/;"	d
debug	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def debug(before: bool, len: int) {$/;"	m
debugMach	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def debugMach = CLOptions.PRINT_MACH.val != VstMatcher.None;$/;"	d
debugMach	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def debugMach = CLOptions.PRINT_MACH.val != VstMatcher.None;$/;"	d
debugOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def debugOpt = OptionGroup.new("DEBUGGING", options);$/;"	d
debugPoint	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def debugPoint(kind: string, p: string, off: int, source: Source, slots: int) {$/;"	m
debug_print	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def debug_print(src: i32, size: i32);							\/\/ * s$/;"	f
debugs	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def debugs = sections.debugs;$/;"	d
debugs	$VIRGIL/aeneas/src/os/Linux.v3	/^	def debugs = Array<ElfSectionHeader>.new(DebugSectionCount);$/;"	d
dec	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def dec(a: X86Rm) {$/;"	m
dec_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def dec_m(a: X86_64Addr) -> this {$/;"	m
dec_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def dec_r(a: X86_64Gpr) -> this {$/;"	m
decl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def decl: VstClass;$/;"	d
declType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var declType: Type;$/;"	d
decl_file	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var decl_file: u32;$/;"	d
decl_line	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var decl_line: u32;$/;"	d
declareField	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def declareField(f: IrField, builder: JvmClassfileBuilder, static: bool) {$/;"	m
decodeCond	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def decodeCond(opcode: int) -> X86_64Cond {$/;"	m
decodeRounding	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def decodeRounding(opcode: int) -> X86_64Rounding {$/;"	m
decodeUnicode	$VIRGIL/lib/util/Utf8.v3	/^	def decodeUnicode(str: Array<byte>, start: int, end: int, f: u32 -> void) -> int {$/;"	f
decodeUtf16	$VIRGIL/lib/util/Utf8.v3	/^	def decodeUtf16(str: Array<byte>, start: int, end: int) -> (Array<u16>, int) {$/;"	f
decrementDegree	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def decrementDegree(n: int) {$/;"	m
deepEqual	$VIRGIL/aeneas/src/core/Value.v3	/^	def deepEqual(vals1: Array<Val>, vals2: Array<Val>) -> bool {$/;"	f
deepEqualBottom	$VIRGIL/aeneas/src/core/Value.v3	/^	def deepEqualBottom(vals: Array<Val>) -> bool {$/;"	f
defEnd	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var defEnd: int;$/;"	d
defStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def defStack = Vector<int>.new();$/;"	d
defStart	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def defStart: int;$/;"	d
default	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def default() -> SsaCfEdge { return succs[succs.length - 1]; }$/;"	m
default	$VIRGIL/aeneas/src/types/Type.v3	/^	def default: Type; \/\/ default type to use if variable has no solution$/;"	d
default	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var default: MatchCase;$/;"	d
defaultGetBitWidth	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def defaultGetBitWidth(compiler: Compiler, prog: Program, t: Type) -> byte {$/;"	f
defaultGetScalar	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def defaultGetScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	f
defaultRecord	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	var defaultRecord: Record;$/;"	d
defcase	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var defcase: MatchCase;$/;"	d
deferRecord	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def deferRecord(r: Record) {$/;"	m
deferValue	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def deferValue(val: Val) {$/;"	m
defineConst	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def defineConst(next: ArchInstr) {$/;"	m
definePhis	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def definePhis(phi: SsaPhi) -> List<(SsaPhi, int)> {$/;"	m
defineReturnValues	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def defineReturnValues(block: SsaBlock, i: SsaApplyOp, retLocs: Array<int>) {$/;"	m
defs	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def defs = Vector<(ArchInstr, Operand.Def, bool)>.new();$/;"	d
deleteAt	$VIRGIL/lib/util/Arrays.v3	/^	def deleteAt<T>(array: Array<T>, index: int) -> Array<T> {$/;"	f
deleteVar	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def deleteVar(n: int, pos: int) {$/;"	m
depth	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var depth: int;$/;"	d
depth	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var depth: int;  \/\/ loop depth$/;"	d
depth	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	var depth: int;$/;"	d
depth	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	var depth = -1;			\/\/ depth from root, to speed up commonSuperClass()$/;"	d
desc	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	var desc: string;$/;"	d
description	$VIRGIL/aeneas/src/main/Error.v3	/^	def var description: string;$/;"	d
descriptor	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def descriptor() -> string {$/;"	m
dest	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var dest: SsaBlock;$/;"	d
dest	$VIRGIL/lib/util/Edge.v3	/^	var dest: T;		\/\/ the destination of this edge$/;"	d
desti	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var desti: int;$/;"	d
devirtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var devirtual: RaMethod;	\/\/ RA-devirtualized target, if any$/;"	d
devirtualize	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def devirtualize(m: IrSpec, x: SsaInstr) -> IrSpec {$/;"	m
dfn	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfn(i: SsaInstr) {$/;"	m
dfn	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def dfn(a: VReg) -> int {$/;"	m
dfnAll	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfnAll(i: SsaInstr) {$/;"	m
dfnAt	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def dfnAt(v: VReg, fixed: int) -> int {$/;"	m
dfnFixed	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfnFixed(i: SsaInstr, constraint: int) {$/;"	m
dfnReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfnReg(i: SsaInstr) {$/;"	m
dfngpr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def dfngpr(a: VReg) -> int {$/;"	m
dfnsse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def dfnsse(a: VReg) -> int {$/;"	m
dfnv	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfnv(vreg: VReg, constraint: int) {$/;"	m
dfnv0	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dfnv0(vreg: VReg) {$/;"	m
digits	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var digits: byte;$/;"	d
digits	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def digits: int;$/;"	d
dirCount	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var dirCount: u32 = 1;$/;"	d
dirFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def dirFile = DwarfDirFile.new(prog);$/;"	d
dirIdx	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def dirIdx: u32;$/;"	d
dirOrder	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def dirOrder = Vector<DwarfDir>.new();$/;"	d
directCallBlocks	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var directCallBlocks: List<SsaBlock>;$/;"	d
directCallTargets	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var directCallTargets: List<IrSpec>;$/;"	d
directCalls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def directCalls = Vector<IrSpec>.new();$/;"	d
directory	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def directory: string;$/;"	d
dirs	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var dirs = HashMap<string, DwarfDir>.new(Strings.hash, Strings.equal);$/;"	d
dirty	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var dirty: Array<bool>;			\/\/ which outgoing call edges are dirty$/;"	d
dirtyAll	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def dirtyAll() {$/;"	m
dirtyIncomingEdges	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def dirtyIncomingEdges(dst: SpecMethod) {$/;"	m
disable	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def disable() { ssa.breakpoint = false; }$/;"	m
disconnect	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def disconnect() {$/;"	m
discriminator	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def discriminator: u32;$/;"	d
div	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def div(di: FpSketch, qmin: u31) -> bool {$/;"	m
div	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def div(rs: MipsReg, rt: MipsReg)               { emit_r2i(0x00000000, rs, rt, 0x1a); }$/;"	m
div	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def div(b: X86Rm) { emitb_rm(0xF7, b, 6); } \/\/ unsigned divide (output in edx:eax)$/;"	m
divDigit	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def divDigit(v: int, mod: int, z: bool) {$/;"	m
divPow10	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def divPow10(exp: u32, qmin: u31) -> bool {$/;"	m
divU32	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def divU32(d: u32, qmin: u31) -> bool {$/;"	m
div_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def div_m(b: X86_64Addr) -> this {$/;"	m
div_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def div_r(b: X86_64Gpr) -> this {$/;"	m
divest	$VIRGIL/lib/util/DataReader.v3	/^	def divest(expecting: int, alias: Range<byte>) -> this {$/;"	m
divpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
divps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
divsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def divsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5E, a, b); }$/;"	m
divsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
divsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
divss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def divss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5E, a, b); }$/;"	m
divss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
divss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def divss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
divu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def divu(rs: MipsReg, rt: MipsReg)              { emit_r2i(0x00000000, rs, rt, 0x1b); }$/;"	m
do0	$VIRGIL/lib/term/Vt100.v3	/^	def do0() {$/;"	m
do1	$VIRGIL/lib/term/Vt100.v3	/^	def do1(i: int) {$/;"	m
do2	$VIRGIL/lib/term/Vt100.v3	/^	def do2(i: int) {$/;"	m
do3	$VIRGIL/lib/term/Vt100.v3	/^	def do3(i: int) {$/;"	m
doBlock	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def doBlock(block: SsaBlock) {$/;"	m
doCast	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doCast(cast: TypeCast, ft: Type, tt: Type, val: Val) -> (bool, Val) {$/;"	f
doCast0	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doCast0(ft: Type, tt: Type, val: Val) -> (bool, Val) {$/;"	f
doGoto	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def doGoto(target: SsaCfEdge) -> SsaInstr {$/;"	m
doIc	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def doIc(icm: IcMethod) {$/;"	m
doIndent	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def doIndent(b: StringBuilder) -> StringBuilder {$/;"	m
doIntPromote	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntPromote(t1: Type, t2: Type, val: Val) -> Val {$/;"	f
doIntQuery	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntQuery(ift: IntType, itt: IntType, v: Val) -> bool {$/;"	f
doIntTrunc32	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntTrunc32(t: IntType, v: int) -> int {$/;"	f
doIntTrunc64	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntTrunc64(t: IntType, v: long) -> long {$/;"	f
doIntTruncU32	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntTruncU32(t: IntType, v: int) -> int {$/;"	f
doIntTruncU64	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntTruncU64(t: IntType, v: long) -> long {$/;"	f
doIntView	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doIntView(t1: IntType, t2: IntType, val: Val) -> Val {$/;"	f
doMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def doMethod(method: IrMethod) {$/;"	m
doOp	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doOp = evalOp; \/\/ expose top-level function from below$/;"	d
doOp	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def doOp(i: SsaApplyOp) -> SsaInstr {$/;"	m
doParallelMove	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def doParallelMove(i: ArchInstr, next: ArchInstr) {$/;"	m
doQuery	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doQuery(query: TypeQuery, ft: Type, tt: Type, val: Val) -> bool {$/;"	f
doQuery0	$VIRGIL/aeneas/src/core/Eval.v3	/^	def doQuery0(ft: Type, tt: Type, val: Val) -> bool {$/;"	f
doRefLayoutGetField	$VIRGIL/aeneas/src/core/Eval.v3	/^def doRefLayoutGetField(args: Arguments, fieldType: Type, ref: ByteArrayOffset, offset: int) -> Result {$/;"	f
doRefLayoutSetField	$VIRGIL/aeneas/src/core/Eval.v3	/^def doRefLayoutSetField(args: Arguments, fieldType: Type, ref: ByteArrayOffset, offset: int, val: Val) -> Result {$/;"	f
doShift	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def doShift(i_old: SsaApplyOp, op: Operator, tt: IntType) {$/;"	m
doSimpleShift	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def doSimpleShift(i_old: SsaApplyOp, op: Operator, tt: IntType) {$/;"	m
doSplit	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	private def doSplit(start: SsaBlock, last: SsaLink, end: SsaLink) {$/;"	m
doSsa	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def doSsa(m: IrMethod) {$/;"	m
do_d_d	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_d_d(func: double -> double) -> Val {$/;"	m
do_dd_d	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_dd_d(func: (double, double) -> double) -> Val {$/;"	m
do_dd_z	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_dd_z(func: (double, double) -> bool) -> Val {$/;"	m
do_f_f	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_f_f(func: float -> float) -> Val {$/;"	m
do_ff_f	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_ff_f(func: (float, float) -> float) -> Val {$/;"	m
do_ff_z	$VIRGIL/aeneas/src/core/Eval.v3	/^	def do_ff_z(func: (float, float) -> bool) -> Val {$/;"	m
dohash	$VIRGIL/lib/util/Map.v3	/^	private def dohash(key: K) -> int {$/;"	m
dom_child	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var dom_child: SsaBlockInfo;	\/\/ first child in dominator tree$/;"	d
dom_depth	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var dom_depth: int;		\/\/ depth in dominator tree$/;"	d
dom_max	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var dom_max: int;		\/\/ dominator interval end in sRPO$/;"	d
dom_parent	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var dom_parent: SsaBlockInfo;	\/\/ immediate dominator (parent in dom tree)$/;"	d
dom_sibling	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var dom_sibling: SsaBlockInfo;	\/\/ next sibling in dominator tree$/;"	d
done	$VIRGIL/lib/util/DataReader.v3	/^	def done() -> bool {$/;"	m
drain	$VIRGIL/lib/util/Vector.v3	/^	def drain<T>(vec: Vector<T>, pos: int, f: T -> void) -> int {$/;"	f
drain	$VIRGIL/lib/util/WorkQueue.v3	/^	def drain() {$/;"	m
drawBox	$VIRGIL/lib/term/Vt100.v3	/^	def drawBox(x: int, y: int, innerWidth: int, innerHeight: int) {$/;"	f
dstList	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var dstList: MoveNode;	\/\/ head of destination list$/;"	d
dstNext	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var dstNext: MoveNode;	\/\/ next in a list of successors$/;"	d
dump	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dump() {$/;"	m
dumpFacts	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dumpFacts(facts: RaFact.set, virtual: RaVirtual, val: Val, recursive: bool) {$/;"	m
dumpField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dumpField(receiver: Type, rf: RaField) {$/;"	m
dumpMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dumpMethod(rm: RaMethod) {$/;"	m
dumpRecord	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dumpRecord(r: Record, x: Record) {$/;"	m
dumpState	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def dumpState(str: string) {$/;"	m
dumpType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def dumpType(rt: RaType) {$/;"	m
dup	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dup() {$/;"	m
dup	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def dup() -> SsaProbe { return SsaProbe.new(); }$/;"	m
dup	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def dup() -> SsaProbe {$/;"	m
dup	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def dup() -> SsaTreeProfilerRetProbe {$/;"	m
dup	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	def dup() -> SsaCallRetProbe {$/;"	m
dup	$VIRGIL/lib/util/Arrays.v3	/^	def dup<T>(src: Array<T>) -> Array<T>{$/;"	f
dup	$VIRGIL/lib/util/Ranges.v3	/^	def dup<T>(r: Range<T>) -> Array<T> {$/;"	f
dup2	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dup2() {$/;"	m
dupK	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dupK(kind: JvmKind) {$/;"	m
dupVReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def dupVReg(vreg: VReg) -> VReg {$/;"	m
dup_x1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dup_x1() {$/;"	m
dup_x2	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def dup_x2() {$/;"	m
dwarf	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def dwarf: Dwarf;$/;"	d
dwarf	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def dwarf: Dwarf;$/;"	d
e_entry	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var e_entry: long;$/;"	d
e_flags	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var e_flags: int;$/;"	d
e_machine	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var e_machine: int;$/;"	d
e_phoff	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def e_phoff() -> long {$/;"	m
e_shoff	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def e_shoff() -> long {$/;"	m
e_shstrndx	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var e_shstrndx: int;$/;"	d
eat1	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def eat1() -> this {$/;"	m
eatEnd	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def eatEnd(p: ParserState, start: FilePoint) -> FileRange {$/;"	f
eax	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def eax = X86Regs.EAX;$/;"	d
ebp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def ebp = X86Regs.EBP;$/;"	d
ebx	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def ebx = X86Regs.EBX;$/;"	d
ecx	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def ecx = X86Regs.ECX;$/;"	d
edesc	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def edesc: string;$/;"	d
edgeMapMap	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var edgeMapMap: PartialMap<SsaBlock, Array<int>>;$/;"	d
edi	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def edi = X86Regs.EDI;$/;"	d
edx	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def edx = X86Regs.EDX;$/;"	d
effectiveType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def effectiveType() -> Type { return if(implicitType != null, implicitType, exactType); }$/;"	m
eip	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	var eip: int;$/;"	d
elem	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def elem: RaType;$/;"	d
elem	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def elem: (WasmPacking, WasmType);$/;"	d
elemScale	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var elemScale: int;$/;"	d
elemTypes	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var elemTypes: Array<Type>; $/;"	d
elementType	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def elementType: JvmType;$/;"	d
elementType	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def elementType(t: Type, index: int) -> Type {$/;"	f
elementType	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	def elementType(atype: Type) -> Type {$/;"	f
elementType	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def elementType() -> Type {$/;"	m
elements	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var elements: int;$/;"	d
elems	$VIRGIL/lib/util/Stack.v3	/^	def var elems = Array<T>.new(10);$/;"	d
elf	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def elf: ElfHeader;$/;"	d
elf_machine	$VIRGIL/aeneas/src/os/Linux.v3	/^	def elf_machine: int;$/;"	d
elim	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def elim(vtype: Type) -> Type {$/;"	m
elimError	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var elimError: TypeVarEliminator;$/;"	d
elimTypeVars	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def elimTypeVars(t: Type) -> Type {$/;"	f
elimTypeVars	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^def elimTypeVars = VstIr.elimTypeVars;$/;"	d
elimTypeVars	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def elimTypeVars(t: Type) -> Type {$/;"	f
eliminateStoreNarrow	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def eliminateStoreNarrow(tt: IntType, v: SsaInstr) -> SsaInstr {$/;"	m
emit	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def emit();$/;"	m
emit	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emit(w: DataWriter, getTypeRef: (Type, int) -> int, codeStart: long);$/;"	m
emit	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def emit(w: DataWriter) {$/;"	m
emit	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def emit(w: DataWriter);$/;"	m
emit	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def emit() {$/;"	m
emit	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emit() {$/;"	m
emit	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emit() {$/;"	m
emit	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def emit(codegen: SsaMachGen, next: ArchInstr) {$/;"	m
emit	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def emit(codegen: SsaMachGen, next: ArchInstr) {$/;"	m
emit	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emit();$/;"	m
emit	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def emit(compiler: Compiler, prog: Program) { }$/;"	m
emit	$VIRGIL/aeneas/src/os/Linux.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/ssa/SsaTarget.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def emit(i: CfgInstr) {$/;"	m
emit	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def emit(out: DataWriter) {$/;"	m
emit	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emit() { emitFunc(params); }$/;"	m
emit	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def emit(compiler: Compiler, prog: Program) {$/;"	m
emit	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def emit(val: int) {$/;"	m
emit	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def emit(val: int) {$/;"	m
emit0	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def emit0(codegen: SsaMachGen, j: int, next: ArchInstr) {$/;"	m
emit0	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def emit0(codegen: SsaMachGen, j: int, next: ArchInstr) {$/;"	m
emit0	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emit0(opcode: int) {$/;"	m
emit1	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emit1(opcode: int, a: void) {$/;"	m
emit2	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emit2(opcode: int, a: void, b: void) {$/;"	m
emit3	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emit3(opcode: int, a: void, b: void, c: void) {$/;"	m
emitAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitAbbrev(w: DataWriter, name: u32, form: u32) {$/;"	m
emitAddr	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitAddr(addr: Addr) {$/;"	m
emitAllocationStub	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitAllocationStub() {$/;"	m
emitApply	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitApply(i: SsaApplyOp, op: Operator, leave: bool) -> bool {$/;"	m
emitArrayAlloc	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitArrayAlloc(arrayType: Type, code: JvmCodeBuilder) {$/;"	m
emitArrayGetElem	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitArrayGetElem(arrayType: Type, code: JvmCodeBuilder) {$/;"	m
emitArrayGetLength	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitArrayGetLength(arrayType: Type, code: JvmCodeBuilder) {$/;"	m
emitArrayInit	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitArrayInit(op: Operator, len: int) {$/;"	m
emitArraySetElem	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitArraySetElem(arrayType: Type, code: JvmCodeBuilder, asVal: bool) {$/;"	m
emitArrayType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitArrayType(t: ArrayType) {$/;"	m
emitBaseType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitBaseType(t: Type, byteSize: int, encoding: int) {$/;"	m
emitBashScriptHeader	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def emitBashScriptHeader(fd: int) {$/;"	m
emitBinop	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitBinop(i: SsaApplyOp, op: WasmOp) {$/;"	m
emitBlock	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitBlock(b: SsaJvmBlock) {$/;"	m
emitBody	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def emitBody(bi: SsaBlockInfo) {$/;"	m
emitBranch	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitBranch(opcode: byte, bi: SsaJvmBlock) {$/;"	m
emitBranchIf	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitBranchIf(opTrue: byte, tb: SsaBlock, fb: SsaBlock) {$/;"	m
emitCall	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitCall(i: SsaApplyOp, methodRef: IrSpec) {$/;"	m
emitCall	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitCall(call: SsaApplyOp, funcRep: Mach_FuncRep) {$/;"	m
emitCallKernel	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitCallKernel(call: SsaApplyOp, kernel: Kernel) {$/;"	m
emitCentralDir	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def emitCentralDir() {$/;"	m
emitCentralDirEntry	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def emitCentralDirEntry(fname: string, offset: int, size: int, crc: int) {$/;"	m
emitChildren	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitChildren(w: DataWriter, getTypeRef: (Type, int) -> int, codeStart: long, children: Vector<DwarfDie>) {$/;"	m
emitClassType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitClassType(t: ClassType) {$/;"	m
emitCmp	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def emitCmp(edge: SsaDfEdge) -> ArmCond {$/;"	m
emitCmp	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitCmp(i: SsaInstr, inblock: bool) -> X86_64CondPair {$/;"	m
emitCmpBinop	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitCmpBinop(opcode: int, i: SsaApplyOp, cond: X86_64Cond) -> X86_64CondPair {$/;"	m
emitCode	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitCode(block: SsaBlock, sji: SsaJvmInstr) {$/;"	m
emitCompareBranch	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitCompareBranch(block: SsaBlock, b: SsaJvmCompareBranch) {$/;"	m
emitCondJump	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitCondJump(cond: X86_64Cond, target: SsaBlock) {$/;"	m
emitDefaultCmp	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitDefaultCmp(i: SsaInstr) -> X86_64CondPair {$/;"	m
emitDefaultVariantRecord	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitDefaultVariantRecord(t: Type, code: JvmCodeBuilder) {$/;"	m
emitDoubleMathCall	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitDoubleMathCall(isDouble: bool, name: string) {$/;"	m
emitEnd	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitEnd(block: SsaBlock, sji: SsaJvmInstr) {$/;"	m
emitEngineScript	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^        def emitEngineScript(cmd: string, compiler: Compiler, prog: Program) {$/;"	m
emitEntryStub	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitEntryStub() {$/;"	m
emitEnumType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitEnumType(t: EnumType) {$/;"	m
emitEq	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitEq(i: SsaApplyOp) {$/;"	m
emitExplicitArraySizeCheck	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitExplicitArraySizeCheck(code: JvmCodeBuilder) {$/;"	m
emitExplicitBoundsCheck	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitExplicitBoundsCheck(arrayType: Type, code: JvmCodeBuilder) {$/;"	m
emitField	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitField(t: VstMember) {$/;"	m
emitFloatAbs	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatAbs(isDouble: bool) {$/;"	m
emitFloatBinop	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatBinop(isDouble: bool, fop: byte, dop: byte) {$/;"	m
emitFloatBinop	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitFloatBinop(i: SsaApplyOp, isDouble: bool, op32: WasmOp, op64: WasmOp) {$/;"	m
emitFloatBinop	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitFloatBinop(i: SsaApplyOp, opcode: int) {$/;"	m
emitFloatBitEq	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitFloatBitEq(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatCastD	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatCastD(i: SsaApplyOp) {$/;"	m
emitFloatCastI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatCastI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatCmp	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatCmp(isDouble: bool, fop: byte, dop: byte, ifop: byte) {$/;"	m
emitFloatCmp	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitFloatCmp(is64: bool, i: SsaApplyOp, cond: X86_64Cond, reflex: X86_64Cond) -> X86_64CondPair {$/;"	m
emitFloatPromoteI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatPromoteI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatPromoteI	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitFloatPromoteI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatQueryD	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatQueryD(i: SsaApplyOp) {$/;"	m
emitFloatQueryI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatQueryI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatRound	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatRound(isDouble: bool) {$/;"	m
emitFloatRoundI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatRoundI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatRoundI	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitFloatRoundI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFloatRoundI	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitFloatRoundI(i: SsaApplyOp, is64: bool) {$/;"	m
emitFloatUnop	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitFloatUnop(i: SsaApplyOp, isDouble: bool, op32: WasmOp, op64: WasmOp) {$/;"	m
emitFloatValue	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def emitFloatValue(code: JvmCodeBuilder, ft: FloatType, val: Val) {$/;"	m
emitFloatViewI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitFloatViewI(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitFunc	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emitFunc: T -> void;$/;"	d
emitFunctionConversion	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitFunctionConversion(code: JvmCodeBuilder, exactType: Type, implicitType: Type) {$/;"	m
emitFunctionValue	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitFunctionValue(code: JvmCodeBuilder, etype: Type, fval: FuncVal) {$/;"	m
emitGetField	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitGetField(memberRef: IrSpec, code: JvmCodeBuilder) {$/;"	m
emitGotoOrFallThru	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitGotoOrFallThru(block: SsaBlock) {$/;"	m
emitHeader	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitHeader() -> int {$/;"	m
emitIndirectAdapter	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIndirectAdapter(sig: Signature, index: u32, m: IrMethod) {$/;"	m
emitInit	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitInit(heap: JvmHeap, code: JvmCodeBuilder);$/;"	m
emitInstrs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emitInstrs() {$/;"	m
emitInt	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitInt(o: Operand) {$/;"	m
emitIntBinop	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntBinop(i: SsaApplyOp, iop: byte, lop: byte, trunc: bool) {$/;"	m
emitIntBinop	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIntBinop(i: SsaApplyOp, op32: WasmOp, op64: WasmOp) {$/;"	m
emitIntBinop	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitIntBinop(opcode: int, i: SsaApplyOp) {$/;"	m
emitIntBinopSU	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIntBinopSU(i: SsaApplyOp, op32s: WasmOp, op32u: WasmOp, op64s: WasmOp, op64u: WasmOp) {$/;"	m
emitIntCastF	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntCastF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntCastF	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIntCastF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntCmp	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntCmp(i: SsaApplyOp, iop: byte, lop: byte, isysMethName: string, lsysMethName: string) {$/;"	m
emitIntConvertF	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitIntConvertF(i: SsaApplyOp, is64: bool) {$/;"	m
emitIntDiv	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntDiv(i: SsaApplyOp) {$/;"	m
emitIntDivMod	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitIntDivMod(i: SsaApplyOp, isMod: bool) {$/;"	m
emitIntQueryF	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntQueryF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntTrunc	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntTrunc(tt: IntType) {$/;"	m
emitIntTruncF	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntTruncF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntTruncF	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIntTruncF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntValue	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def emitIntValue(code: JvmCodeBuilder, tt: IntType, val: Val) {$/;"	m
emitIntViewF	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntViewF(i: SsaApplyOp, isDouble: bool) {$/;"	m
emitIntViewI	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitIntViewI(i: SsaApplyOp) {$/;"	m
emitIntViewI	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitIntViewI(i: SsaApplyOp) {$/;"	m
emitIntViewI	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitIntViewI(i: SsaApplyOp) {$/;"	m
emitInvokeVirtual	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitInvokeVirtual(code: JvmCodeBuilder, spec: IrSpec, nonnull: bool) {$/;"	m
emitJoinBlocks	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def emitJoinBlocks(list: List<SsaBlockInfo>) {$/;"	m
emitJoinEnds	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def emitJoinEnds(list: List<SsaBlockInfo>, context: CfgContext) {$/;"	m
emitJvmClassfile	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def emitJvmClassfile(jvmClass: JvmClassfile) {$/;"	m
emitJvmTypeConversion	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitJvmTypeConversion(code: JvmCodeBuilder, exactType: Type, implicitType: Type) {$/;"	m
emitLine	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitLine(lineDelta: int, lastLabel: Label, label: Label) {$/;"	m
emitLineAddr	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitLineAddr(lineDelta: int, addrDelta: u32) {$/;"	m
emitLineStr	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitLineStr() {$/;"	m
emitLines	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitLines() {$/;"	m
emitLoad	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitLoad(i: SsaInstr) {$/;"	m
emitLoadArguments	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def emitLoadArguments(code: JvmCodeBuilder, exactType: Type, implicitType: Type, base: int) {$/;"	m
emitLoads	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitLoads(loads: List<SsaInstr>) {$/;"	m
emitLocalFileHeader	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def emitLocalFileHeader(name: string, len: int, crc: int) {$/;"	m
emitMethodName	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def emitMethodName(w: MachDataWriter, m: IrMethod, namebuf: StringBuilder) {$/;"	m
emitMovd	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitMovd(i: SsaApplyOp) {$/;"	m
emitMoveIR	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitMoveIR(t: Type, from: SsaInstr, to: int) {$/;"	m
emitMoveRR	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitMoveRR(t: Type, from: int, to: int) {$/;"	m
emitMoves	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emitMoves(mr: MoveResolver) {$/;"	m
emitN	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emitN(opcode: int) {$/;"	m
emitParMoves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def emitParMoves(cur: ArchInstr, next: ArchInstr) {$/;"	m
emitPhiResolutionMoves	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def emitPhiResolutionMoves(block: SsaBlock, edge: SsaCfEdge) {$/;"	m
emitRecordValue	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitRecordValue(code: JvmCodeBuilder, rval: Record) {$/;"	m
emitRef	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitRef(heap: JvmHeap, code: JvmCodeBuilder) {$/;"	m
emitRefLoad	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitRefLoad(offset: int) {$/;"	m
emitRefStore	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitRefStore(offset: int) {$/;"	m
emitSetC	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitSetC(dreg: VReg, conds: X86_64CondPair) {$/;"	m
emitSetField	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitSetField(memberRef: IrSpec, code: JvmCodeBuilder, asVal: bool) {$/;"	m
emitSetLineAddr	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitSetLineAddr(lineDelta: int, label: Label) {$/;"	m
emitShift	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitShift(i: SsaApplyOp, op: Operator) {$/;"	m
emitShift	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitShift(i: SsaApplyOp, op32: WasmOp, op64: WasmOp) {$/;"	m
emitShift	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitShift(i: SsaApplyOp, opcode: int) {$/;"	m
emitShiftShift	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitShiftShift(i: SsaApplyOp, op1: int, op2: int, width: int) {$/;"	m
emitShiftShiftI	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitShiftShiftI(i: SsaApplyOp, op1: WasmOp, op2: WasmOp, width: int) {$/;"	m
emitShiftShiftL	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitShiftShiftL(i: SsaApplyOp, op1: WasmOp, op2: WasmOp, width: int) {$/;"	m
emitSimpleBinop	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def emitSimpleBinop(opcode: int, i: SsaApplyOp, unused: int) {$/;"	m
emitSingletonField	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def emitSingletonField() {$/;"	m
emitSwitch	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitSwitch(block: SsaBlock, sw: SsaSwitch) {$/;"	m
emitTestWrappers	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def emitTestWrappers(context: SsaContext, rt: MachRuntime, w: DataWriter, e: ExecuteTestCase) {$/;"	m
emitThrow	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitThrow(code: JvmCodeBuilder, jclass: JvmClass) {$/;"	m
emitThrow	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitThrow(ex: string) {$/;"	m
emitTupleConversion	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def emitTupleConversion(code: JvmCodeBuilder, exactType: Type, implicitType: Type) {$/;"	m
emitTupleCreate	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitTupleCreate(t: Type, code: JvmCodeBuilder) {$/;"	m
emitTupleGetElem	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def emitTupleGetElem(t: Type, index: int, code: JvmCodeBuilder) {$/;"	m
emitType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitType(t: Type, v: int) {$/;"	m
emitTypeCast	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitTypeCast(t1: Type, t2: Type) {$/;"	m
emitTypeQuery	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def emitTypeQuery(t1: Type, t2: Type) {$/;"	m
emitUnspecifiedType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def emitUnspecifiedType(t: Type) {$/;"	m
emitValMoves	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emitValMoves(list: List<(Val, int)>) {$/;"	m
emitValue	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def emitValue(code: JvmCodeBuilder, etype: Type, val: Val) -> int {$/;"	m
emitVarDecls	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitVarDecls(w: MachDataWriter) {$/;"	m
emitVarMoves	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def emitVarMoves(list: List<(int, int)>) {$/;"	m
emitWasm	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def emitWasm(m: IrMethod, funcNum: int) {$/;"	m
emitWasmModule	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def emitWasmModule(context: SsaContext, rt: MachRuntime) -> DataWriter {$/;"	m
emit_b_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_b_type(opcode: u7, f3: u2, rs1: RiscV64Gpr, rs2: RiscV64Gpr, imm: i13) {$/;"	m
emit_i_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_i_type(opcode: u7, rd: RiscV64Gpr, f3: u2, rs1: RiscV64Gpr, imm: u12) {$/;"	m
emit_item	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def emit_item(item: JvmClassItem) {$/;"	m
emit_j_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_j_type(opcode: u7, rd: RiscV64Gpr, imm: i21) {$/;"	m
emit_m	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emit_m(base: X86Reg, index: X86Reg, scale: byte, disp: int, eop: int) {$/;"	m
emit_r1	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def emit_r1(opcode: int, rs: MipsReg, imm: u16) {$/;"	m
emit_r2i	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def emit_r2i(opcode: int, rd: MipsReg, rs: MipsReg, imm: u16) {$/;"	m
emit_r3	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def emit_r3(opcode: int, rd: MipsReg, rs: MipsReg, rt: MipsReg) {$/;"	m
emit_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def emit_r_i(rd: Arm64Reg, imm: u16, code: u9) {$/;"	m
emit_r_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def emit_r_r_i_i(rd: Arm64Reg, rn: Arm64Reg, imm: u12, lsl12: u1, code: u9) {$/;"	m
emit_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def emit_r_r_r_ex_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: DataRegExtend,$/;"	m
emit_r_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def emit_r_r_r_sh_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, $/;"	m
emit_r_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_r_type(opcode: u7, rd: RiscV64Gpr, f3: u2, rs1: RiscV64Gpr, rs2: RiscV64Gpr, f7: u7) {$/;"	m
emit_rex_b_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_m_r(a: X86_64Addr, b: X86_64Reg, rex: byte, code: byte) {$/;"	m
emit_rex_b_m_x	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_m_x(a: X86_64Addr, rex: byte, code: byte, ext: byte) {$/;"	m
emit_rex_b_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_r(a: X86_64Reg, rex: byte, code: byte) {$/;"	m
emit_rex_b_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_r_m(a: X86_64Reg, b: X86_64Addr, rex: byte, code: byte) {$/;"	m
emit_rex_b_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_r_r(a: X86_64Reg, b: X86_64Reg, rex: byte, code: byte) {$/;"	m
emit_rex_b_r_x	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_b_r_x(a: X86_64Reg, rex: byte, code: byte, ext: byte) {$/;"	m
emit_rex_bb_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bb_r(a: X86_64Reg, rex: byte, c1: byte, c2: byte, low3: u3) {$/;"	m
emit_rex_bb_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bb_r_m(a: X86_64Reg, b: X86_64Addr, rex: byte, c1: byte, c2: byte) {$/;"	m
emit_rex_bb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bb_r_r(a: X86_64Reg, b: X86_64Reg, rex: byte, c1: byte, c2: byte) {$/;"	m
emit_rex_bbb_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bbb_m_r(a: X86_64Addr, b: X86_64Reg, rex: byte, c1: byte, c2: byte, c3: byte) {$/;"	m
emit_rex_bbb_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bbb_r_m(a: X86_64Reg, b: X86_64Addr, rex: byte, c1: byte, c2: byte, c3: byte) {$/;"	m
emit_rex_bbb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bbb_r_r(a: X86_64Reg, b: X86_64Reg, rex: byte, c1: byte, c2: byte, c3: byte) {$/;"	m
emit_rex_bbb_r_r2	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emit_rex_bbb_r_r2(a: X86_64Reg, b: X86_64Reg, rex: byte, c1: byte, c2: byte, c3: byte) {$/;"	m
emit_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emit_rm(a: X86Rm, eop: int) {$/;"	m
emit_rm_1	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	private def emit_rm_1(eop: int, regnum: int, disp: int) {$/;"	m
emit_rrr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	private def emit_rrr(opcode: u32, rd: ArmReg, rs: ArmReg, rm: ArmReg) {$/;"	m
emit_s_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_s_type(opcode: u7, rd: RiscV64Gpr, rs1: RiscV64Gpr, rs2: RiscV64Gpr, imm: u12) {$/;"	m
emit_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emit_sm(a: SSERm, eop: int) {$/;"	m
emit_u_type	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def emit_u_type(opcode: u7, rd: RiscV64Gpr, imm: u20) {$/;"	m
emitb	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitb(b0: int) {$/;"	m
emitb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitb(b0: int) {$/;"	m
emitb_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitb_m(b0: int, a: X86_64Addr, eop: int) {$/;"	m
emitb_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitb_r(b0: int, a: X86_64Reg, eop: int) {$/;"	m
emitb_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitb_rm(b0: int, a: X86Rm, eop: int) {$/;"	m
emitbb	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitbb(b0: int, b1: int) {$/;"	m
emitbb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbb(b0: int, b1: int) {$/;"	m
emitbb_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitbb_m(b0: int, b1: int, a: X86_64Addr, eop: int) {$/;"	m
emitbb_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitbb_r(b0: int, b1: int, a: X86_64Reg, eop: int) {$/;"	m
emitbb_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbb_rm(b0: int, b1: int, a: X86Rm, eop: int) {$/;"	m
emitbb_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbb_s_sm(b1: byte, b2: byte, a: SSEReg, b: SSERm) {$/;"	m
emitbbb	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitbbb(b0: int, b1: int, b2: int) {$/;"	m
emitbbb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbbb(b0: int, b1: int, b2: int) {$/;"	m
emitbbb_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbbb_s_sm(b1: byte, b2: byte, b3: byte, a: SSEReg, b: SSERm) {$/;"	m
emitbbb_si_b	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbbb_si_b(b1: byte, b2: byte, b3: byte, a: SSEReg, b: int, c: byte) {$/;"	m
emitbbbb_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbbbb_s_sm(b1: byte, b2: byte, b3: byte, b4: byte,$/;"	m
emitbbd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitbbd(b0: int, b1: int, d0: int) {$/;"	m
emitbbd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbbd(b0: int, b1: int, d0: int) {$/;"	m
emitbd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitbd(b0: int, d0: int) {$/;"	m
emitbd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitbd(b0: int, d0: int) {$/;"	m
emitd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitd(d0: int) {$/;"	m
emitd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def emitd(d0: int) {$/;"	m
emitls	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def emitls(pat: u32, rd: ArmReg, rn: ArmReg, off: ArmOffset) {$/;"	m
emitlss	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def emitlss(pat: u32, rd: ArmReg, rn: ArmReg, off: ArmSmallOffset) {$/;"	m
emitm	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitm(a: X86_64Addr, eop: int) {$/;"	m
emitop2_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitop2_m_i(a: X86_64Addr, i: int, rex: byte, op2code: byte) {$/;"	m
emitop2_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitop2_m_r(a: X86_64Addr, b: X86_64Gpr, rex: byte, op2code: byte) {$/;"	m
emitop2_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitop2_r_i(a: X86_64Gpr, i: int, rex: byte, op2code: byte) {$/;"	m
emitop2_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitop2_r_m(a: X86_64Gpr, b: X86_64Addr, rex: byte, op2code: byte) {$/;"	m
emitop2_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitop2_r_r(a: X86_64Reg, b: X86_64Reg, rex: byte, op2code: byte) {$/;"	m
emitq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitq(d0: long) {$/;"	m
emitr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitr(a: X86_64Reg, eop: int) {$/;"	m
emitrm_1	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def emitrm_1(eop: int, regnum: int, a: X86_64Addr) {$/;"	m
emitw	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def emitw(d0: int) {$/;"	m
empty	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def empty() -> bool {$/;"	m
empty	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def empty() -> bool {$/;"	m
empty	$VIRGIL/lib/util/Stack.v3	/^	def empty() -> bool;$/;"	m
emptyRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def emptyRefMap(max: int) -> int {$/;"	m
enable	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def enable() { ssa.breakpoint = true; }$/;"	m
encode	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def encode(w: DataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def encode(w: DataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encode(rt: MachRuntime, w: MachDataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def encode(w: MachDataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def encode(w: MachDataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def encode(w: MachDataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def encode(is64: bool, w: DataWriter) {$/;"	m
encode	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def encode(is64: bool, w: DataWriter) {$/;"	m
encode	$VIRGIL/lib/util/Utf8.v3	/^	def encode(codepoint: u32, dest: Array<byte>, pos: int) -> int {$/;"	f
encode32	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def encode32(w: DataWriter) {$/;"	m
encode64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def encode64(w: DataWriter) {$/;"	m
encodeAbs	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeAbs(w: DataWriter, space: AddressSpace, abs: int) {$/;"	m
encodeAddr	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeAddr(w: DataWriter, space: AddressSpace, addr: Addr) {$/;"	m
encodeCmds	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def encodeCmds(w: DataWriter) {$/;"	m
encodeCond	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def encodeCond(cond: X86_64Cond) -> int {$/;"	m
encodeData	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeData(region: Region, w: DataWriter, a: Addr) {$/;"	m
encodeField	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeField(w: DataWriter, f: IrField) {$/;"	m
encodeInt	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeInt(w: DataWriter, v: Val, tt: IntType) {$/;"	m
encodeMtable	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeMtable(w: DataWriter, mtable: IrMtable) {$/;"	m
encodeRecord	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeRecord(w: DataWriter, r: Record) {$/;"	m
encodeRegion	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeRegion(region: Region, w: MachDataWriter) {$/;"	m
encodeSource	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	private def encodeSource(off: int, source: Source) {$/;"	m
encodeSymbolTable	$VIRGIL/aeneas/src/os/Linux.v3	/^	def encodeSymbolTable(w: DataWriter) {$/;"	m
encodeVal	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def encodeVal(w: DataWriter, v: Val, t: Type) {$/;"	m
end	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var end: u32;$/;"	d
end	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var end: int = -1;		\/\/ end position of code that defines this var$/;"	d
end	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def end() -> SsaEnd {$/;"	m
end	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var end: int;    \/\/ end of block interval containing loop blocks$/;"	d
end	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var end: bool;$/;"	d
end	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def end() -> this {$/;"	m
end	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def end(start: FilePoint) -> FileRange {$/;"	m
end	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def end(stmt: MatchStmt) {$/;"	m
end	$VIRGIL/lib/util/DataWriter.v3	/^	def end() -> int {$/;"	m
end	$VIRGIL/lib/util/Token.v3	/^	def end() -> FilePoint {$/;"	m
endAddr	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def endAddr() -> int {$/;"	m
endColumn	$VIRGIL/lib/util/Token.v3	/^	def endColumn: int;$/;"	d
endLine	$VIRGIL/lib/util/Token.v3	/^	def endLine: int;$/;"	d
endOffset	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def endOffset() -> int {$/;"	m
endPageAddr	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def endPageAddr() -> int {$/;"	m
endPos	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var endPos: int;		\/\/ last live position$/;"	d
endSection	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def endSection() {$/;"	m
ends	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def ends = Vector<int>.new(); \/\/ offset to an end of a souce line$/;"	d
endsWith	$VIRGIL/lib/util/Strings.v3	/^	def endsWith(str: string, end: string) -> bool {$/;"	f
endsWithFrom	$VIRGIL/lib/util/Strings.v3	/^	def endsWithFrom(str: string, start: int, end: string) -> bool {$/;"	f
enorm	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var enorm: TypeNorm; \/\/ for mixed arrays$/;"	d
enter	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def enter(name: string, indent: int) {$/;"	m
enterExtendedAsciiMode	$VIRGIL/lib/term/Vt100.v3	/^	def enterExtendedAsciiMode = lit("\x0E");$/;"	d
enterMethod	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def enterMethod(m: IrMethod) -> this {$/;"	m
enterMethod	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def enterMethod(m: MethodEnv) {$/;"	m
enterNormalAsciiMode	$VIRGIL/lib/term/Vt100.v3	/^	def enterNormalAsciiMode = lit("\x0F");$/;"	d
enterScope	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def enterScope() -> int {$/;"	m
enterSpec	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def enterSpec(s: IrSpec) -> this {$/;"	m
entries	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def entries = Vector<DwarfLocListEntry>.new();$/;"	d
entries	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def entries = Vector<(int, int, int)>.new();$/;"	d
entryStub	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def entryStub = Addr.new(codeRegion, null, 0);$/;"	d
entryStubFuncIndex	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var entryStubFuncIndex = -1;$/;"	d
enumDecl	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def enumDecl: VstEnum;$/;"	d
enumGetParamOperator	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def enumGetParamOperator(f: VstField) -> Operator {$/;"	m
enumType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var enumType: EnumType;$/;"	d
enumVals	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var enumVals: Record;$/;"	d
enums	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def enums = Vector<VstEnum>.new();$/;"	d
env	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var env: IrSpec;$/;"	d
env	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def env: VarEnvironment;$/;"	d
env	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def env = VarEnvironment.new();$/;"	d
eof_at	$VIRGIL/lib/util/DataReader.v3	/^	def eof_at(pos: int, size: int, msg: string) -> this {$/;"	m
eor	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def eor(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(2, rd, rn, op); }$/;"	m
eors	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def eors(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(3, rd, rn, op); }$/;"	m
eqArrayLength	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def eqArrayLength(index: SsaInstr, array: SsaInstr) -> bool {$/;"	m
equal	$VIRGIL/aeneas/src/core/Value.v3	/^	def equal(val1: Val, val2: Val) -> bool {$/;"	f
equal	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def equal(a: SsaInstr, b: SsaInstr) -> bool {$/;"	m
equal	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private def equal(a: (Type, Val), b: (Type, Val)) -> bool {$/;"	m
equal	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def equal(a: (int, int), b: (int, int)) -> bool {$/;"	m
equal	$VIRGIL/lib/util/Arrays.v3	/^	def equal<A>(x: Array<A>, y: Array<A>) -> bool {$/;"	f
equal	$VIRGIL/lib/util/Ranges.v3	/^	def equal<A>(x: Range<A>, y: Range<A>) -> bool {$/;"	f
equal	$VIRGIL/lib/util/Strings.v3	/^	def equal(arr1: string, arr2: string) -> bool {$/;"	f
equalApply	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def equalApply(a: SsaApplyOp, b: SsaApplyOp) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/core/Operator.v3	/^	def equals(that: Operator) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/core/Program.v3	/^	def equals(other: Val) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/core/Value.v3	/^	def equals(val: Val) -> bool { return this == val; }$/;"	m
equals	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def equals(other: IrSpec) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def equals(val: Val) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/types/Float.v3	/^	def equals(that: Val) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/types/Function.v3	/^	def equals(that: Signature) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def equals(other: Val) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def equals(other: Val) -> bool {$/;"	m
equals	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def equals(other: Val) -> bool {$/;"	m
equals	$VIRGIL/lib/util/Map.v3	/^	def equals: (K, K) -> bool;$/;"	d
equalsList	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def equalsList(l1: List<Type>, l2: List<Type>) -> bool {$/;"	f
eraseDown	$VIRGIL/lib/term/Vt100.v3	/^	def eraseDown = esc("[J");$/;"	d
eraseLine	$VIRGIL/lib/term/Vt100.v3	/^	def eraseLine = esc("[2K");$/;"	d
eraseOneLeft	$VIRGIL/lib/term/Vt100.v3	/^	def eraseOneLeft = lit("\x1b[0D \x1b[0D");$/;"	d
eraseScreen	$VIRGIL/lib/term/Vt100.v3	/^	def eraseScreen = esc("[2J");$/;"	d
eraseToEndOfLine	$VIRGIL/lib/term/Vt100.v3	/^	def eraseToEndOfLine = esc("[K");$/;"	d
eraseToStartOfLine	$VIRGIL/lib/term/Vt100.v3	/^	def eraseToStartOfLine = esc("[1K");$/;"	d
eraseUp	$VIRGIL/lib/term/Vt100.v3	/^	def eraseUp = esc("[1J");$/;"	d
err	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def err = darwinFileStream(DarwinConst.STDERR);$/;"	d
errAtDecl	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtDecl(decl: Decl) -> SourceCodeError {$/;"	m
errAtDecl	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtDecl(decl: Decl) -> SourceCodeError {$/;"	m
errAtExpr	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtExpr(expr: Expr) -> SourceCodeError {$/;"	m
errAtExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtExpr(expr: Expr) -> SourceCodeError {$/;"	m
errAtPoint	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtPoint(point: FilePoint) -> SourceCodeError {$/;"	m
errAtPoint	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtPoint(point: FilePoint) -> SourceCodeError {$/;"	m
errAtRange	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtRange(range: FileRange) -> SourceCodeError {$/;"	m
errAtRange	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtRange(range: FileRange) -> SourceCodeError {$/;"	m
errAtStmt	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtStmt(stmt: Stmt) -> SourceCodeError {$/;"	m
errAtStmt	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtStmt(stmt: Stmt) -> SourceCodeError {$/;"	m
errAtToken	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def errAtToken(token: Token) -> SourceCodeError {$/;"	m
errAtToken	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errAtToken(token: Token) -> SourceCodeError {$/;"	m
errInsideToken	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def errInsideToken(token: Token, offset: int) -> SourceCodeError {$/;"	m
errnoToNetError	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^def errnoToNetError(e: long) -> NetError {$/;"	f
error	$VIRGIL/aeneas/src/main/Error.v3	/^	def var error: string;$/;"	d
error	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def error(expr: Expr, msg: string) -> SsaInstr {$/;"	m
error	$VIRGIL/aeneas/src/types/Type.v3	/^	var error: bool;$/;"	d
error	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def error(args: Arguments) -> Exception {$/;"	m
error	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def error(msg: string) -> bool {$/;"	m
error	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def error(msg: string) {$/;"	m
error	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def error(ex: string, msg: string) {$/;"	f
error1	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def error1<T>(msg: string, param: T) {$/;"	m
errorAt	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def errorAt(range: FileRange, msg: string) {$/;"	m
errorAtOffset	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def errorAtOffset(offset: int, msg: string) {$/;"	m
errorType	$VIRGIL/aeneas/src/main/Error.v3	/^	var errorType: Type;$/;"	d
error_column	$VIRGIL/lib/util/TextReader.v3	/^	def var error_column: int = int.max;	\/\/ earliest column with error$/;"	d
error_line	$VIRGIL/lib/util/TextReader.v3	/^	def var error_line: int = int.max;	\/\/ earliest line with error$/;"	d
error_msg	$VIRGIL/aeneas/src/types/Type.v3	/^	var error_msg: string;$/;"	d
error_msg	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var error_msg: string;$/;"	d
error_msg	$VIRGIL/lib/util/DataReader.v3	/^	def var error_msg: string;		\/\/ error message$/;"	d
error_msg	$VIRGIL/lib/util/TextReader.v3	/^	def var error_msg: string;		\/\/ error message$/;"	d
error_pos	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var error_pos: int;$/;"	d
error_pos	$VIRGIL/lib/util/DataReader.v3	/^	def var error_pos: int = int.max;	\/\/ first error position$/;"	d
errornoOk	$VIRGIL/rt/x86-64-darwin/System.v3	/^def errornoOk(rval: long, errorno: long) -> bool {$/;"	f
errors	$VIRGIL/aeneas/src/main/Error.v3	/^	var errors: List<Error>;$/;"	d
errors	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	var errors: List<int>;			\/\/ errors generated so far$/;"	d
esc	$VIRGIL/lib/term/Vt100.v3	/^	def esc(s: string) -> void -> void {$/;"	f
esi	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def esi = X86Regs.ESI;$/;"	d
esp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def esp = X86Regs.ESP;$/;"	d
evalAppExprs	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def evalAppExprs(t: Expr, appbind: AppBinding, a: VstList<Expr>, boundMap: Array<int>, env: VstSsaEnv) -> (SsaInstr, Array<SsaInstr>) {$/;"	m
evalAppExprs0	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def evalAppExprs0(t: Expr, appbind: AppBinding, args: Array<Expr>, boundMap: Array<int>, env: VstSsaEnv) -> (SsaInstr, Array<SsaInstr>) {$/;"	m
evalDecInt	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def evalDecInt(r: Range<byte>) -> Val {$/;"	m
evalDecLong	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def evalDecLong(r: Range<byte>) -> Val {$/;"	m
evalFloat	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def evalFloat(w: Range<byte>, f: Range<byte>, negexp: bool, e: Range<byte>) -> Val {$/;"	m
evalIntBinop	$VIRGIL/aeneas/src/core/Eval.v3	/^def evalIntBinop(args: Arguments, op32: (int, int) -> int, op64: (long, long) -> long) -> Result  {$/;"	f
evalIntShift	$VIRGIL/aeneas/src/core/Eval.v3	/^def evalIntShift(args: Arguments, op32: (int, byte) -> int, op64: (long, byte) -> long) -> Result  {$/;"	f
evalOp	$VIRGIL/aeneas/src/core/Eval.v3	/^def evalOp(op: Operator, args: Arguments) -> Result {$/;"	f
evalOp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def evalOp(op: Operator, dst: int, args: Array<int>) -> Result {$/;"	m
evalOverflowExponent	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def evalOverflowExponent() -> Val {$/;"	m
evalUnderflowExponent	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def evalUnderflowExponent() -> Val {$/;"	m
evaluate	$VIRGIL/aeneas/src/core/Operator.v3	/^	def evaluate(args: Arguments) -> Result {$/;"	m
exDests	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var exDests: List<Addr>;$/;"	d
exEntries	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def exEntries  = Vector<(int, int)>.new();$/;"	d
exRegion	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def exRegion  = Region.new("ex", mach.code);$/;"	d
exStringTable	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def exStringTable = TableIndex<string, int>.new(Strings.hash);$/;"	d
exactFuncType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var exactFuncType: Type;$/;"	d
exactType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var exactType: Type;$/;"	d
exception	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var exception: Exception;	\/\/ last exception$/;"	d
exception	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def exception: string;$/;"	d
exception	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var exception: Exception;$/;"	d
exception_table_length	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var exception_table_length: int;$/;"	d
execute	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def execute(instr: IcInstr) -> int {$/;"	m
execute	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def execute(opt: DbgExecuteOpt) {$/;"	m
executed	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	var executed = false;$/;"	d
exit	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def exit() {$/;"	m
exit	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def exit(code: int) {$/;"	f
exitScope	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def exitScope(prevStart: int) {$/;"	m
exits	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var exits: List<SsaCfEdge>; \/\/ edges leaving loop$/;"	d
exp	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	var exp: int;$/;"	d
exp	$VIRGIL/lib/math/Math.v3	/^	def exp = exp0;$/;"	d
exp0	$VIRGIL/lib/math/Math.v3	/^def exp0(x: double) -> double {$/;"	f
exp_width	$VIRGIL/aeneas/src/types/Float.v3	/^	def exp_width: byte;$/;"	d
expect	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def expect(msg: string) -> T {$/;"	m
expected	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def expected(v: string) -> int {$/;"	m
expected	$VIRGIL/lib/util/TextReader.v3	/^	private def expected(s: string) -> int {$/;"	m
expectedFail	$VIRGIL/aeneas/src/util/Progress.v3	/^	def expectedFail(report: string) {$/;"	m
expectedFailed	$VIRGIL/aeneas/src/util/Progress.v3	/^	var expectedFailed: int;$/;"	d
explicitName	$VIRGIL/aeneas/src/core/Program.v3	/^	var explicitName: string;$/;"	d
explicitNullCheck	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def explicitNullCheck(source: Source, t: Type, nobj: SsaInstr) -> SsaInstr {$/;"	m
explicitTag	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	var explicitTag: Interval;$/;"	d
explicitTag	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var explicitTag: (int, Interval);$/;"	d
explicitTagLength	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var explicitTagLength: byte;$/;"	d
expname	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def expname: string;$/;"	d
exponentBias	$VIRGIL/aeneas/src/types/Float.v3	/^	def exponentBias() -> int {$/;"	m
exportMap	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var exportMap: PartialMap<string, ExportDecl>;$/;"	d
exports	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def exports = Vector<ExportDecl>.new();$/;"	d
expr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def expr: VstPackingExpr;$/;"	d
exprSource	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def exprSource(e: Expr) -> Source {$/;"	m
extPutVariable	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def extPutVariable(idx: int, name: string, val: Val, vtype: Type) {$/;"	m
extWriteFlags	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var extWriteFlags: Array<bool>;$/;"	d
extarray	$VIRGIL/aeneas/src/wasm/WasmOp.v3	/^	def extarray = Array<string>.new(256);$/;"	d
extendBigEnd	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def extendBigEnd(bigEnd: SsaInstr, ft: IntType, signed: bool) -> SsaInstr {$/;"	m
extended	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def extended = Vector<int>.new();$/;"	d
extract	$VIRGIL/lib/util/DataWriter.v3	/^	def extract() -> Array<byte> {$/;"	m
extract	$VIRGIL/lib/util/StringBuilder.v3	/^	def extract() -> string {$/;"	m
extract	$VIRGIL/lib/util/Vector.v3	/^	def extract() -> Array<T> {$/;"	m
extractFieldRef	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def extractFieldRef(i_old: SsaApplyOp, field: IrField) -> RaField {$/;"	m
extractIdent	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def extractIdent<T>(p: ParserState, end: int) -> VstIdent<T> {$/;"	f
extractIrSpec	$VIRGIL/aeneas/src/core/Operator.v3	/^	def extractIrSpec(op: Operator, member: IrMember) -> IrSpec {$/;"	f
extractLine	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	def extractLine(line: int) -> string {$/;"	m
extractLine	$VIRGIL/lib/util/Token.v3	/^	def extractLine(input: Array<byte>, lineEnds: Vector<int>) -> string {$/;"	m
extractMethodRef	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def extractMethodRef(op: Operator, method: IrMethod) -> (FuncNorm, IrSpec) {$/;"	m
extractTmpConstraint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def extractTmpConstraint(len: int) {$/;"	m
extractVirtualRef	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def extractVirtualRef(op: Operator, method: IrMethod) -> (FuncNorm, IrSpec, bool) {$/;"	m
f2d	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def f2d() {$/;"	m
f2i	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def f2i() {$/;"	m
f2i_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def f2i_fixup() {$/;"	m
f2l	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def f2l() {$/;"	m
f2ui_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def f2ui_fixup() {$/;"	m
f32	$VIRGIL/aeneas/src/types/Float.v3	/^	def f32(sign: int, exp: int, mantissa: u32) -> Float32Val {$/;"	f
f32_count	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var f32_count = 0;$/;"	d
f64	$VIRGIL/aeneas/src/types/Float.v3	/^	def f64(sign: int, exp: int, mantissa: u64) -> Float64Val {$/;"	f
f64_count	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var f64_count = 0;$/;"	d
f_suffix	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var f_suffix: bool;$/;"	d
fabs	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def fabs(dest: SSEReg, a: SSERm, isDouble: bool) {$/;"	m
facts	$VIRGIL/aeneas/src/core/Opcode.v3	/^	def facts(opcode: Opcode) -> Fact.set { return table[opcode.tag]; }$/;"	f
facts	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var facts: Fact.set;$/;"	d
facts	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def facts() -> Fact.set {$/;"	m
facts	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var facts: Fact.set;		\/\/ computed dataflow facts$/;"	d
facts	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var facts: Fact.set;$/;"	d
fadd_d	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fadd_d(a: SSEAddr) {$/;"	m
faddd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def faddd(a: X86_64Addr) -> this {$/;"	m
fail	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def fail<T>(msg: string, p: T) {$/;"	m
fail	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def fail(msg: string) {$/;"	m
fail	$VIRGIL/aeneas/src/main/Error.v3	/^	def fail(msg: string) {$/;"	m
fail	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def fail(msg: string) {$/;"	m
fail	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def fail<T>(msg: string) -> T {$/;"	m
fail	$VIRGIL/aeneas/src/util/Progress.v3	/^	def fail(report: string) {$/;"	m
fail	$VIRGIL/aeneas/src/v3/V3.v3	/^	def fail<T>(msg: string) -> T {$/;"	f
fail	$VIRGIL/lib/util/DataReader.v3	/^	def fail(msg: string) -> this {$/;"	m
fail	$VIRGIL/lib/util/TextReader.v3	/^	def fail(msg: string) -> this {$/;"	m
fail1	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def fail1<A>(fmt: string, a: A) {$/;"	m
fail1	$VIRGIL/aeneas/src/v3/V3.v3	/^	def fail1<T, A>(msg: string, p: A) -> T {$/;"	f
failCriticalEdge	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def failCriticalEdge(e: SsaCfEdge) {$/;"	m
failLocation	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def failLocation(msg: string, loc: int, regSet: MachRegSet) -> ArmReg {$/;"	m
failLocation	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def failLocation(msg: string, loc: int, regSet: MachRegSet) -> X86Reg {$/;"	m
failRel	$VIRGIL/lib/util/TextReader.v3	/^	def failRel(offset: int, msg: string) -> this {$/;"	m
failSSELocation	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def failSSELocation(msg: string, loc: int, regSet: MachRegSet) -> SSEReg {$/;"	m
fail_at	$VIRGIL/lib/util/DataReader.v3	/^	def fail_at(pos: int, msg: string) -> this {$/;"	m
failed	$VIRGIL/aeneas/src/util/Progress.v3	/^	var failed: int;$/;"	d
failures	$VIRGIL/aeneas/src/util/Progress.v3	/^	var failures: List<(string, string)>;$/;"	d
falseBlock	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def falseBlock() -> SsaBlock { return block().succ(1).dest; }$/;"	m
falseBlock	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	private var falseBlock: SsaBuilder;$/;"	d
falseConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def falseConst() -> SsaConst {$/;"	m
far_uses	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var far_uses: List<int>;$/;"	d
fatalReport	$VIRGIL/aeneas/src/main/Error.v3	/^	def fatalReport(context: string) {$/;"	m
fconst	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def fconst(val: u32) {$/;"	m
ffunc	$VIRGIL/lib/util/IO.v3	/^	private def ffunc: (Array<byte>, int, int) -> void;$/;"	d
fgBlack	$VIRGIL/lib/term/Vt100.v3	/^	def fgBlack = esc("[0;30m");$/;"	d
fgBlue	$VIRGIL/lib/term/Vt100.v3	/^	def fgBlue = esc("[0;34m");$/;"	d
fgBrightBlue	$VIRGIL/lib/term/Vt100.v3	/^	def fgBrightBlue = esc("[1;34m");$/;"	d
fgBrightCyan	$VIRGIL/lib/term/Vt100.v3	/^	def fgBrightCyan = esc("[1;36m");$/;"	d
fgBrightGreen	$VIRGIL/lib/term/Vt100.v3	/^	def fgBrightGreen = esc("[1;32m");$/;"	d
fgBrightRed	$VIRGIL/lib/term/Vt100.v3	/^	def fgBrightRed = esc("[1;31m");$/;"	d
fgBrown	$VIRGIL/lib/term/Vt100.v3	/^	def fgBrown = esc("[0;33m");$/;"	d
fgCyan	$VIRGIL/lib/term/Vt100.v3	/^	def fgCyan = esc("[0;36m");$/;"	d
fgDarkgray	$VIRGIL/lib/term/Vt100.v3	/^	def fgDarkgray = esc("[1;30m");$/;"	d
fgGreen	$VIRGIL/lib/term/Vt100.v3	/^	def fgGreen = esc("[0;32m");$/;"	d
fgLightGray	$VIRGIL/lib/term/Vt100.v3	/^	def fgLightGray = esc("[0;37m");$/;"	d
fgMagenta	$VIRGIL/lib/term/Vt100.v3	/^	def fgMagenta = esc("[1;35m");$/;"	d
fgNorm	$VIRGIL/lib/term/Vt100.v3	/^	def fgNorm = esc("[0m");$/;"	d
fgPurple	$VIRGIL/lib/term/Vt100.v3	/^	def fgPurple = esc("[0;35m");$/;"	d
fgRed	$VIRGIL/lib/term/Vt100.v3	/^	def fgRed = esc("[0;31m");$/;"	d
fgWhite	$VIRGIL/lib/term/Vt100.v3	/^	def fgWhite = esc("[1;37m");$/;"	d
fgYellow	$VIRGIL/lib/term/Vt100.v3	/^	def fgYellow = esc("[1;33m");$/;"	d
fid	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var fid: int;$/;"	d
fieldConst	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def fieldConst(receiver: Type, member: VstField, obj: SsaInstr, env: VstSsaEnv) -> SsaInstr {$/;"	m
fieldID	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var fieldID: int;$/;"	d
fieldMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def fieldMap      = IrUtil.newIrItemMap<Address<IrField>>();$/;"	d
fieldNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def fieldNorm(rf: RaField) -> TypeNorm {$/;"	m
fieldOrder	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	var fieldOrder: Array<CaseField>;$/;"	d
fieldRanges	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var fieldRanges: Array<(int, int)>; \/\/ (start, end) index for ClassAlloc instructions$/;"	d
fieldRangesO	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var fieldRangesO: Array<(int, int)>;$/;"	d
fieldRangesT	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var fieldRangesT: Array<(int, int)>;	\/\/ mapping of unnormalized field index to normalized range$/;"	d
fieldRedefs	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var fieldRedefs: VstList<VstRedefField>;	\/\/ parse field redefinitions$/;"	d
fieldStart	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def fieldStart() -> int {$/;"	m
fieldType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def fieldType: Type;	\/\/ the type of the field$/;"	d
fields	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def fields: Array<IrField>;		\/\/ fields, including super fields$/;"	d
fields	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def fields = Vector<IrField>.new();$/;"	d
fields	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def fields = Array<RaField>.new(orig.fields.length);          \/\/ index of fields$/;"	d
fields	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var fields = Vector<CaseField>.new(); \/\/ an ordering of fields to solve for during packing$/;"	d
fields	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def fields = Vector<IrField>.new();$/;"	d
fields	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def fields  = Vector<JvmField>.new();$/;"	d
fields	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var fields: List<(SsaInstr, IrField, SsaInstr)>;$/;"	d
fields	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var fields: List<VstField>;$/;"	d
fields	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def fields: Array<(WasmPacking, WasmType)>;$/;"	d
fild_q	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fild_q(a: SSEAddr) {$/;"	m
fildq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fildq(a: X86_64Addr) -> this {$/;"	m
file	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var file: JvmClassfile;$/;"	d
file	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def file: ParsedFile;			\/\/ the file being parsed$/;"	d
file	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def file: VstFile;$/;"	d
fileClose	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileClose(args: Arguments) -> Val {$/;"	m
fileClose	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileClose(fd: int) {$/;"	f
fileCount	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var fileCount: u32 = 1;$/;"	d
fileLeft	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileLeft(args: Arguments) -> Val {$/;"	m
fileLeft	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileLeft(fd: int) -> int {$/;"	f
fileLoad	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileLoad(args: Arguments) -> Record {$/;"	m
fileLoad	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileLoad(fileName: string) -> Array<byte> {$/;"	f
fileName	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	def fileName: string;$/;"	d
fileName	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def fileName = file.fileName;		\/\/ name of the file$/;"	d
fileName	$VIRGIL/lib/util/TextReader.v3	/^	def fileName: string;$/;"	d
fileNum	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def fileNum: u32;$/;"	d
fileOpen	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileOpen(args: Arguments) -> Box<int> {$/;"	m
fileOpen	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileOpen(fileName: string, read: bool) -> int {$/;"	f
fileRead	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileRead(args: Arguments) -> Val {$/;"	m
fileRead	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileRead(fd: int) -> int {$/;"	f
fileReadK	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileReadK(args: Arguments) -> Result {$/;"	m
fileReadK	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileReadK(fd: int, data: Array<byte>, offset: int, len: int) -> int {$/;"	f
fileWriteK	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def fileWriteK(args: Arguments) -> Result {$/;"	m
fileWriteK	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def fileWriteK(fd: int, data: Array<byte>, offset: int, len: int) {$/;"	f
filename	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def filename: string;$/;"	d
fileoff	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var fileoff: int;$/;"	d
files	$VIRGIL/aeneas/src/core/Program.v3	/^	var files: Array<string>;		\/\/ the input files$/;"	d
files	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def files = HashMap<string, DwarfFile>.new(Strings.hash, Strings.equal);$/;"	d
files	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var files: List<(string, int, int, int)>;$/;"	d
files	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var files: Array<VstFile>;			\/\/ all files, in order specified on command line$/;"	d
filesize	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var filesize: int;$/;"	d
filetype	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var filetype: int;$/;"	d
filter	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def filter(matcher: VstMatcher, spec: IrSpec, f: IrSpec -> void) {$/;"	m
filter	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def filter(f: VstMatcher) -> bool {$/;"	m
filterIc	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def filterIc(matcher: VstMatcher, spec: IrSpec, icm: IcMethod, f: (IrSpec, IcMethod) -> void) {$/;"	m
find	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def find(key: K, f: K -> D) -> int {$/;"	m
find	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def find(obj: SsaInstr, f: IrMember) -> SsaInstr {$/;"	m
findAbsConst	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def findAbsConst(start: int) -> int {$/;"	m
findBestLoc	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def findBestLoc(regClass: RegClass, hint: int, constraint: int) -> int {$/;"	m
findBestLocUnderConstraint	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def findBestLocUnderConstraint(regClass: RegClass, prefer: int, constraint: int) -> int {$/;"	m
findChild	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def findChild(c: IrMethod) -> CctNode<F> {$/;"	m
findCommonDominator	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def findCommonDominator(vreg: VReg, block: SsaBlock) -> SsaBlock {$/;"	m
findDominatorOutOfLoop	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def findDominatorOutOfLoop(node: Node) -> SsaBlock {$/;"	m
findError	$VIRGIL/lib/util/Utf8.v3	/^	def findError(str: string) -> int {$/;"	f
findJoins	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def findJoins(bi: SsaBlockInfo) -> List<SsaBlockInfo> {$/;"	m
findLinearIvs	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def findLinearIvs() -> List<SsaLinearIv> {$/;"	m
findLoopControl	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def findLoopControl() -> (SsaInstr, bool) {$/;"	m
findLoopRemainder	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def findLoopRemainder(bi: SsaBlockInfo) -> List<SsaBlockInfo> {$/;"	m
findMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def findMethod(index: int, typeArgs: Array<Type>) -> RaMethod {$/;"	m
findPriorBoundsCheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def findPriorBoundsCheck(i: SsaInstr, x: SsaInstr, y: SsaInstr) -> bool {$/;"	m
findRaMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def findRaMethod(rm: RaMethod) -> RaMethod {$/;"	m
findSucc	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def findSucc(v: Val) -> SsaCfEdge {$/;"	m
finish	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def finish(item: SpecMethod) {$/;"	m
finish	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def finish() {$/;"	m
finish	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def finish() -> SsaBuilder {$/;"	m
finish	$VIRGIL/lib/util/Arrays.v3	/^	private def finish<T>(array: Array<T>, k: int, end: Array<T>, i: int) -> Array<T> {$/;"	f
finishBlock	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def finishBlock(b: SsaBlockInfo, livein: BitMatrix, bnum: int, pnum: int) {$/;"	m
finishBlockOrder	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	private def finishBlockOrder(list: List<SsaBlock>) {$/;"	m
finishCycle	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int);$/;"	m
finishDefs	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def finishDefs(i: ArchInstr, d: Operand.Def, consumedFromStack: bool) {$/;"	m
finishFloat	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def finishFloat(w: Range<byte>, f: Range<byte>, negexp: bool, e: Range<byte>) -> bool {$/;"	m
finishFmt	$VIRGIL/lib/util/StringBuilder.v3	/^	private def finishFmt(fmt: string, offset: int) {$/;"	m
finishInstrs	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def finishInstrs(start: ArchInstr, end: ArchInstr) {$/;"	m
finishLoop	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def finishLoop(b: SsaBlockInfo, livein: BitMatrix) {$/;"	m
finishLoopLiveness	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def finishLoopLiveness(info: SsaBlockInfo) {$/;"	m
finishPhi	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	private def finishPhi(i_old: SsaPhi) {$/;"	m
finishRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def finishRefMap() -> int {$/;"	m
finishStringSection	$VIRGIL/aeneas/src/os/Linux.v3	/^	def finishStringSection(w: DataWriter) {$/;"	m
fire	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def fire(i: IcInterpreter, probeIp: int) {$/;"	m
fire	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def fire(i: SsaInterpreter) { }$/;"	m
fire	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def fire(i: SsaInterpreter) {$/;"	m
fire	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def fire(i: SsaInterpreter) {$/;"	m
fire	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	def fire(i: SsaInterpreter) {$/;"	m
fireBefore	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def fireBefore(i: IcInstr, probes: IcProbes, probeIp: int) -> bool {$/;"	m
fireProbes	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def fireProbes(probes: IcProbes, probeIp: int, after: bool) {$/;"	m
first	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var first = true;$/;"	d
first	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def first() -> Type {$/;"	m
first	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var first = SsaJvmInstr.new();	\/\/ fake "first" instruction in a basic block$/;"	d
first	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var first: ArchInstr;$/;"	d
first	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def first() -> T {$/;"	m
firstByte	$VIRGIL/lib/util/Token.v3	/^	def firstByte() -> FileRange {$/;"	m
firstConst	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var firstConst: int;$/;"	d
firstError	$VIRGIL/aeneas/src/main/Error.v3	/^	def firstError() -> string {$/;"	m
firstSourceLine	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var firstSourceLine: bool; \/\/ used by SsaX86_64Gen in assemble$/;"	d
fisttp_q	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fisttp_q(a: SSEAddr) {$/;"	m
fisttpq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fisttpq(a: X86_64Addr) -> this {$/;"	m
flags	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var flags = DWARF_DEFAULT_IS_STMT;$/;"	d
flags	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var flags: int;$/;"	d
flags	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def flags = OptimizationFlags.new(CLOptions.OPT.get(), optError);$/;"	d
fld_d	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fld_d(a: SSEAddr) {$/;"	m
fld_q	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fld_q(a: SSEAddr) {$/;"	m
fldd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fldd(a: X86_64Addr) -> this {$/;"	m
fldq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fldq(a: X86_64Addr) -> this {$/;"	m
flip	$VIRGIL/lib/util/BitMatrix.v3	/^	def flip() {$/;"	m
flip	$VIRGIL/lib/util/Random.v3	/^	def flip(num: int, denom: int) -> bool {$/;"	f
flipRow	$VIRGIL/lib/util/BitMatrix.v3	/^	def flipRow(row: int) {$/;"	m
floatParamRegs	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def floatParamRegs = [R.XMM0, R.XMM1, R.XMM2, R.XMM3, R.XMM4, R.XMM5, R.XMM6];$/;"	d
floatRetRegs	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def floatRetRegs = [R.XMM0, R.XMM1];$/;"	d
flow	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var flow: int;			\/\/ flow control state$/;"	d
flow	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var flow: int;			\/\/ used to detect unreachable code$/;"	d
flush	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def flush() -> this {$/;"	m
flush	$VIRGIL/lib/util/IO.v3	/^	def flush() {$/;"	m
fname	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var fname: string;$/;"	d
fold	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var fold: bool;		\/\/ true if all inputs are constants$/;"	d
fold2i	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def fold2i(s: (int, int) -> int, sl: (long, long) -> long) -> SsaInstr {$/;"	m
fold4b	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def fold4b(s: (int, int) -> bool, u: (u32, u32) -> bool, sl: (long, long) -> bool, ul: (u64, u64) -> bool) -> SsaInstr {$/;"	m
fold4i	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def fold4i(s: (int, int) -> int, u: (u32, u32) -> u32, sl: (long, long) -> long, ul: (u64, u64) -> u64) -> SsaInstr {$/;"	m
foldLazyEvalL	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def foldLazyEvalL(isAnd: bool, left: bool, right: Expr, env: VstSsaEnv) -> SsaInstr {$/;"	m
foldLazyEvalR	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def foldLazyEvalR(isAnd: bool, left: SsaInstr, right: bool) -> SsaInstr {$/;"	m
forAll	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def forAll<T>(vec: Vector<T>, do: T -> void) {$/;"	m
foreachBlock	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def foreachBlock(pm: IcMethodProf, f: (IcMethodProf, (int, int), int) -> void) {$/;"	m
format1	$VIRGIL/lib/util/Strings.v3	/^	def format1<A>(fmt: string, a: A) -> string {$/;"	f
format2	$VIRGIL/lib/util/Strings.v3	/^	def format2<A, B>(fmt: string, a: A, b: B) -> string {$/;"	f
format3	$VIRGIL/lib/util/Strings.v3	/^	def format3<A, B, C>(fmt: string, a: A, b: B, c: C) -> string {$/;"	f
formatPrev	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def formatPrev(msg: string, prev: FilePoint) -> string {$/;"	f
fourConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def fourConst() -> SsaConst {$/;"	m
fp_bit_eq	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def fp_bit_eq(dest: X86Reg, a: SSEReg, b: SSERm, isDouble: bool) {$/;"	m
fps	$VIRGIL/lib/term/Animator.v3	/^	var fps: u32;  \/\/ actual frames per second$/;"	d
fraction_width	$VIRGIL/aeneas/src/types/Float.v3	/^	def fraction_width: byte;$/;"	d
frame	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var frame: MachFrame;$/;"	d
frame	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var frame: IcFrame;$/;"	d
frame	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var frame: MachFrame;$/;"	d
frame	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var frame: MachFrame;$/;"	d
frame	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var frame: F;			\/\/ for detecting recursion vs. looping$/;"	d
frame	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var frame: SsaIntFrame;$/;"	d
frame	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	var frame: SsaIntFrame;$/;"	d
frame	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	var frame: MachFrame;$/;"	d
frameAdjust	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def frameAdjust() -> int {$/;"	m
frameAdjust	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def frameAdjust() -> int {$/;"	m
frameAdjust	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def frameAdjust() -> int {$/;"	m
frameSize	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var frameSize: int = -1;	\/\/ architecture-specific total frame size$/;"	d
frameSlots	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def frameSlots() -> int {$/;"	m
free	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def free(spill: int, curPoint: LsraPoint) -> int {$/;"	m
free32Spills	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var free32Spills = SpillQueue.new();$/;"	d
free64Spills	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var free64Spills = SpillQueue.new();$/;"	d
freeList	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var freeList: IcFrame;		\/\/ list for recycling IcFrame objects$/;"	d
freeReg	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def freeReg(loc: int, clear: bool) {$/;"	m
freeSpill	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def freeSpill(spill: int) -> int {$/;"	m
freeze	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def freeze() {$/;"	m
freezeMoves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def freezeMoves(node: int) {$/;"	m
freezeWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def freezeWorklist = Vector<int>.new();$/;"	d
fromArray	$VIRGIL/lib/util/List.v3	/^	def fromArray<T>(array: Array<T>) -> List<T> {$/;"	f
fromIrMemberAndTypes	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def fromIrMemberAndTypes(typeArgs: Array<Type>, member: IrMember) -> IrSpec {$/;"	m
fromTypeArray	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def fromTypeArray(a: Array<Type>) -> Type {$/;"	f
fromVstMember	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def fromVstMember(member: VstMember) -> IrSpec {$/;"	m
fromVstMemberAndType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def fromVstMemberAndType(receiver: Type, member: VstMember) -> IrSpec {$/;"	m
fround_i	$VIRGIL/aeneas/src/core/Eval.v3	/^def fround_i(isDouble: bool, itt: IntType, v: Val) -> (Val, \/*rounded*\/bool) {$/;"	f
fstp_d	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fstp_d(a: SSEAddr) {$/;"	m
fstp_q	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def fstp_q(a: SSEAddr) {$/;"	m
fstpd	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fstpd(a: X86_64Addr) -> this {$/;"	m
fstpq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def fstpq(a: X86_64Addr) -> this {$/;"	m
ftype	$VIRGIL/aeneas/src/types/Function.v3	/^	private var ftype: FuncType;$/;"	d
ftype	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var ftype: Type;$/;"	d
fullName	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var fullName: string;$/;"	d
funcNorm	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var funcNorm: FuncNorm;$/;"	d
funcRef	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def funcRef(m: IrSpec) -> SsaInstr {$/;"	m
funcRefType	$VIRGIL/aeneas/src/types/Function.v3	/^	def funcRefType(ftype: Type) -> Type {$/;"	f
funcRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def funcRep(m: IrSpec) -> Mach_FuncRep {$/;"	m
funcType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def funcType = Function.prependParamType(AnyRef.TYPE, methType);$/;"	d
funcType	$VIRGIL/aeneas/src/types/Function.v3	/^	def funcType() -> FuncType {$/;"	m
functionTable	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def functionTable = Vector<(IrMethod, u32)>.new();$/;"	d
gatherCaseClasses	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def gatherCaseClasses(vec: Vector<IrClass>, decl: VstClass) -> Vector<IrClass> {$/;"	m
gatherLivenessForBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def gatherLivenessForBlock(block: SsaBlock) {$/;"	m
gatherParallelMoveDests	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def gatherParallelMoveDests(i: ArchInstr, dests: Vector<(VReg, List<Operand.Def>)>) {$/;"	m
gatherPolyOps	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def gatherPolyOps(graph: SsaGraph) -> List<SsaApplyOp> {$/;"	m
gcmeth	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var gcmeth: IrMethod;$/;"	d
gen	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def gen: OldCodeGen;$/;"	d
gen	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def gen: VstSsaGen;$/;"	d
gen	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def gen(order: SsaBlockOrder) -> Vector<CfgInstr> {$/;"	m
gen	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen<T>(name: string, f: T -> void, params: T) -> MachInstr {$/;"	m
genAdd	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genAdd(i: SsaApplyOp, v: VReg) {$/;"	m
genAllCode	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genAllCode() {$/;"	m
genAlloc	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genAlloc(source: Source, mtype: Type, size: SsaInstr) -> SsaInstr {$/;"	m
genAlloc	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genAlloc(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genAllocMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genAllocMethod(size: IntType) -> IrMethod {$/;"	m
genAllocStub	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genAllocStub(asm: ArmMacroAssembler) {$/;"	m
genAllocStub	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genAllocStub() {$/;"	m
genAllocStub	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genAllocStub();$/;"	m
genAllocStub	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genAllocStub() {$/;"	m
genAllocStub	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genAllocStub() {$/;"	m
genAppRead	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genAppRead(appbind: AppBinding, target: SsaInstr, args: Array<SsaInstr>, env: VstSsaEnv) -> SsaInstr {$/;"	m
genApply	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genApply(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genApplyOp	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genApplyOp(i_old: SsaApplyOp) {$/;"	m
genApplyOp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genApplyOp(i_old: SsaApplyOp) {$/;"	m
genApplyOp	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def genApplyOp(oi: SsaApplyOp) {$/;"	m
genApplyOp	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genApplyOp(i_old: SsaApplyOp);$/;"	m
genArmCode	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genArmCode(irm: IrMethod, codegen: ArmCodeGen) {$/;"	m
genArrayAlloc	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayAlloc(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genArrayAllocWithSize	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayAllocWithSize(source: Source, arrayType: Type, hsize: int, len: int, scale: int) -> SsaInstr {$/;"	m
genArrayByteGetMultiple	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genArrayByteGetMultiple(i_old: SsaApplyOp, it: IntType, array: SsaInstr, i_offset: SsaInstr, offset: int) -> SsaInstr {$/;"	m
genArrayByteSetMultiple	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genArrayByteSetMultiple(i_old: SsaApplyOp, it: IntType, array: SsaInstr, i_offset: SsaInstr, offset: int, val: SsaInstr) {$/;"	m
genArrayElemOffset	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayElemOffset(headerSize: int, scale: int, index: SsaInstr) -> SsaInstr {$/;"	m
genArrayGetElem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayGetElem(i_old: SsaApplyOp, elem: int) {$/;"	m
genArrayGetLength	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayGetLength(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genArrayInit	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayInit(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genArraySetElem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArraySetElem(i_old: SsaApplyOp, elem: int) {$/;"	m
genArrayTupleInit	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genArrayTupleInit(i_old: SsaApplyOp, elems: int, length: int) -> SsaInstr {$/;"	m
genBinop	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genBinop(c: Operator, pre: SsaInstr, expr: Expr, env: VstSsaEnv) -> SsaInstr {$/;"	m
genBlock	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def genBlock(b: SsaIcBlock) {$/;"	m
genBlock	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genBlock(b_old: SsaBlock, b_new: SsaBlock) {$/;"	m
genBlock	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genBlock(b: SsaBlock) {$/;"	m
genBoundsCheck	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genBoundsCheck(i_old: SsaApplyOp, nullity: Fact.set) -> (SsaInstr, Fact.set) {$/;"	m
genByteArrayGetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genByteArrayGetField(i_old: SsaApplyOp, offset: int) {$/;"	m
genByteArraySetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genByteArraySetField(i_old: SsaApplyOp, offset: int) {$/;"	m
genCall	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCall(call: SsaApplyOp, rv: VReg, funcRep: Mach_FuncRep) -> bool {$/;"	m
genCallClassMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genCallClassMethod(i_old: SsaApplyOp, method: IrMethod) {$/;"	m
genCallClassSelector	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genCallClassSelector(i_old: SsaApplyOp, selector: IrSelector) {$/;"	m
genCallKernel	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCallKernel(sys: SsaApplyOp, rv: VReg, kernel: Kernel) -> bool {$/;"	m
genCallMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genCallMethod(i_old: SsaApplyOp, method: IrMethod) {$/;"	m
genCallRiGc	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genCallRiGc(ssa: SsaBuilder, p_size: SsaInstr) -> SsaInstr {$/;"	m
genCallVariantSelector	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genCallVariantSelector(i_old: SsaApplyOp, selector: IrSelector) {$/;"	m
genCaseBindings	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genCaseBindings(key: SsaInstr, c: MatchCase, env: VstSsaEnv) {$/;"	m
genCheckpoint	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genCheckpoint(i_old: SsaCheckpoint) {$/;"	m
genClassAlloc	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassAlloc(i_old: SsaApplyOp, method: IrMethod) {$/;"	m
genClassCast	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassCast(ft: Type, tt: Type, i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genClassGetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField) {$/;"	m
genClassGetMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {$/;"	m
genClassGetSelector	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {$/;"	m
genClassIdCheck	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassIdCheck(i_old: SsaApplyOp, low: int, high: int, i_new: SsaInstr) -> SsaInstr {$/;"	m
genClassIdQuery	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassIdQuery(i_old: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {$/;"	m
genClassSetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genClassSetField(i_old: SsaApplyOp, field: IrField, init: bool) {$/;"	m
genCmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCmp(cmp: X86CmpMatch) {$/;"	m
genCmpBr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCmpBr(cmp: X86CmpMatch, target: SsaBlock) {$/;"	m
genCmpSet	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCmpSet(cmp: X86CmpMatch, v: VReg) {$/;"	m
genCmpSwp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCmpSwp(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genCode	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def genCode(builder: JvmClassfileBuilder, m: IrMethod, name: string, jsig: JvmSig, static: bool) -> JvmMethod {$/;"	m
genCode	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCode(asm: X86MacroAssembler) {$/;"	m
genCodeFromSsa	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genCodeFromSsa() {$/;"	m
genCodeFromSsa	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genCodeFromSsa();$/;"	m
genCodeFromSsa	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genCodeFromSsa() {$/;"	m
genCodeFromSsa	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genCodeFromSsa() {$/;"	m
genCompareFields	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def genCompareFields(tag: int) {$/;"	m
genCompareTag	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def genCompareTag() {$/;"	m
genComponentGetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genComponentGetField(i_old: SsaApplyOp, field: IrField) {$/;"	m
genComponentSetField	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genComponentSetField(i_old: SsaApplyOp, field: IrField) {$/;"	m
genCondThrow	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genCondThrow(i: SsaApplyOp, v: VReg, exception: string) -> bool {$/;"	m
genDeleteVar	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genDeleteVar(i_old: SsaDeleteVar) {$/;"	m
genDiv	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genDiv(i: SsaApplyOp, v: VReg, div: bool) -> bool {$/;"	m
genEntryStub	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genEntryStub() {$/;"	m
genEntryStub	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genEntryStub();$/;"	m
genEntryStub	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genEntryStub() {$/;"	m
genEntryStub	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genEntryStub() {$/;"	m
genEnumIteration	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genEnumIteration(stmt: ForeachStmt, enumType: EnumType, env: VstSsaEnv) -> SsaInstr {$/;"	m
genEnumSetIteration	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genEnumSetIteration(stmt: ForeachStmt, tc: EnumSetType, set: SsaInstr, env: VstSsaEnv) -> SsaInstr {$/;"	m
genEnumToSet	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def genEnumToSet(x: SsaInstr, block: SsaBuilder) -> SsaInstr {$/;"	m
genEqual2	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genEqual2(t: Type, tn: TypeNorm, xa: Array<SsaInstr>, ya: Array<SsaInstr>) -> SsaInstr {$/;"	m
genEqualN	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genEqualN(i_old: SsaApplyOp, tn: TypeNorm) -> SsaInstr {$/;"	m
genEqualOp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genEqualOp(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genExpr(e: Expr) -> SsaInstr {$/;"	m
genExtractInterval	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genExtractInterval(scalar: SsaInstr, interval: Interval, ft: IntRepType, tt: Type) -> SsaInstr {$/;"	m
genFatalStub	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genFatalStub(ex: string, addr: Addr) {$/;"	m
genFatalStub	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genFatalStub(ex: string, addr: Addr);$/;"	m
genFatalStub	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def genFatalStub(ex: string, addr: Addr) {$/;"	m
genFatalStub	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def genFatalStub(ex: string, addr: Addr) {$/;"	m
genFatalStub	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def genFatalStub(ex: string, addr: Addr) {$/;"	m
genFatalStub	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def genFatalStub(ex: string, addr: Addr) {$/;"	m
genFieldComparisons	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def genFieldComparisons(b: SsaBuilder, falseBlock: SsaBlock) {$/;"	m
genFieldComparisonsWithDefault	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def genFieldComparisonsWithDefault(compareTag: bool, b: SsaBuilder, p0: SsaInstr, falseBlock: SsaBlock) {$/;"	m
genFloatCastD	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genFloatCastD(i_old: SsaApplyOp) {$/;"	m
genFloatCastI	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genFloatCastI(i_old: SsaApplyOp) {$/;"	m
genFloatConvertI	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genFloatConvertI(op: Operator, inputs: Array<SsaInstr>) -> SsaInstr {$/;"	m
genFloatQueryD	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genFloatQueryD(i_old: SsaApplyOp) {$/;"	m
genFloatQueryI	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genFloatQueryI(i_old: SsaApplyOp) {$/;"	m
genFloatRoundI	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genFloatRoundI(i: SsaApplyOp, v: VReg, isDouble: bool) {$/;"	m
genGoto	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genGoto(i_old: SsaGoto) {$/;"	m
genGoto	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genGoto(target: SsaBlock) {$/;"	m
genGraph	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genGraph() -> SsaGraph {$/;"	m
genIc	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def genIc(memberRef: IrSpec) -> IcMethod {$/;"	m
genIf	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def genIf(key: int, block: SsaBlock) {$/;"	m
genIf	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genIf(b_old: SsaBlock, i_old: SsaIf) {$/;"	m
genIf	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genIf(i: SsaIf) {$/;"	m
genIfNull	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIfNull(i_old: SsaApplyOp, resultType: Type, nobj: SsaInstr, nullVal: Val, gen: SsaInstr -> SsaInstr) -> SsaInstr {$/;"	m
genInc	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genInc(expr: AutoExpr, pre: SsaInstr, env: VstSsaEnv) -> SsaInstr {$/;"	m
genInstr	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def genInstr(block: SsaBlock, i: SsaInstr) {$/;"	m
genInstrs	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genInstrs(b_old: SsaBlock) {$/;"	m
genIntCastF	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntCastF(i_old: SsaApplyOp) {$/;"	m
genIntCastF	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genIntCastF(i: SsaApplyOp, v: VReg, isDouble: bool) {$/;"	m
genIntCmp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntCmp(i_old: SsaApplyOp, infixH: IntType -> Operator, infixL: IntType -> Operator) -> SsaInstr {$/;"	m
genIntCmpRec	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntCmpRec(i_old: SsaApplyOp, tn: IntNorm, ai_new: Array<SsaInstr>, i: int, infixH: IntType -> Operator, infixL: IntType -> Operator) -> SsaInstr {$/;"	m
genIntDivOrMod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntDivOrMod(i_old: SsaApplyOp) {$/;"	m
genIntQueryF	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntQueryF(i_old: SsaApplyOp) {$/;"	m
genIntTruncF	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntTruncF(i_old: SsaApplyOp) {$/;"	m
genIntTruncF	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genIntTruncF(i: SsaApplyOp, v: VReg, isDouble: bool) {$/;"	m
genIntTruncFEqual	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntTruncFEqual(source: Source, ft: Type, itt: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
genIntViewI	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genIntViewI(i_old: SsaApplyOp) {$/;"	m
genIntViewI	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genIntViewI(i: SsaApplyOp, v: VReg) {$/;"	m
genJump	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def genJump(info: SsaIcBlock) {$/;"	m
genJump	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genJump(target: SsaBlock) {$/;"	m
genLazyEval	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genLazyEval(isAnd: bool, left: Expr, right: Expr, env: VstSsaEnv) -> SsaInstr {$/;"	m
genLoad	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genLoad(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genLoadAddr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genLoadAddr(i: SsaApplyOp, v: VReg, x: SsaInstr, scale: byte, disp: int) -> bool {$/;"	m
genLoadConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genLoadConst(t: Type, val: Val);	\/\/ arch-specific$/;"	m
genLoadConst	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def genLoadConst(t: Type, val: Val) {$/;"	m
genLoadLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genLoadLocal(v: VReg);		\/\/ arch-specific$/;"	m
genLoadLocal	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def genLoadLocal(v: VReg) {$/;"	m
genLoadLocalIntoReg	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genLoadLocalIntoReg(v: VReg, reg: int) {$/;"	m
genLoadLongConstIntoReg	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genLoadLongConstIntoReg(val: long, reg: int) {$/;"	m
genLoadRtAddr_i32	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def genLoadRtAddr_i32(addr: CiRuntime_Address) {$/;"	m
genMainInit	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genMainInit(asm: ArmMacroAssembler, frame: MachFrame) {$/;"	m
genMainInit	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genMainInit(frame: MachFrame) {$/;"	m
genMainInit	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genMainInit(frame: MachFrame) {$/;"	m
genMainStub	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genMainStub(asm: ArmMacroAssembler) {$/;"	m
genMoveLocLoc	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def genMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass) { context.unimplemented(); }$/;"	m
genMoveLocLoc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass);$/;"	m
genMoveLocLoc	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass) {$/;"	m
genMoveValLoc	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def genMoveValLoc(src: VReg, dst: (VReg, int), regClass: RegClass) { context.unimplemented(); }$/;"	m
genMoveValLoc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genMoveValLoc(vreg: VReg, dst: (VReg, int), regClass: RegClass);$/;"	m
genMoveValLoc	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genMoveValLoc(src: VReg, dst: (VReg, int), regClass: RegClass) {$/;"	m
genMoves	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def genMoves(alloc: int -> int, move: (int, int) -> void) {$/;"	m
genMtableLookup	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genMtableLookup(i_old: SsaApplyOp, oobj: SsaDfEdge, nobj: SsaInstr, funcRep: Mach_FuncRep, methodRef: IrSpec) -> SsaInstr {$/;"	m
genMul	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genMul(i: SsaApplyOp, v: VReg) {$/;"	m
genMultiBlock	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genMultiBlock(oldStart: SsaBlock, newStart: SsaBlock) {$/;"	m
genNewVar	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genNewVar(i_old: SsaNewVar) {$/;"	m
genNormRangeGetElem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNormRangeGetElem(i_old: SsaApplyOp, elem: int) {$/;"	m
genNormRangeSetElem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNormRangeSetElem(i_old: SsaApplyOp, elem: int) {$/;"	m
genNormTypedLoads	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNormTypedLoads(source: Source, nullity: Fact.set, machType: Type, base: SsaInstr, offset: int) -> Array<SsaInstr> {$/;"	m
genNormTypedStores	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNormTypedStores(i_old: SsaApplyOp, nullity: Fact.set, init: bool, machType: Type, base: SsaInstr, offset: int, vals: Array<SsaInstr>, start: int) {$/;"	m
genNullCheck	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNullCheck(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genNullCheck0	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genNullCheck0(source: Source, nobj: SsaInstr) {$/;"	m
genOp2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genOp2(name: string, i: SsaApplyOp, v: VReg, m: X86Assembler -> X86Op2) {$/;"	m
genParallelIntOp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genParallelIntOp(i_old: SsaApplyOp, infix: IntType -> Operator) {$/;"	m
genParams	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genParams(graph: SsaGraph) {$/;"	m
genPatternCond	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genPatternCond(keyType: Type, cur: SsaBuilder, pat: MatchPattern, origKey: SsaInstr, key: SsaInstr) -> SsaInstr {$/;"	m
genPhi	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genPhi(phi: SsaPhi) {$/;"	m
genPhi	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genPhi(i_old: SsaPhi) {$/;"	m
genPhi1	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genPhi1(i_old: SsaPhi) -> SsaInstr {$/;"	m
genPhis	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def genPhis() {$/;"	m
genPop	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genPop(v: VReg);			\/\/ arch-specific$/;"	m
genPop	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def genPop(v: VReg) {$/;"	m
genRangeQuery	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genRangeQuery(i_old: SsaApplyOp, low: int, high: int, val: SsaInstr) -> SsaInstr {$/;"	m
genReadModifyWrite	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genReadModifyWrite(source: Source, lval: Expr, modify: (SsaInstr, VstSsaEnv) -> SsaInstr, env: VstSsaEnv) -> (SsaInstr, SsaInstr) {$/;"	m
genReceiver	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genReceiver(expr: Expr, env: VstSsaEnv) -> SsaInstr {$/;"	m
genRef	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def genRef(ref: SsaDfEdge) -> int {$/;"	m
genRef1	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genRef1(e: SsaDfEdge) -> SsaInstr {$/;"	m
genRefs	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genRefs(a: Array<SsaDfEdge>) -> Array<SsaInstr> {$/;"	m
genRegRegMove	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genRegRegMove(src: int, dst: int) {$/;"	m
genReload	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genReload(src: VReg, dst: (VReg, int)) {$/;"	m
genRestore	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genRestore(dst: (VReg, int), slot: int) {$/;"	m
genRestoreLocal	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def genRestoreLocal(v: VReg, reg: int) { context.unimplemented(); }$/;"	m
genRestoreLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genRestoreLocal(v: VReg, reg: int);$/;"	m
genRestoreLocal	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genRestoreLocal(v: VReg, loc: int) {$/;"	m
genReturn	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genReturn(oldRet: SsaReturn) {$/;"	m
genReturn	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def genReturn(oi: SsaReturn) {$/;"	m
genReturn	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genReturn(i_old: SsaReturn) {$/;"	m
genReturn	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genReturn(i: SsaReturn) {$/;"	m
genRiInit	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genRiInit(asm: ArmMacroAssembler, frame: MachFrame) {$/;"	m
genRiInit	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genRiInit(frame: MachFrame) {$/;"	m
genRiInit	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genRiInit(frame: MachFrame) {$/;"	m
genSaveLocal	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def genSaveLocal(reg: int, v: VReg) { context.unimplemented(); }$/;"	m
genSaveLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genSaveLocal(reg: int, v: VReg);$/;"	m
genSaveLocal	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def genSaveLocal(loc: int, v: VReg) {$/;"	m
genScript	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def genScript() {$/;"	m
genSetInterval	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genSetInterval(scalar: SsaInstr, value: SsaInstr, interval: Interval, ft: Type, tt: IntRepType) -> SsaInstr {$/;"	m
genShadowStackAlloc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genShadowStackAlloc(shadow_sp: VReg, slots: int) {$/;"	m
genShadowStackFree	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genShadowStackFree(shadow_sp: VReg, slots: int) {$/;"	m
genShadowStackRestore	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int) {$/;"	m
genShadowStackSave	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genShadowStackSave(shadow_sp: VReg, v: VReg, slot: int) {$/;"	m
genShift	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genShift(name: string, i: SsaApplyOp, v: VReg, shifter: X86Shifter) {$/;"	m
genShiftOp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genShiftOp(i_old: SsaApplyOp) {$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genSigHandlerInstall(asm: ArmAssembler, signo: int, handler: Addr);$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr);$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr);$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr) {$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr) {$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr);$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr) {$/;"	m
genSigHandlerInstall	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def genSigHandlerInstall(signo: int, handler: Addr) {$/;"	m
genSigInstalls	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genSigInstalls(asm: ArmAssembler) {$/;"	m
genSigInstalls	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genSigInstalls() {$/;"	m
genSigInstalls	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genSigInstalls() {$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genSignalHandlerStub() {$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genSignalHandlerStub();$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def genSignalHandlerStub() {$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def genSignalHandlerStub() {$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def genSignalHandlerStub() {$/;"	m
genSignalHandlerStub	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def genSignalHandlerStub() {$/;"	m
genSimpleVal	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genSimpleVal(tn: TypeNorm, v: Val) -> Val {$/;"	m
genSimpleVal	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genSimpleVal(v: Val, tn: TypeNorm) -> Val;$/;"	m
genSimpleVal	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genSimpleVal(tn: TypeNorm, v: Val) -> Val {$/;"	m
genSsa	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def genSsa(memberRef: IrSpec, depth: int) -> SsaGraph {$/;"	m
genSsaMoves	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def genSsaMoves(block: SsaBlock) {$/;"	m
genStmt	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genStmt(s: Stmt) {$/;"	m
genStore	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genStore(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genStoreAddr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genStoreAddr(i: SsaApplyOp, v: VReg, x: SsaInstr, scale: byte, disp: int, val: SsaInstr) -> bool {$/;"	m
genStoreLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genStoreLocal(v: VReg, pop: bool);	\/\/ arch-specific$/;"	m
genStoreLocal	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def genStoreLocal(v: VReg, pop: bool) {$/;"	m
genStub	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def genStub(name: string, t: (Addr, (Addr, MachDataWriter) -> void)) {$/;"	m
genSwitch	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genSwitch(b_old: SsaBlock, i_old: SsaSwitch) {$/;"	m
genSwitch	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genSwitch(i: SsaSwitch) {$/;"	m
genTestInputs	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genTestInputs(main: IrMethod, asm: ArmMacroAssembler, frame: MachFrame) {$/;"	m
genTestInputs	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genTestInputs(main: IrMethod, frame: MachFrame) {$/;"	m
genTestInputs	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genTestInputs(main: IrMethod, frame: MachFrame) {$/;"	m
genTestOutput	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def genTestOutput(asm: ArmMacroAssembler, frame: MachFrame);$/;"	m
genTestOutput	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def genTestOutput(main: IrMethod, frame: MachFrame);$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def genTestOutput(main: IrMethod, frame: MachFrame);$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def genTestOutput(main: IrMethod, frame: MachFrame) {$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	def genTestOutput(main: IrMethod, frame: MachFrame) {$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def genTestOutput(frame: MachFrame);$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def genTestOutput(frame: MachFrame) {$/;"	m
genTestOutput	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	def genTestOutput(frame: MachFrame) {$/;"	m
genThreePartFor	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genThreePartFor(loopNum: int, loopVar: VarDecl, cond: Expr, update: Expr, body: Stmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
genThrow	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def genThrow(oi: SsaThrow) {$/;"	m
genThrow	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genThrow(i_old: SsaThrow) {$/;"	m
genThrow	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genThrow(i: SsaThrow) {$/;"	m
genTruncateInPlace	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTruncateInPlace(i_old: SsaApplyOp, tt: IntType) -> SsaInstr {$/;"	m
genTruncatingIntOp	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTruncatingIntOp(i_old: SsaApplyOp) {$/;"	m
genTupleGetElem	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTupleGetElem(i_old: SsaApplyOp, index: int) {$/;"	m
genTypeCast	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTypeCast(i_old: SsaApplyOp, castOp: TypeCast) {$/;"	m
genTypeQuery	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTypeQuery(i_old: SsaApplyOp, query: TypeQuery) -> SsaInstr {$/;"	m
genTypeSubsume	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genTypeSubsume(i_old: SsaApplyOp) {$/;"	m
genUpdateVar	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genUpdateVar(i_old: SsaUpdateVar) {$/;"	m
genVal	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genVal(i_old: SsaConst, vec: Vector<SsaInstr>) {$/;"	m
genVal1	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genVal1(i_old: SsaConst) -> SsaInstr {$/;"	m
genValIntoArray	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genValIntoArray(v: Val, tn: TypeNorm, dest: Array<Val>, index: int);$/;"	m
genValN	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genValN(i_old: SsaConst, tn: TypeNorm, vec: Vector<SsaInstr>) {$/;"	m
genValN	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def genValN(i_old: SsaConst, tn: TypeNorm, vec: Vector<SsaInstr>);$/;"	m
genVarDecl	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genVarDecl(v: VarDecl) {$/;"	m
genVarRead	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genVarRead(obj: SsaInstr, binding: VarBinding, env: VstSsaEnv) -> SsaInstr {$/;"	m
genVarWrite	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def genVarWrite(varbind: VarBinding, varSource: Source, obj: SsaInstr, val: SsaInstr, checked: bool, env: VstSsaEnv) -> SsaInstr {$/;"	m
genVariantClassAlloc	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genVariantClassAlloc(vn: VariantNorm, ai_inputs: Array<SsaInstr>) -> Array<SsaInstr> {$/;"	m
genVariantDispatcher	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def genVariantDispatcher(m: IrMethod) {$/;"	m
genVariantGetField	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genVariantGetField(rc: RaClass, raField: RaField, vn: VariantNorm, ninputs: Array<SsaInstr>) -> Array<SsaInstr> {$/;"	m
genVariantGetMethod	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genVariantGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {$/;"	m
genVariantGetSelector	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genVariantGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {$/;"	m
genVariantGetTag	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genVariantGetTag(i_old: SsaApplyOp, nobj: SsaInstr) -> SsaInstr {$/;"	m
genVariantReplaceNull	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def genVariantReplaceNull(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
genVariantScalarView	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def genVariantScalarView(oldType: Type, newType: Type, i_scalar: SsaInstr) -> SsaInstr {$/;"	m
genWide	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWide(i: SsaApplyOp, orig: Operator, v: VReg) -> bool {$/;"	m
genWideArith	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideArith(i: SsaApplyOp, name: string, asm: (int, int, int, int, int, int) -> (), v: VReg) -> bool {$/;"	m
genWideDiv	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideDiv(i: SsaApplyOp, orig: Operator, v: VReg, mod: bool) -> bool {$/;"	m
genWideFloatRoundI	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideFloatRoundI(i: SsaApplyOp, orig: Operator, v: VReg, isDouble: bool) -> bool {$/;"	m
genWideIntCastF	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideIntCastF(i: SsaApplyOp, orig: Operator, v: VReg, isDouble: bool) -> bool {$/;"	m
genWideIntTruncF	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideIntTruncF(i: SsaApplyOp, orig: Operator, v: VReg, isDouble: bool) -> bool {$/;"	m
genWideIntViewF	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideIntViewF(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genWideMul	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideMul(i: SsaApplyOp, v: VReg) -> bool {$/;"	m
genWideShift	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def genWideShift(i: SsaApplyOp, name: string, shifter: X86Shifter, v: VReg) -> bool {$/;"	m
gen_add_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_add_i(dest: VReg, a: SsaInstr, imm: int) {$/;"	m
gen_br	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_br(cond: X86Cond, target: SsaBlock) {$/;"	m
gen_cmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_cmp(a: SsaInstr, b: SsaInstr) {$/;"	m
gen_cmp_a	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_cmp_a(a: SsaInstr, addr: Addr) {$/;"	m
gen_cmp_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_cmp_i(a: SsaInstr, imm: int) {$/;"	m
gen_d2i_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_d2i_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_d2l_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_d2l_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_d2ui_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_d2ui_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_d2ul_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_d2ul_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_d2ul_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_d2ul_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_entry	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_entry() {$/;"	m
gen_f2i_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_f2i_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_f2ui_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_f2ui_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_i64_divmod_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_i64_divmod_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int, op: WideDivision) {$/;"	f
gen_imul	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_imul (dest: VReg, a: SsaInstr, b: SsaInstr) {$/;"	m
gen_imul_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_imul_i(dest: VReg, a: SsaInstr, imm: int) {$/;"	m
gen_lea	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_lea(dest: VReg, base: SsaInstr, scale: byte, disp: int) {$/;"	m
gen_loada	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loada(dest: VReg, t: Type, addr: Addr) {$/;"	m
gen_loada_disp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loada_disp(dest: VReg, t: Type, addr: Addr, disp: SsaInstr) {$/;"	m
gen_loada_disp_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loada_disp_sse(dest: VReg, t: Type, addr: Addr, disp: SsaInstr, isDouble: bool) {$/;"	m
gen_loada_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loada_sse(dest: VReg, t: Type, addr: Addr, isDouble: bool) {$/;"	m
gen_loadx	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loadx(dest: VReg, t: Type, base: SsaInstr, scale: byte, disp: int, canTrap: bool, source: Source) {$/;"	m
gen_loadx_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_loadx_sse(dest: VReg, t: Type, base: SsaInstr, scale: byte, disp: int, isDouble: bool, canTrap: bool, source: Source) {$/;"	m
gen_neg	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_neg(dest: VReg, a: SsaInstr) {$/;"	m
gen_not	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_not(dest: VReg, a: SsaInstr) {$/;"	m
gen_op2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_op2(name: string, commutative: bool, m: X86Assembler -> X86Op2, dest: VReg, a: SsaInstr, b: SsaInstr) {$/;"	m
gen_op2_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_op2_i(name: string, m: X86Assembler -> X86Op2, dest: VReg, a: SsaInstr, imm: Val) {$/;"	m
gen_phi_dfn	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_phi_dfn(phi: SsaPhi) -> SsaLink {$/;"	m
gen_set	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_set(cond: X86Cond, a: VReg) {$/;"	m
gen_sse_bit_eq	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_bit_eq(dest: VReg, a: SsaInstr, b: SsaInstr, isDouble: bool) {$/;"	m
gen_sse_cmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_cmp(cond: X86Cond, dest: VReg, a: SsaInstr, b: SsaInstr, isDouble: bool) {$/;"	m
gen_sse_cvt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_cvt(name: string, m: (X86Assembler, SSEReg, SSERm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_f2i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_f2i(name: string, m: (X86MacroAssembler, X86Reg, SSERm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_fabs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_fabs(dest: VReg, a: SsaInstr, isDouble: bool) {$/;"	m
gen_sse_i2f	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_i2f(name: string, m: (X86MacroAssembler, SSEReg, X86Rm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_op2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_op2(name: string, m: (X86Assembler, SSEReg, SSERm) -> void, dest: VReg, a: SsaInstr, b: SsaInstr) {$/;"	m
gen_sse_round	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_round(name: string, m: (X86Assembler, SSEReg, SSERm, RoundingMode) -> void,$/;"	m
gen_sse_sqrt	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_sqrt(name: string, m: (X86Assembler, SSEReg, SSERm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_trunc	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_trunc(name: string, m: (X86MacroAssembler, X86Reg, SSERm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_view_double	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_view_double(name: string, m: (X86Assembler, SSEReg, SSERm) -> void, dest: VReg, a: SsaInstr, b: SsaInstr) {$/;"	m
gen_sse_view_float	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_view_float(name: string, m: (X86Assembler, SSEReg, X86Rm) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_sse_view_int	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_sse_view_int(name: string, m: (X86Assembler, X86Rm, SSEReg) -> void, dest: VReg, a: SsaInstr) {$/;"	m
gen_storex	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_storex(size: int, base: SsaInstr, scale: byte, disp: int, val: SsaInstr, canTrap: bool, source: Source) {$/;"	m
gen_storex_abs	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_storex_abs(size: int, addr: Addr, val: SsaInstr) {$/;"	m
gen_storex_abs_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_storex_abs_sse(addr: Addr, val: SsaInstr, isDouble: bool) {$/;"	m
gen_storex_i	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_storex_i(size: int, base: SsaInstr, scale: byte, disp: int, val: int, canTrap: bool, source: Source) -> bool {$/;"	m
gen_storex_sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gen_storex_sse(base: SsaInstr, scale: byte, disp: int, val: SsaInstr, isDouble: bool, canTrap: bool, source: Source) {$/;"	m
gen_ui2d_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_ui2d_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
gen_ui2f_fixup_stub	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def gen_ui2f_fixup_stub(mach: MachProgram, addr: Addr, w: MachDataWriter, codeStartOffset: int) {$/;"	f
generate	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def generate() -> SsaGraph {$/;"	m
generate	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def generate(m: IrMethod, frame: MachFrame) {$/;"	m
generate	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def generate() -> IcMethod {$/;"	m
generate	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def generate() -> SsaGraph {$/;"	m
generateVariantEquals	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def generateVariantEquals(t: Type) -> RaClass {$/;"	m
generated	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var generated: bool;$/;"	d
get	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def get<T>() -> T {$/;"	m
get	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def get(name: string, val: bool) -> bool {$/;"	m
get	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def get(graph: SsaGraph) -> SsaConst {$/;"	m
get	$VIRGIL/lib/util/List.v3	/^	def get<T>(list: List<T>, index: int) -> T {$/;"	f
get	$VIRGIL/lib/util/Option.v3	/^	def get() -> T { return val; }$/;"	m
get1	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def get1(i: SsaInstr) -> SsaInstr {$/;"	m
get1	$VIRGIL/aeneas/src/types/Type.v3	/^	def get1(hash: int, typeCon: TypeCon, t: Type) -> Type {$/;"	m
getAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def getAbbrev(a: DwarfAbbrevTag) -> u32 {$/;"	m
getAbs	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def getAbs(rt: MachRuntime) -> int {$/;"	m
getAccessAddress	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def getAccessAddress(siginfo: Pointer, ucontext: Pointer) -> Pointer {$/;"	f
getAlias	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def getAlias(n: int) -> int {$/;"	m
getAndCompareAllFields	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getAndCompareAllFields(rc: RaClass) {$/;"	m
getAndSetField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getAndSetField(rf: RaField) {$/;"	m
getArithWidth	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def getArithWidth(tt: IntType) -> ArithWidth {$/;"	m
getArrayElemOffset	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getArrayElemOffset(arrayType: Type, elem: int) -> int {$/;"	m
getArrayElemScale	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getArrayElemScale(arrayType: Type) -> int {$/;"	m
getArrayLengthOffset	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getArrayLengthOffset(arrayType: Type) -> int {$/;"	m
getAssignment	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def getAssignment(usepos: int) -> int {$/;"	m
getBitWidth	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def getBitWidth(t: Type) -> byte {$/;"	m
getBitWidth	$VIRGIL/aeneas/src/os/Linux.v3	/^	private def getBitWidth(compiler: Compiler, prog: Program, t: Type) -> byte {$/;"	m
getBitWidth	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	private def getBitWidth(compiler: Compiler, prog: Program, t: Type) -> byte {$/;"	m
getBool	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def getBool() -> bool {$/;"	m
getBoundType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getBoundType() -> Type {$/;"	m
getCRC	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def getCRC() -> int {$/;"	m
getClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getClass(t: Type) -> RaClass {$/;"	m
getClassAllocIr	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	private def getClassAllocIr(vn: VariantNorm) -> IrMethod {$/;"	m
getClosureReceiver	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getClosureReceiver() -> Type {$/;"	m
getClosureType	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def getClosureType(ic: IrClass, op: Operator, indexMap: Array<int>) -> Type {$/;"	m
getCodeAddress	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getCodeAddress(methodRef: IrSpec) -> Val {$/;"	m
getCodeStart	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def getCodeStart(e: SsaCfEdge) -> int {$/;"	m
getCommand	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def getCommand() -> string {$/;"	m
getComponentRecord	$VIRGIL/aeneas/src/core/Program.v3	/^	def getComponentRecord(comp: VstComponent) -> Record {$/;"	m
getComponentRecord	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	private def getComponentRecord(t: Type) -> Record {$/;"	m
getConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private def getConst(t: Type, v: Val, facts: Fact.set) -> SsaConst {$/;"	m
getDeclaredType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getDeclaredType() -> Type {$/;"	m
getDefaultTypeArgs	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def getDefaultTypeArgs() -> TypeArgs {$/;"	m
getDefaultVariantCaseType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getDefaultVariantCaseType(prog: Program, t: Type) -> Type {$/;"	f
getDepth	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def getDepth() -> int {$/;"	m
getDest	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def getDest() -> SsaInstr { return dest; }$/;"	m
getEdgeMap	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	private def getEdgeMap(i_old: SsaPhi, b_old: SsaBlock, b_new: SsaBlock) -> Array<int> {$/;"	m
getElem	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def getElem<T>(array: Array<T>, index: int) -> Array<T> {$/;"	m
getElemElemOffset	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getElemElemOffset(elem: int) -> int {$/;"	m
getElemElemType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getElemElemType(arrayType: Type, elem: int) -> Type {$/;"	m
getEnumSetType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getEnumSetType(t: Type) -> IntType {$/;"	f
getEnumSetType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getEnumSetType(tref: TypeRef, enumType: EnumType) -> Type {$/;"	m
getEquality	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getEquality(t: Type, context: IrSpec) {$/;"	m
getErrorType	$VIRGIL/aeneas/src/main/Error.v3	/^	def getErrorType() -> Type {$/;"	m
getErrorType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getErrorType() -> Type {$/;"	m
getErrorTypeCon	$VIRGIL/aeneas/src/main/Error.v3	/^	def getErrorTypeCon(name: string) -> TypeCon {$/;"	m
getErrorTypeNamed	$VIRGIL/aeneas/src/main/Error.v3	/^	def getErrorTypeNamed(name: string) -> Type {$/;"	m
getExceptionDest	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getExceptionDest(off: int, ex: string, source: Source) -> Addr {$/;"	m
getFPS	$VIRGIL/lib/term/Animator.v3	/^	def getFPS() -> u32 {$/;"	m
getFatalAddress	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getFatalAddress(ex: string) -> Addr {$/;"	m
getField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getField(rf: RaField) {$/;"	m
getField	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getField() -> VstField { return VstField.!(member); }$/;"	m
getFieldJvmType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def getFieldJvmType(f: IrField) -> JvmType {$/;"	m
getFieldType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getFieldType() -> Type { return instantiateType(IrField.!(member).fieldType); }$/;"	m
getFieldType	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def getFieldType(op: Operator, field: IrField) -> Type {$/;"	m
getFixed	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def getFixed(usepos: int) -> int {$/;"	m
getFlag	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def getFlag(flag: int) -> bool {$/;"	m
getForFunc	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def getForFunc(funcRep: Mach_FuncRep) -> MachCallConv {$/;"	f
getForFunc	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def getForFunc(mach: MachProgram, funcRep: Mach_FuncRep) -> MachCallConv {$/;"	f
getForFunc	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def getForFunc(mach: MachProgram, funcRep: Mach_FuncRep) -> MachCallConv {$/;"	f
getForFunc	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def getForFunc(mach: MachProgram, funcRep: Mach_FuncRep) -> MachCallConv {$/;"	f
getForGraph	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def getForGraph(graph: SsaGraph) -> MachCallConv {$/;"	f
getForGraph	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def getForGraph(mach: MachProgram, graph: SsaGraph) -> MachCallConv { \/\/ XXX: put Signature in SsaGraph$/;"	f
getForGraph	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def getForGraph(mach: MachProgram, graph: SsaGraph) -> MachCallConv { \/\/ XXX: put Signature in SsaGraph$/;"	f
getForGraph	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def getForGraph(mach: MachProgram, graph: SsaGraph) -> MachCallConv {$/;"	f
getForeachElemType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getForeachElemType(expr: Expr) -> Type {$/;"	m
getFrame	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def getFrame(ssa: SsaGraph) -> MachFrame {$/;"	m
getFrame	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def getFrame(ssa: SsaGraph) -> MachFrame {$/;"	m
getFrame	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def getFrame(ssa: SsaGraph) -> MachFrame {$/;"	m
getFuncRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getFuncRep(t: Type) -> Mach_FuncRep {$/;"	m
getFuncType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getFuncType() -> Type { return Function.funcRefType(getBoundType()); }$/;"	m
getIcMethod	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def getIcMethod(memberRef: IrSpec) -> IcMethod {$/;"	m
getIndexedWriteType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getIndexedWriteType(receiver: Type, member: VstMethod) -> Type {$/;"	m
getInputAndMaybeDead	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def getInputAndMaybeDead(v: SsaApplyOp) -> SsaInstr {$/;"	m
getInputs	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def getInputs(i: SsaInstr) -> Array<SsaDfEdge> {$/;"	m
getInt	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def getInt() -> (bool, int) {$/;"	m
getInterpreter	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def getInterpreter() -> (Closure, Array<Val>) -> Result {$/;"	m
getIntervalsForSize	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def getIntervalsForSize(s: byte) -> Array<Interval> {$/;"	m
getIp	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def getIp(ucontext: Pointer) -> Pointer {$/;"	f
getIrClass	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getIrClass(ctype: Type) -> IrClass {$/;"	m
getIrClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def getIrClass(vtype: Type) -> IrClass {$/;"	m
getIrSpec	$VIRGIL/aeneas/src/core/Eval.v3	/^def getIrSpec(member: IrMember, args: Arguments) -> IrSpec {$/;"	f
getJvmClass	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def getJvmClass(utype: Type) -> JvmClass {$/;"	m
getJvmIntType	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def getJvmIntType(tt: IntType) -> JvmType {$/;"	m
getListHead	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def getListHead(dest: SpecMethod) -> SpecEdge { return dest.useList; }$/;"	m
getListHead	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def getListHead(dest: SsaInstr) -> SsaDfEdge { return dest.useList; }$/;"	m
getListHead	$VIRGIL/lib/util/Edge.v3	/^	def getListHead(dest: T) -> Edge<T>;$/;"	m
getLoc	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def getLoc(o: Operand) -> (X86_64Reg, int) {$/;"	m
getLocalAddr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def getLocalAddr() -> InetAddress {$/;"	m
getLocalAddress	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def getLocalAddress() -> InetAddress;$/;"	m
getLongConstAddr	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getLongConstAddr(val: long) -> Addr {$/;"	m
getLowestN	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def getLowestN<T>(inputs: Array<T>, n: int) -> Array<T> {$/;"	m
getMain	$VIRGIL/aeneas/src/core/Program.v3	/^	def getMain() -> IrSpec {$/;"	m
getMark	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def getMark(i: SsaLink) -> int;$/;"	m
getMemberRef	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	private def getMemberRef(clname: string, fname: string, desc: string, isMethod: bool) -> int {$/;"	m
getMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getMethod(op: SsaApplyOp, rm: RaMethod) {$/;"	m
getMethod	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def getMethod() -> VstMethod { return VstMethod.!(member); }$/;"	m
getMethodID	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def getMethodID(memberRef: IrSpec) -> int {$/;"	m
getMethodType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getMethodType() -> Type {$/;"	m
getMinimumArithSize	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def getMinimumArithSize(width: int) -> IntType {$/;"	m
getN	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def getN(i: SsaInstr) -> Range<SsaInstr> {$/;"	m
getN	$VIRGIL/aeneas/src/types/Type.v3	/^	def getN(hash: int, typeCon: TypeCon, nested: List<Type>) -> Type {$/;"	m
getNameOperator	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def getNameOperator() -> Operator {$/;"	m
getNameOperator	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def getNameOperator() -> Operator {$/;"	m
getNames	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def getNames(prog: Program) -> Record {$/;"	m
getNames	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def getNames(prog: Program) -> Record {$/;"	m
getNewIrSpec	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def getNewIrSpec(ra: ReachabilityAnalyzer, rn: ReachabilityNormalizer) -> IrSpec {$/;"	m
getNode	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def getNode(loc: int) -> MoveNode {$/;"	m
getNormFieldsForCase	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def getNormFieldsForCase(rc: RaClass) -> Array<Type> {$/;"	m
getNormIndex	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def getNormIndex() -> int {$/;"	m
getObjectSize	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def getObjectSize(t: Type, r: Record) -> int {$/;"	m
getOutput	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def getOutput() -> ArchInstrBuffer {$/;"	m
getOutput	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def getOutput() -> ArchInstrBuffer {$/;"	m
getOutput	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def getOutput() -> ArchInstrBuffer {$/;"	m
getOutput	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def getOutput() -> ArchInstrBuffer {$/;"	m
getOutputFileName	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def getOutputFileName(fileName: string, ext: string) -> string {$/;"	m
getParallelMoveReg	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def getParallelMoveReg(rcl: RegClass, which: int) -> int {$/;"	m
getParallelMoveReg	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def getParallelMoveReg(rcl: RegClass, which: int) -> int {$/;"	m
getParallelMoveReg	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def getParallelMoveReg(rcl: RegClass, which: int) -> int {$/;"	m
getParamType	$VIRGIL/aeneas/src/types/Function.v3	/^	def getParamType(ftype: Type) -> Type {$/;"	f
getParamType	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def getParamType(param: ParamDecl) -> Type {$/;"	f
getParamTypeArray	$VIRGIL/aeneas/src/types/Function.v3	/^	def getParamTypeArray(ftype: Type) -> Array<Type> {$/;"	f
getParamTypeList	$VIRGIL/aeneas/src/types/Function.v3	/^	def getParamTypeList(ftype: Type) -> List<Type> {$/;"	f
getParamTypes	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getParamTypes() -> Array<Type> { return instantiateTypes(asMethod().sig.paramTypes); }$/;"	m
getParams	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getParams() -> List<ParamDecl> {$/;"	m
getProgram	$VIRGIL/aeneas/src/core/Eval.v3	/^	def getProgram() -> Program;$/;"	m
getProgram	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def getProgram() -> Program {$/;"	m
getProgram	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def getProgram() -> Program {$/;"	m
getProjections	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def getProjections(i: SsaApplyOp) -> Array<SsaInstr> {$/;"	m
getReceiver	$VIRGIL/aeneas/src/core/Eval.v3	/^def getReceiver(args: Arguments) -> Val {$/;"	f
getRecordReceiver	$VIRGIL/aeneas/src/core/Eval.v3	/^def getRecordReceiver(args: Arguments) -> Record {$/;"	f
getRelDepth	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def getRelDepth(bi: SsaBlockInfo) -> int {$/;"	m
getRep	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def getRep(utype: Type) -> JvmType {$/;"	m
getReplacements	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def getReplacements(i: SsaInstr) -> Array<SsaInstr> {$/;"	m
getResidualParamType	$VIRGIL/aeneas/src/core/Operator.v3	/^	def getResidualParamType(indexMap: Array<int>) -> Type {$/;"	m
getResidualParamTypeList	$VIRGIL/aeneas/src/core/Operator.v3	/^	def getResidualParamTypeList(indexMap: Array<int>) -> List<Type> {$/;"	m
getResidualType	$VIRGIL/aeneas/src/core/Operator.v3	/^	def getResidualType(indexMap: Array<int>) -> Type {$/;"	m
getReturnRange	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getReturnRange() -> FileRange {$/;"	m
getReturnType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getReturnType() -> Type { return instantiateType(asMethod().sig.returnType()); }$/;"	m
getReturnType	$VIRGIL/aeneas/src/types/Function.v3	/^	def getReturnType(ftype: Type) -> Type {$/;"	f
getReturnType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getReturnType() -> Type { \/\/ XXX: force callers to handle ReturnType.This$/;"	m
getRiExit	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getRiExit() -> IrMethod {$/;"	m
getRiGc	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getRiGc() -> IrMethod {$/;"	m
getRiInit	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getRiInit() -> IrMethod {$/;"	m
getRiSignal	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def getRiSignal() -> IrMethod {$/;"	m
getRoot	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	private def getRoot(index: int) -> IrMethod {$/;"	m
getRootType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getRootType(t: Type) -> Type {$/;"	f
getRuntime	$VIRGIL/aeneas/src/os/Linux.v3	/^	private def getRuntime(prog: Program) -> MachRuntime {$/;"	m
getRuntime	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def getRuntime(prog: Program) -> MachRuntime {$/;"	m
getRuntime	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	private def getRuntime(prog: Program) -> MachRuntime {$/;"	m
getRuntime	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	private def getRuntime(prog: Program) -> MachRuntime {$/;"	m
getScalar	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def getScalar(t: Type) -> Scalar.set {$/;"	m
getScalar	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	m
getScalar	$VIRGIL/aeneas/src/os/Linux.v3	/^	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	m
getScalar	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	m
getScalar	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	m
getScalar	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {$/;"	m
getScalarFromSet	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def getScalarFromSet(s: Scalar.set) -> Scalar {$/;"	f
getScalarPattern	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def getScalarPattern(s: Scalar) -> ScalarPattern {$/;"	m
getScopeVars	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def getScopeVars() -> Array<VarDecl> {$/;"	m
getSigIndex	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def getSigIndex(m: IrMethod) -> u32 {$/;"	m
getSockAddr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def getSockAddr() -> Array<byte>;$/;"	m
getSource	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def getSource(icm: IcMethod, ip: int) -> Source {$/;"	m
getSource	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def getSource(a: Array<Operand>) -> Source {$/;"	m
getSourceI	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def getSourceI(icm: IcMethod, ip: int, i: IcInstr) -> Source {$/;"	m
getSp	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def getSp(ucontext: Pointer) -> Pointer {$/;"	f
getSpec	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getSpec() -> IrSpec {$/;"	m
getStackTrace	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def getStackTrace() -> List<Source> {$/;"	m
getStackTrace	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def getStackTrace(source: Source) -> List<Source> {$/;"	m
getStringOffset	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def getStringOffset(str: string) -> int {$/;"	m
getStringRecord	$VIRGIL/aeneas/src/core/Program.v3	/^	def getStringRecord(sexpr: StringExpr) -> Record {$/;"	m
getSubprogramAbbrev	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def getSubprogramAbbrev(hasFile: bool, hasRet: bool) -> u32 {$/;"	m
getSuperType	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def getSuperType() -> RefType {$/;"	m
getSuperType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getSuperType(t: Type) -> Type {$/;"	f
getSuperType	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def getSuperType() -> ClassType {$/;"	m
getSyntheticComponent	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getSyntheticComponent() -> VstComponent {$/;"	m
getSyntheticVariantType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getSyntheticVariantType(t: Type, vcase: VstCaseMember) -> Type {$/;"	f
getSystemFileID	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def getSystemFileID(fd: int) -> int {$/;"	m
getTagLength	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	private def getTagLength(numCases: int) -> byte {$/;"	m
getTagLength	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def getTagLength(numCases: int) -> byte {$/;"	f
getTagType	$VIRGIL/aeneas/src/vst/Vst.v3	/^def getTagType(caseCount: int) -> IntType {$/;"	f
getTarget	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def getTarget(name: string) -> Target {$/;"	f
getThisParam	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def getThisParam() -> SsaInstr {$/;"	m
getTmpSpill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def getTmpSpill(regClass: RegClass) -> int {$/;"	m
getTopMethod	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def getTopMethod() -> IcMethod {$/;"	m
getTotal	$VIRGIL/lib/util/IO.v3	/^	def getTotal() -> int {$/;"	m
getType	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def getType() -> Type;$/;"	m
getType	$VIRGIL/aeneas/src/types/Int.v3	/^	def getType(signed: bool, width: int) -> IntType {$/;"	f
getType	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	def getType(scalar: Scalar) -> IntRepType {$/;"	f
getType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def getType() -> Type;$/;"	m
getType	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def getType() -> Type {$/;"	m
getTypeArg	$VIRGIL/aeneas/src/core/Eval.v3	/^	def getTypeArg(i: int) -> Type;$/;"	m
getTypeArg	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def getTypeArg(i: int) -> Type {$/;"	m
getTypeArg	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def getTypeArg(i: int) -> Type {$/;"	m
getTypeArgs	$VIRGIL/aeneas/src/core/Eval.v3	/^	def getTypeArgs() -> Array<Type>;$/;"	m
getTypeArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def getTypeArgs() -> Array<Type> {$/;"	m
getTypeArgs	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def getTypeArgs() -> TypeArgs {$/;"	m
getTypeArgs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def getTypeArgs() -> Array<Type> {$/;"	m
getTypeArgs	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getTypeArgs(t: Type) -> TypeArgs {$/;"	f
getTypeArgs	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def getTypeArgs() -> TypeArgs {$/;"	m
getTypeCon	$VIRGIL/aeneas/src/types/Int.v3	/^	def getTypeCon(signed: bool, width: int) -> Int_TypeCon {$/;"	f
getTypeFromScalarSet	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^def getTypeFromScalarSet(s: Scalar.set, usePacking: bool) -> Type {$/;"	f
getTypeRef	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def getTypeRef(t: Type, pos: int) -> int {$/;"	m
getTypes	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getTypes() -> IrSpecTypes {$/;"	m
getTypes	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def getTypes(useTagScalar: bool) -> Array<Type> {$/;"	m
getULEB32Size	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def getULEB32Size(x: u32) -> u32 {$/;"	m
getUnboundType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def getUnboundType() -> Type {$/;"	m
getUnsafe	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def getUnsafe(name: string) -> bool {$/;"	m
getUtf8	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	private def getUtf8(bytes: string) -> JvmCpe_Utf8 {$/;"	m
getVReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def getVReg(i: SsaInstr) -> VReg {$/;"	m
getVal	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def getVal(i: SsaInstr) -> Val {$/;"	m
getVar	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def getVar(usepos: int) -> VReg {$/;"	m
getVariantTag	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getVariantTag(t: Type) -> int {$/;"	f
getVariantTagType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def getVariantTagType(t: Type) -> IntType {$/;"	f
getVirtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def getVirtual(rm: RaMethod) {$/;"	m
getVreg	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def getVreg(loc: int) -> VReg {$/;"	m
getVstFile	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def getVstFile(fileName: string) -> VstFile {$/;"	m
getWordShiftCount	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def getWordShiftCount(inputs: Array<SsaInstr>, tt: IntType, tn: IntNorm) -> int {$/;"	m
getWriter	$VIRGIL/lib/util/IO.v3	/^	def getWriter() -> DataWriter {$/;"	m
getfield	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def getfield(jclass: JvmClass, fname: string, jtype: JvmType) {$/;"	m
getsockname	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def getsockname(sockfd: int, sockAddr: Array<byte>) -> NetResult<void> {$/;"	f
getstatic	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def getstatic(jclass: JvmClass, fname: string, jtype: JvmType) {$/;"	m
gettimeofday	$VIRGIL/rt/x86-64-darwin/System.v3	/^	private def gettimeofday() -> (long, long) {$/;"	f
global	$VIRGIL/aeneas/src/core/Program.v3	/^	var global: Type;$/;"	d
globalCache	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def globalCache = TypeCache.new();$/;"	d
globalProbes	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def globalProbes  = IcProbes.new(); \/\/ container for any global probes$/;"	d
globalType	$VIRGIL/aeneas/src/core/Program.v3	/^	def globalType() -> Type {$/;"	m
global_timer_set	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def global_timer_set(timestamp: i64) -> i64;						\/\/ I U Ry Rt C T$/;"	f
goto_bw	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def goto_bw(pos: int) {$/;"	m
goto_fw	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def goto_fw() -> int {$/;"	m
gpr	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def gpr(name: string, r: Arm64Gpr, allocatable: bool) -> byte {$/;"	f
gpr	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def gpr(name: string, r: X86_64Gpr, allocatable: bool) -> byte {$/;"	f
gpr	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def gpr(a: SsaInstr) -> int {$/;"	m
gprCount	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def gprCount = 31; \/\/ x0-x30$/;"	d
gprStart	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private var gprStart = cursor;$/;"	d
gpr_start	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private var gpr_start = cursor;$/;"	d
graph	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var graph: Graph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	var graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private var graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var graph: SsaGraph;$/;"	d
graph	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var graph: SsaGraph;$/;"	d
green	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def green<T>(fmt: string, a: T) { color(CTRL_GREEN, fmt, a); }$/;"	f
group	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var group = 0;$/;"	d
grow	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def grow(delta: int) -> int {$/;"	m
grow	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def grow(size: int) {$/;"	m
grow	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def grow(len: int) -> this {$/;"	m
grow	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private def grow() {$/;"	m
grow	$VIRGIL/lib/util/Arrays.v3	/^	def grow<T>(array: Array<T>, size: int) -> Array<T> {$/;"	f
grow	$VIRGIL/lib/util/BitMatrix.v3	/^	def grow(nrows: int) -> this {$/;"	m
grow	$VIRGIL/lib/util/DataWriter.v3	/^	def grow(nlength: int) -> this {$/;"	m
grow	$VIRGIL/lib/util/StringBuilder.v3	/^	def grow(nlength: int) -> this {$/;"	m
grow	$VIRGIL/lib/util/Vector.v3	/^	def grow(nlength: int) -> this {$/;"	m
growI2X	$VIRGIL/lib/util/DataWriter.v3	/^	private def growI2X(nlength: int) -> this {$/;"	m
growToN	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def growToN<T>(inputs: Array<T>, n: int, extend: T) -> Array<T> {$/;"	m
growV	$VIRGIL/lib/util/Arrays.v3	/^	def growV<T>(array: Array<T>, nlength: int, val: T) -> Array<T> {$/;"	f
growVals	$VIRGIL/aeneas/src/core/Eval.v3	/^	def growVals(size: int) -> Array<Val> {$/;"	m
gvn	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def gvn = Gvn.new(graph);$/;"	d
half	$VIRGIL/lib/math/Math.v3	/^def half	= [0.5, -0.5];$/;"	d
handleBreakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def handleBreakpoint(args: string, on: bool) {$/;"	m
handleCommand	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def handleCommand(command: DbgCommand, args: string) -> bool {$/;"	m
hard	$VIRGIL/aeneas/src/types/Type.v3	/^	def hard: bool;  \/\/ whether the constraint is hard$/;"	d
has	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def has(i: SsaInstr) -> bool {$/;"	m
has	$VIRGIL/lib/util/Map.v3	/^	def has(key: K) -> bool;$/;"	m
has1	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def has1(i: SsaInstr) -> bool {$/;"	m
hasExplicitTag	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def hasExplicitTag() -> bool { return explicitTag != EMPTY_INTERVAL; }$/;"	m
hasExplicitTag	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def hasExplicitTag() -> bool { return tag != null; }$/;"	m
hasImplicitTag	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def hasImplicitTag() -> bool { return false; }$/;"	m
hasInput	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def hasInput(x: SsaInstr, i: SsaInstr) -> bool {$/;"	m
hasIntervals	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var hasIntervals = false;$/;"	d
hasNoTag	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def hasNoTag() -> bool { return tag == null; }$/;"	m
hasPhis	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def hasPhis() -> bool {$/;"	m
hasPred	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def hasPred() -> bool {$/;"	m
hasSuffix	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def hasSuffix() -> bool {$/;"	m
hasTagScalar	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var hasTagScalar = false;$/;"	d
hasTypeVars	$VIRGIL/aeneas/src/types/Type.v3	/^	def hasTypeVars() -> bool { return (hash & TypeConst.TYPEVAR_MASK) != 0; }$/;"	m
hash	$VIRGIL/aeneas/src/core/Program.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/core/Value.v3	/^	def hash(v: Val) -> int {$/;"	f
hash	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def hash() -> int { return caseIdx * 31 + fieldIdx; }$/;"	m
hash	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private def hash(t: Type, v: Val) -> int {$/;"	m
hash	$VIRGIL/aeneas/src/types/Function.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/types/Int.v3	/^	def hash(val: long) -> int {$/;"	f
hash	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/types/Type.v3	/^	def hash: int;		\/\/ hash and bits indicating openness$/;"	d
hash	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def hash() -> int {$/;"	m
hash	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var hash = Array<int>.new(INITIAL);$/;"	d
hash	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def hash(begin: int, len: int) -> int {$/;"	m
hash	$VIRGIL/lib/util/Arrays.v3	/^	def hash<T>(h0: int, array: Array<T>, hash: T -> int) -> int {$/;"	f
hash	$VIRGIL/lib/util/Map.v3	/^	def hash: K -> int;$/;"	d
hash	$VIRGIL/lib/util/Strings.v3	/^	def hash(str: string) -> int {$/;"	f
hashNext	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var hashNext: MoveNode;	\/\/ next in hash chain$/;"	d
hashVstCompound	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^def hashVstCompound(c: VstCompound) -> int {$/;"	f
hashVstMethod	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^def hashVstMethod(m: VstMethod) -> int {$/;"	f
hashval	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var hashval: int;$/;"	d
header	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var header: MachO_Header;$/;"	d
header	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def header: SsaBlock;	\/\/ start of loop (ends with loop condition)$/;"	d
headerMark	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def headerMark = ++graph.markGen;$/;"	d
headerSize	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var headerSize: int;$/;"	d
heapBuilder	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var heapBuilder: JvmClassfileBuilder;$/;"	d
heapSize	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var heapSize = CLOptions.HEAP_SIZE.get();$/;"	d
hexMap_l	$VIRGIL/lib/util/Chars.v3	/^	def hexMap_l = "0123456789abcdef";$/;"	d
hexMap_u	$VIRGIL/lib/util/Chars.v3	/^	def hexMap_u = "0123456789ABCDEF";$/;"	d
hexValue	$VIRGIL/aeneas/src/util/Char.v3	/^	def hexValue(ch: byte) -> int {$/;"	f
hexValue	$VIRGIL/lib/util/Chars.v3	/^	def hexValue(ch: byte) -> int {$/;"	f
hideCursor	$VIRGIL/lib/term/Vt100.v3	/^	def hideCursor = esc("[?25l");$/;"	d
high_pc	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var high_pc: u32;$/;"	d
highestNonZeroDigit	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	private def highestNonZeroDigit() -> int {$/;"	m
highestOneBit	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def highestOneBit() -> int {$/;"	m
hint	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var hint: byte;			\/\/ physical register hint$/;"	d
hint	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def hint(src: SsaInstr, dest: VReg) {$/;"	m
hintVar	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def hintVar(src: VReg, dest: VReg) {$/;"	m
hiword	$VIRGIL/lib/math/Math.v3	/^def hiword(x: double) -> int {$/;"	f
hoistLoopRemaindersInDomTree	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def hoistLoopRemaindersInDomTree(bi: SsaBlockInfo) {$/;"	m
horizontalChar	$VIRGIL/lib/term/Vt100.v3	/^def horizontalChar = '\x71'; \/\/ 196$/;"	d
huge	$VIRGIL/lib/math/Math.v3	/^def huge	= 1.0e+300;$/;"	d
i2b	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def i2b() {$/;"	m
i2d	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def i2d() {$/;"	m
i2f	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def i2f() {$/;"	m
i2l	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def i2l() {$/;"	m
i2xf	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def i2xf(isDouble: bool) {$/;"	m
i32_count	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var i32_count = 0;$/;"	d
i64_count	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var i64_count = 0;$/;"	d
i_const	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def i_const(v: int) -> SsaInstr {$/;"	m
ibuf	$VIRGIL/lib/term/Vt100.v3	/^def ibuf = [ESC, '[', SP, SP, SP, SP];$/;"	d
ic0	$VIRGIL/lib/ic/ic0_untyped.v3	/^import component ic0 {$/;"	n
icMon	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var icMon: (IrSpec, IcMethod) -> void;	 \/\/ monitor for IC generation$/;"	d
icall	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def icall(a: X86Rm) { emitb_rm(0xFF, a, 2); } \/\/ indirect call$/;"	m
icall_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def icall_m(a: X86_64Addr) -> this {$/;"	m
icall_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def icall_r(a: X86_64Gpr) -> this {$/;"	m
icm	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var icm: IcMethod;$/;"	d
icmList	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	var icmList: List<IcMethod>;$/;"	d
iconst	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def iconst(val: int) {$/;"	m
iconst_0	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def iconst_0() {$/;"	m
iconst_1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def iconst_1() {$/;"	m
icount	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var icount: Array<int>;		\/\/ per-instruction count$/;"	d
idMark	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var idMark: int;$/;"	d
ident	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def ident: VstIdent<void>;$/;"	d
identify	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def identify(loc: int) -> string {$/;"	m
idiv	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def idiv(b: X86Rm) { emitb_rm(0xF7, b, 7); } \/\/ signed divide (output in edx:eax)$/;"	m
idiv_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def idiv_m(b: X86_64Addr) -> this {$/;"	m
idiv_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def idiv_r(b: X86_64Gpr) -> this {$/;"	m
idivmod_checked	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def idivmod_checked(source: Source, zeroCheck: bool, negCheck: bool, a: X86Rm, div: bool) {$/;"	m
iinc	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def iinc(index: int, val: int) {$/;"	m
ijmp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ijmp(a: X86Rm) { emitb_rm(0xFF, a, 4); } \/\/ indirect jump$/;"	m
ijmp_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ijmp_m(a: X86_64Addr) -> this {$/;"	m
ijmp_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ijmp_r(a: X86_64Gpr) -> this {$/;"	m
illegal	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def illegal() { emitbb(0x0F, 0xFF); }$/;"	m
image	$VIRGIL/lib/util/Token.v3	/^	def image: string;$/;"	d
implicitFuncType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var implicitFuncType: Type;$/;"	d
implicitType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var implicitType: Type;$/;"	d
impls	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var impls: List<RaMethod>;	\/\/ list of all implementations$/;"	d
importName	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var importName: Token;$/;"	d
importName	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def importName(s: string) -> this {$/;"	m
impure	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var impure = SsaLoadedFields.new();$/;"	d
imul	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def imul(b: X86Rm) { emitb_rm(0xF7, b, 5); } \/\/ signed multiply (output in edx:eax)$/;"	m
imul_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def imul_m(b: X86_64Addr) -> this {$/;"	m
imul_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def imul_r(b: X86_64Gpr) -> this {$/;"	m
imul_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def imul_r_i(a: X86_64Gpr, i: int) -> this {$/;"	m
imul_r_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def imul_r_i(a: X86Reg, i: int) {$/;"	m
imul_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def imul_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
imul_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def imul_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
imul_r_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def imul_r_rm(a: X86Reg, b: X86Rm) { emitbb_rm(0x0F, 0xAF, b, a.index); } \/\/ signed multiply$/;"	m
inLoop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def inLoop(a: SsaBlock, loop: SsaLoopInfo) -> bool {$/;"	m
inRunMain	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var inRunMain: bool;$/;"	d
inSameBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def inSameBlock(i: SsaInstr) -> bool {$/;"	m
inSameBlock	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def inSameBlock(i: SsaInstr) -> bool {$/;"	m
inShadowStack	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var inShadowStack: bool;$/;"	d
inbounds	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var inbounds: List<(SsaInstr, SsaInstr)>;$/;"	d
inc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def inc(a: X86Rm) {$/;"	m
incErrors	$VIRGIL/aeneas/src/main/Error.v3	/^	def incErrors() {$/;"	m
inc_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def inc_m(a: X86_64Addr) -> this {$/;"	m
inc_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def inc_r(a: X86_64Gpr) -> this {$/;"	m
indent	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var indent: int;$/;"	d
indent	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var indent: int;$/;"	d
indent	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def indent(i: int) {$/;"	m
index	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var index: u32;$/;"	d
index	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var index: int;$/;"	d
index	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var index = -1;		\/\/ index into the appropriate members list$/;"	d
index	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def index: int;$/;"	d
index	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def index: int;$/;"	d
index	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var index: int;$/;"	d
index	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def index: int;$/;"	d
index	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var index: int = -1;$/;"	d
index	$VIRGIL/aeneas/src/types/Type.v3	/^	var index: int;$/;"	d
index	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var index: int;$/;"	d
indirect	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def indirect() -> X86_64Addr {$/;"	m
indirect	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def indirect() -> X86Addr {$/;"	m
indirectAdapters	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def indirectAdapters = Vector<(Signature, u32, IrMethod)>.new();$/;"	d
inferClosedType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def inferClosedType(expr: Expr) -> Type {$/;"	m
inferFieldType	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def inferFieldType(fdecl: VstField) -> Type {$/;"	m
inferFuncExprBodyType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def inferFuncExprBodyType(expr: Expr, expected: Type) -> Type {  \/\/ TODO$/;"	m
inferIntegralType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def inferIntegralType(expr: Expr, op: string) -> IntType {$/;"	m
inferMemberType	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def inferMemberType(member: VstMember) -> Type {$/;"	m
inferPackingExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def inferPackingExpr(env: VarEnvironment, expr: VstPackingExpr) -> byte {$/;"	m
inferType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def inferType(expr: Expr, outerType: Type) -> Type {$/;"	m
info	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def info = DwarfInfoSection.new(abbrev);$/;"	d
info	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var info: Array<byte>;$/;"	d
info	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def info(b: SsaBlock) -> SsaBlockInfo {$/;"	m
infoInputs	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def infoInputs() {$/;"	m
infoLocals	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def infoLocals() {$/;"	m
infoVal	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def infoVal(infoIdx: Array<int>) -> bool {$/;"	m
info_start	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var info_start: int;$/;"	d
inheritedField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def inheritedField(rf: RaField) -> bool {$/;"	m
inherits	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def inherits(m: IrMember) -> bool {$/;"	m
init	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def init(getFrame: SsaGraph -> MachFrame) {$/;"	m
init	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def init(m: IrSpec, args: Array<Val>) {$/;"	m
init	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def init = Vector<IrMethod>.new();$/;"	d
init	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def init() -> bool {$/;"	m
init	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def init: SsaInstr;	\/\/ I$/;"	d
init	$VIRGIL/aeneas/src/v3/Mangle.v3	/^	def init(c: byte, d: byte) {$/;"	f
init	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var init: Expr;$/;"	d
init	$VIRGIL/lib/util/Option.v3	/^	def init: T;$/;"	d
initEnv	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var initEnv: MethodEnv;$/;"	d
initFacts	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var initFacts = Facts.V_DEFAULT;$/;"	d
initField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def initField(op: SsaApplyOp, rf: RaField) {$/;"	m
initField	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	var initField: VstField;$/;"	d
initFrame	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def initFrame() {$/;"	m
initGraph	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def initGraph() {$/;"	m
initIndex	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var initIndex = -2;$/;"	d
initMax	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var initMax: int;$/;"	d
initOf	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def initOf(member: VstMember, block: SsaBuilder) -> SsaInstr {$/;"	m
initOrder	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	var initOrder: int;$/;"	d
initOrder	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var initOrder: int;$/;"	d
initPrev	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	var initPrev: MethodEnv;$/;"	d
initSig	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var initSig: JvmSig;$/;"	d
initStackRedZone	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def initStackRedZone(start: Pointer, end: Pointer) -> (Pointer, Pointer) {$/;"	f
initState	$VIRGIL/aeneas/src/core/Program.v3	/^	var initState: Array<InitState>;$/;"	d
initState	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def initState(size: int) {$/;"	m
initialSplitBasedOnOperators	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def initialSplitBasedOnOperators(m: IrItem, poly: SpecSet) {$/;"	m
initprot	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var initprot: int;$/;"	d
inits	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var inits: List<IrMethod>;$/;"	d
inl_isx	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def inl_isx(width: byte) { \/\/ int sign-extend$/;"	m
inl_izx	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def inl_izx(width: byte) { \/\/ int zero-extend$/;"	m
inl_lsx	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def inl_lsx(width: byte) { \/\/ long sign-extend$/;"	m
inl_lzx	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def inl_lzx(width: byte) { \/\/ long zero-extend$/;"	m
inl_u2l	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def inl_u2l() {  \/\/ convert U32 to long$/;"	m
inline	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def inline(genDepth: int) {$/;"	m
inlineComplex	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def inlineComplex(targetStart: SsaBlock) {$/;"	m
inlineEntries	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var inlineEntries: List<(int, Source, int)>;$/;"	d
inlineGoto	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def inlineGoto(from: SsaBlockInfo, target: SsaBlockInfo) -> bool {$/;"	m
inlineOrBranchTo	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def inlineOrBranchTo(from: SsaBlockInfo, target: SsaBlockInfo, context: CfgContext) {$/;"	m
inlineSimple	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def inlineSimple(targetStart: SsaBlock) {$/;"	m
inlinedInstrs	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var inlinedInstrs: int;$/;"	d
inlinee	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def inlinee: IrSpec;$/;"	d
inlines	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var inlines = 0;$/;"	d
inner	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var inner: bool;$/;"	d
input	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	var input: Array<byte>;$/;"	d
input	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def input = file.input;			\/\/ data being parsed$/;"	d
input0	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def input0() -> SsaInstr { return inputs[0].dest; }$/;"	m
input1	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def input1() -> SsaInstr { return inputs[1].dest; }$/;"	m
inputs	$VIRGIL/aeneas/src/core/Program.v3	/^	var inputs: Array<Array<byte>>;		\/\/ the input data$/;"	d
inputs	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var inputs: Array<SsaDfEdge>;	\/\/ inputs to this instruction, if any$/;"	d
insert	$VIRGIL/lib/util/Edge.v3	/^	private def insert(dest: T) {$/;"	m
insert	$VIRGIL/lib/util/Map.v3	/^	private def insert(bucket: Bucket<K, V>) {$/;"	m
insertBefore	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def insertBefore(p: LsraPoint, n: LsraPoint) {$/;"	m
insertBefore	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def insertBefore(t: SsaLink) {$/;"	m
insertBreakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def insertBreakpoint(fileName: string, line: int) -> bool {$/;"	m
insertBreakpointM	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def insertBreakpointM(vstCompound: VstCompound, vstMethod: VstMethod, line: int) -> bool {$/;"	m
insertBreakpointVst	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def insertBreakpointVst(vstCompound: VstCompound, line: int) -> bool {$/;"	m
insertEndVarAtLoopEnd	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def insertEndVarAtLoopEnd(vnum: int, t: (int, LsraPoint)) {$/;"	m
insertHead	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def insertHead(n: LsraPoint) {$/;"	m
insertLoadConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertLoadConst(t: Type, val: Val, next: ArchInstr) {$/;"	m
insertLoadLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertLoadLocal(v: VReg, next: ArchInstr) {$/;"	m
insertLoads	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def insertLoads = Vector<(ArchInstr, int, int)>.new();$/;"	d
insertLoadsAfter	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def insertLoadsAfter(sji: SsaJvmInstr, loads: List<SsaInstr>) {$/;"	m
insertLoadsAfter	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def insertLoadsAfter(height: int, start: int) {$/;"	m
insertMoveLocLoc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass, next: ArchInstr) {$/;"	m
insertMoveValLoc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertMoveValLoc(src: VReg, dst: (VReg, int), regClass: RegClass, next: ArchInstr) {$/;"	m
insertPoint	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def insertPoint = Vector<ArchInstr>.new();$/;"	d
insertPop	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertPop(v: VReg, next: ArchInstr) {$/;"	m
insertReload	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def insertReload(vreg: VReg, node: Node) {$/;"	m
insertReload	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertReload(src: VReg, dst: (VReg, int), next: ArchInstr) {$/;"	m
insertRestore	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertRestore(dst: (VReg, int), slot: int, next: ArchInstr) {$/;"	m
insertRestore	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def insertRestore(vreg: VReg, next: ArchInstr) {$/;"	m
insertRestoreLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertRestoreLocal(v: VReg, reg: int, next: ArchInstr) {$/;"	m
insertRestoreVarNum	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def insertRestoreVarNum(varNum: int, t: (ArchInstr, SsaBlock, \/*succs*\/Array<SsaCfEdge>, \/*killRow*\/BitMatrixRow)) {$/;"	m
insertSSVarNum	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def insertSSVarNum(varNum: int, t: (ArchInstr, ArchInstr)) {$/;"	m
insertSaveLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertSaveLocal(reg: int, v: VReg, next: ArchInstr) {$/;"	m
insertShadowStackAlloc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertShadowStackAlloc(shadow_sp: VReg, slots: int, next: ArchInstr) {$/;"	m
insertShadowStackFree	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertShadowStackFree(shadow_sp: VReg, slots: int, next: ArchInstr) {$/;"	m
insertShadowStackRestore	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {$/;"	m
insertShadowStackSave	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertShadowStackSave(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {$/;"	m
insertSpill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def insertSpill(block: SsaBlock, i: ArchInstr) {$/;"	m
insertSpillCleanup	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def insertSpillCleanup() {$/;"	m
insertSpillInit	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def insertSpillInit() {$/;"	m
insertStoreLocal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def insertStoreLocal(v: VReg, pop: bool, next: ArchInstr) {$/;"	m
insertThrow	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def insertThrow(next: SsaLink, source: Source, exception: string, vt: Type) -> SsaInstr {$/;"	m
insertps_s_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def insertps_s_s_i(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
inside	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def inside() -> int {$/;"	m
install	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def install(prog: Program, mach: MachProgram) {$/;"	f
install	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def install(prog: Program) {$/;"	f
install	$VIRGIL/aeneas/src/x86/DarwinModule.v3	/^	def install(prog: Program, is64: bool) {$/;"	f
installHandler	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	def installHandler(signum: int) {$/;"	f
instanceof	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def instanceof(jtype: JvmType) {$/;"	m
instances	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var instances: List<Record>;		\/\/ list of live records$/;"	d
instances	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var instances: List<Record>;$/;"	d
instantiateIrSpec	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def instantiateIrSpec(spec: IrSpec) -> IrSpec {$/;"	m
instantiateType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def instantiateType(t: Type) -> Type {$/;"	m
instantiateTypes	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def instantiateTypes(t: Array<Type>) -> Array<Type> {$/;"	m
instantiations	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var instantiations: List<SpecMethod>;	\/\/ instantiations of the method$/;"	d
instr	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var instr: SsaInstr;		\/\/ the ssa instruction$/;"	d
instr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var instr: SsaInstr;$/;"	d
instrColor	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def instrColor() -> this {$/;"	m
instrMap	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def instrMap: SsaMap = SsaMap.new();$/;"	d
instrUidColor	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def instrUidColor() -> this {$/;"	m
instrVal	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var instrVal: SsaInstr;		\/\/ fast mapping of instr->instr$/;"	d
instrs	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def instrs = Vector<JvmHI>.new();$/;"	d
instrs	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var instrs: Array<SsaJvmInstr>;	\/\/ per-instruction info$/;"	d
instrs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def instrs = Vector<ArchInstr>.new();$/;"	d
instrs	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var instrs = Array<SsaInstr>.new(32);$/;"	d
instrs	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def instrs = Vector<SsaLink>.new();$/;"	d
intBinop	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intBinop(op: Operator, opcode: IntBinop, trunc: bool, dst: int, args: Array<int>) {$/;"	m
intBinopS	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intBinopS(op: Operator, signed_opcode: IntBinop, unsigned_opcode: IntBinop, trunc: bool, dst: int, args: Array<int>) {$/;"	m
intCmpOpcode	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def intCmpOpcode(i: SsaApplyOp) -> int {$/;"	m
intCompare	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intCompare(op: Operator, signed_opcode: IntCompare, unsigned_opcode: IntCompare, dst: int, args: Array<int>) {$/;"	m
intConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def intConst(v: int) -> SsaConst {$/;"	m
intConvert32	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intConvert32(ft: IntType, tt: IntType, dst: int, arg: int) -> bool {$/;"	m
intConvert64	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intConvert64(ft: IntType, tt: IntType, dst: int, arg: int) -> bool {$/;"	m
intFacts	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def intFacts(v: int) -> Fact.set {$/;"	f
intK	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def intK(i: int) -> this {$/;"	m
intK	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def intK(i: int) { \/\/ software interrupt$/;"	m
intMask	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def intMask = (1 << width) - 1;$/;"	d
intNorm	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def intNorm: IntNormalizer;$/;"	d
intNorm	$VIRGIL/aeneas/src/os/Linux.v3	/^	def intNorm: IntNormalizer;$/;"	d
intOpWidth	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def intOpWidth(i: SsaApplyOp) -> byte {$/;"	m
intTrunc	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intTrunc(dst: int, arg: int, signed: bool, width: int) -> bool {$/;"	m
intWidth	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def intWidth(t: Type) -> int {$/;"	m
int_truncd	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def int_truncd(a: X86Reg, b: SSERm) {$/;"	m
int_truncf	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def int_truncf(a: X86Reg, b: SSERm) {$/;"	m
intbinop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def intbinop(i: SsaApplyOp) -> int {$/;"	m
interfere	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var interfere = Vector<int>.new(); \/\/ sorted$/;"	d
interfereCnt	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var interfereCnt: int = 0;$/;"	d
interpreter	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var interpreter: SsaInterpreter;$/;"	d
interval	$VIRGIL/lib/term/Animator.v3	/^	private var interval: u32;    \/\/ 1000000 \/ target frames per second$/;"	d
intervals	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var intervals: Array<Interval>; \/\/ null, if no packing$/;"	d
intfs	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def intfs   = Vector<int>.new(); \/\/ XXX: remove JvmClassfile interfaces?$/;"	d
inttype	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var inttype: IntType;	\/\/ if this is an integer operation, the result type$/;"	d
invalid	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def invalid() -> this { emitbb(0x0F, 0x0B); }$/;"	m
invalidOpcode	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def invalidOpcode(opcode: int) {$/;"	m
inverse	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def inverse(op: byte) -> byte {$/;"	m
inverse	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def inverse() -> BoundOp {$/;"	m
invln2	$VIRGIL/lib/math/Math.v3	/^def invln2	= 1.44269504088896338700e+0;		\/* 3FF71547 652B82FE *\/$/;"	d
invoke	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def invoke(del: Closure, args: Array<Val>) -> Result {$/;"	m
invoke	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def invoke(del: Closure, args: Array<Val>) -> Result {$/;"	m
invoke	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def invoke(del: Closure, args: Array<Val>) -> Result {$/;"	m
invoke_sig	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var invoke_sig: JvmSig;$/;"	d
invokespecial	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def invokespecial(clname: string, mname: string, sig: JvmSig) {$/;"	m
invokestatic	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def invokestatic(clname: string, mname: string, sig: JvmSig) {$/;"	m
invokesystem	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def invokesystem(name: string, sig: JvmSig) {$/;"	m
invokesystem	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def invokesystem(code: JvmCodeBuilder, name: string, sig: JvmSig) {$/;"	m
invokevirtual	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def invokevirtual(clname: string, mname: string, sig: JvmSig) {$/;"	m
iopt	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def iopt = SsaInstrReducer.new(context);$/;"	d
ipReg	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var ipReg: Arm64Gpr;$/;"	d
ipReg	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var ipReg: X86_64Gpr;$/;"	d
iret	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def iret() -> this { emitb(0xCF); }$/;"	m
iret	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def iret() { emitb(0xCF); } \/\/ return from interrupt$/;"	m
is64	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def is64() -> bool {$/;"	m
is64	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def is64(loc: int) -> bool {$/;"	m
is64	$VIRGIL/aeneas/src/types/Float.v3	/^	def is64 = total_width == 64;$/;"	d
is64	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def is64(src: int, dst: int) -> bool {$/;"	m
isArray	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isArray(t: Type) -> bool { return ArrayType.?(t); }$/;"	f
isArrayOrRange	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isArrayOrRange(t: Type) -> bool { return ArrayType.?(t) || RangeType.?(t); }$/;"	f
isAssignable	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def isAssignable(src: Type, dest: Type) -> bool {$/;"	m
isAssignable	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isAssignable(compound: VstCompound) -> bool {$/;"	m
isAssignableFrom	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isAssignableFrom(decl: VstField, compound: VstCompound) -> bool {$/;"	m
isBinary	$VIRGIL/aeneas/src/util/Char.v3	/^	def isBinary(ch: byte) -> bool {$/;"	f
isBinary	$VIRGIL/lib/util/Chars.v3	/^	def isBinary(ch: byte) -> bool {$/;"	f
isBlockEnd	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def isBlockEnd(i: IcInstr) -> bool {$/;"	m
isBound	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var isBound = false;$/;"	d
isBreakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def isBreakpoint(instr: SsaInstr) -> bool {$/;"	m
isCallerStack	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isCallerStack(loc: int) -> bool {$/;"	m
isCast0	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def isCast0(conversion: Conversion) -> bool {$/;"	f
isClass	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isClass(t: Type) -> bool { return ClassType.?(t); }$/;"	f
isComponent	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isComponent(t: Type) -> bool { return t != null && V3Component_TypeCon.?(t.typeCon); } \/\/ TODO$/;"	f
isConnected	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var isConnected = false;$/;"	d
isConst	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def isConst() -> bool      { return facts.F_VALUE; }$/;"	m
isConst	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isConst() -> bool {$/;"	m
isConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isConst() -> bool {$/;"	m
isDecimal	$VIRGIL/aeneas/src/util/Char.v3	/^	def isDecimal(ch: byte) -> bool {$/;"	f
isDecimal	$VIRGIL/lib/util/Chars.v3	/^	def isDecimal(ch: byte) -> bool {$/;"	f
isDominator	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def isDominator(a: SsaBlockInfo, b: SsaBlockInfo) -> bool {$/;"	m
isDouble	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isDouble(t: Type) -> bool {$/;"	f
isEndBlock	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def isEndBlock(bi: SsaBlockInfo) -> bool {$/;"	m
isEndEntry	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def isEndEntry: bool;$/;"	d
isEnum	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def isEnum(t: Type) -> bool {$/;"	m
isEnum	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def isEnum() -> bool { return size == 1 && tag != null && fields.length == 0; }$/;"	m
isEnum	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isEnum(t: Type) -> bool { return EnumType.?(t); }$/;"	f
isEnum	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def isEnum() -> bool {$/;"	m
isEnum	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isEnum() -> bool { return VstEnum.?(this); }$/;"	m
isEnumCase	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def isEnumCase() -> bool { return size == 1 && tag != null && tagValue >= 0 && fields.length == 0; }$/;"	m
isEnumSet	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isEnumSet(t: Type) -> bool { return EnumSetType.?(t); }$/;"	f
isEnumToSet	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isEnumToSet(xt: Type, yt: Type) -> bool {$/;"	f
isFalseConst	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def isFalseConst(i: SsaInstr) -> bool {$/;"	f
isFileScope	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var isFileScope: bool;$/;"	d
isFunction	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isFunction(t: Type) -> bool { return FuncType.?(t); }$/;"	f
isHex	$VIRGIL/aeneas/src/util/Char.v3	/^	def isHex(ch: byte) -> bool {$/;"	f
isHex	$VIRGIL/lib/util/Chars.v3	/^	def isHex(ch: byte) -> bool {$/;"	f
isIdentMiddle	$VIRGIL/aeneas/src/util/Char.v3	/^	def isIdentMiddle(ch: byte) -> bool {$/;"	f
isIdentStart	$VIRGIL/aeneas/src/util/Char.v3	/^	def isIdentStart(ch: byte) -> bool {$/;"	f
isImm	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isImm() -> bool { return tag == 1; }$/;"	m
isImmediatelyAfter	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def isImmediatelyAfter(a: SsaBlock, b: SsaBlock) -> bool {$/;"	m
isImport	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var isImport: bool;$/;"	d
isInLoop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def isInLoop(a: SsaBlock, loop: int) -> bool {$/;"	m
isInRegSet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isInRegSet(loc: int, snum: int) -> bool {$/;"	m
isIndexed	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isIndexed() -> bool {$/;"	m
isIntPromotable	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isIntPromotable(x: IntType, y: IntType) -> bool {$/;"	f
isIntToLong	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isIntToLong(ft: IntType, tt: IntType) -> bool {$/;"	f
isInterfere	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def isInterfere(x: int, y: int) -> bool {$/;"	m
isListening	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var isListening = false;$/;"	d
isLive	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def isLive(ic: IrClass) -> bool {$/;"	f
isLive	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isLive() -> bool {$/;"	m
isLive	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isLive(i: SsaLink, block: SsaBlock) -> bool {$/;"	m
isLocal	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isLocal() -> bool {$/;"	m
isLong	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^def isLong(t: Type) -> bool {$/;"	f
isMethod	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def isMethod() -> bool { return IrMethod.?(member); }$/;"	m
isMixed	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def isMixed() -> bool {$/;"	m
isMultiBlock	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def isMultiBlock() -> bool {$/;"	m
isMultiple	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isMultiple(loc: int) -> bool {$/;"	m
isNan32	$VIRGIL/aeneas/src/types/Float.v3	/^	def isNan32(bits: u32) -> bool {$/;"	f
isNan64	$VIRGIL/aeneas/src/types/Float.v3	/^	def isNan64(bits: u64) -> bool {$/;"	f
isNew	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def isNew() -> bool { return IrMethod.?(member) && member.facts.M_NEW; }$/;"	m
isNewSourceLine	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def isNewSourceLine(source: Source) -> bool {$/;"	m
isNonTrivialInitializer	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def isNonTrivialInitializer(fdecl: VstField) -> bool {$/;"	m
isNonTrivialStore	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def isNonTrivialStore(init: bool, v: SsaInstr) -> bool {$/;"	m
isNonTrivialSuperclause	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def isNonTrivialSuperclause(superclause: SuperClause) -> bool {$/;"	m
isNopSubsume	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def isNopSubsume(ft: Type, tt: Type) -> bool {$/;"	m
isNormalType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isNormalType(t: Type) -> bool {$/;"	m
isOctal	$VIRGIL/aeneas/src/util/Char.v3	/^	def isOctal(ch: byte) -> bool {$/;"	f
isOk	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def isOk(loc: int, constraint: int) -> bool {$/;"	m
isOk	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def isOk(vreg: VReg, constraint: int) -> bool {$/;"	m
isOnlyEdge	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def isOnlyEdge() -> bool { return next == null && dest.useList == this; }$/;"	m
isOpen	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var isOpen = false;$/;"	d
isOverwritten	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def isOverwritten(loc: int) -> bool {$/;"	m
isPacked	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def isPacked() -> bool { return intervals != null; }$/;"	m
isPolymorphic	$VIRGIL/aeneas/src/core/Operator.v3	/^	def isPolymorphic() -> bool {$/;"	m
isPolymorphic	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def isPolymorphic() -> bool {$/;"	m
isPrivate	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isPrivate: bool;$/;"	d
isPromotable	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isPromotable(xt: Type, yt: Type) -> bool {$/;"	f
isPromotableToFloat	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isPromotableToFloat(xt: Type, y: FloatType) -> bool {$/;"	f
isPromote0	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def isPromote0(conversion: Conversion) -> bool {$/;"	f
isRange	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isRange(t: Type) -> bool { return RangeType.?(t); }$/;"	f
isReadOnly	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var isReadOnly: bool;$/;"	d
isRecursive	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isRecursive() -> bool { return recursive > 1; }$/;"	m
isRef	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isRef(v: VReg) -> bool {$/;"	m
isRef	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isRef(t: Type) -> bool { return RefType.?(t); }$/;"	f
isRefType	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	private def isRefType(t: Type) -> bool {$/;"	m
isRefType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def isRefType(t: Type) -> bool {$/;"	m
isReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isReg(loc: int) -> bool {$/;"	m
isRegSet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isRegSet(loc: int) -> bool {$/;"	m
isSSEReg	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def isSSEReg(loc: int) -> bool {$/;"	f
isSigned	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isSigned(op: Operator) -> bool {$/;"	m
isSigned	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isSigned(t: Type) -> bool {$/;"	f
isSigned	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def isSigned(i: SsaApplyOp, isReturn: bool) -> bool {$/;"	m
isStack	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def isStack(loc: int) -> bool {$/;"	m
isString	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isString(t: Type) -> bool { return t == stringType; }$/;"	f
isSubclass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def isSubclass(t: Type, u: Type) -> bool {$/;"	m
isSubsume0	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def isSubsume0(conversion: Conversion) -> bool {$/;"	f
isSubtype	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def isSubtype(xt: Type, yt: Type) -> bool {$/;"	f
isSucc	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def isSucc(block: SsaBlock, succs: Array<SsaCfEdge>) -> bool {$/;"	m
isSynthetic	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isSynthetic(ic: IrClass) -> bool {$/;"	m
isSynthetic	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var isSynthetic: bool;$/;"	d
isTrueConst	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def isTrueConst(i: SsaInstr) -> bool {$/;"	f
isTuple	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isTuple(t: Type) -> bool { return TupleType.?(t); }$/;"	f
isUdp	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def isUdp() -> bool {$/;"	m
isUnboxed	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isUnboxed() -> bool { return variantNorm != null; }$/;"	m
isUsable	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def isUsable(node: MoveNode) -> bool {$/;"	m
isUsedInThisInstr	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def isUsedInThisInstr(reg: byte) -> bool {$/;"	m
isUsedInThisInstr	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def isUsedInThisInstr(reg: byte) -> bool {$/;"	m
isUseless	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def isUseless(vtype: Type) -> bool {$/;"	m
isUselessArray	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def isUselessArray(vtype: Type) -> bool {$/;"	m
isV6	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var isV6: bool;$/;"	d
isValid	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def isValid(addr: Addr) -> bool {$/;"	m
isValidCodepoint	$VIRGIL/lib/util/Utf8.v3	/^	def isValidCodepoint(codepoint: u32) -> bool {$/;"	f
isVariant	$VIRGIL/aeneas/src/v3/V3.v3	/^	def isVariant(t: Type) -> bool { return t != null && t.typeCon.kind == Kind.VARIANT; }$/;"	f
isVariant	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def isVariant() -> bool {$/;"	m
isVariant	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isVariant() -> bool { return variantTag > NON_VARIANT; }$/;"	m
isVariantCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def isVariantCase() -> bool { return variantTag >= 0; }$/;"	m
isVirtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def isVirtual() -> bool {$/;"	m
isWhiteSpace	$VIRGIL/lib/util/Strings.v3	/^	def isWhiteSpace(c: byte) -> bool {$/;"	f
isWritten	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def isWritten() -> bool {$/;"	m
isWrittenInLoop	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def isWrittenInLoop(loopIndex: int) -> bool {$/;"	m
isZero	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def isZero() -> bool {$/;"	m
isZero	$VIRGIL/lib/util/BitMatrix.v3	/^	def isZero(row: int) -> bool {$/;"	m
is_binary	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var is_binary: bool;$/;"	d
is_float	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var is_float: bool;$/;"	d
is_hex	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var is_hex: bool;$/;"	d
is_negative	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var is_negative: bool;$/;"	d
is_octal	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var is_octal: bool;$/;"	d
isa	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def isa: u32;$/;"	d
ishift	$VIRGIL/aeneas/src/types/Int.v3	/^	def ishift = u5.view(32 - width);$/;"	d
iterate	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var iterate: int;$/;"	d
iterateBlocksBackward	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def iterateBlocksBackward(func: SsaBlockInfo -> void) {$/;"	m
iterateBlocksForward	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def iterateBlocksForward(func: SsaBlockInfo -> void) {$/;"	m
iterateInstructionsBackward	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def iterateInstructionsBackward(func: (SsaBlock, ArchInstr) -> void) {$/;"	m
iterateInstructionsForward	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def iterateInstructionsForward(func: (SsaBlock, ArchInstr) -> void) {$/;"	m
iterateloop	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def iterateloop(loop: SsaLoopInfo, endinstr: ArchInstr) {$/;"	m
jal	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def jal(target: u26) { w.put_b32be(0x0c000000 | target); }$/;"	m
jalr	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def jalr(rd: MipsReg, rs: MipsReg) { emit_r3(0x00000009, rd, rs, MipsReg.R0); }$/;"	m
jar	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def jar: bool;$/;"	d
jarFile	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var jarFile: JARFile;$/;"	d
java_lang_AbstractMethodError	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_AbstractMethodError		= JvmClass.new("java\/lang\/AbstractMethodError", jlo);$/;"	d
java_lang_ArithmeticException	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_ArithmeticException		= JvmClass.new("java\/lang\/ArithmeticException", jlo);$/;"	d
java_lang_ArrayIndexOutOfBoundsException	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_ArrayIndexOutOfBoundsException	= JvmClass.new("java\/lang\/ArrayIndexOutOfBoundsException", jlo);$/;"	d
java_lang_ClassCastException	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_ClassCastException		= JvmClass.new("java\/lang\/ClassCastException", jlo);$/;"	d
java_lang_Double	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Double				= JvmClass.new("java\/lang\/Double", jln);$/;"	d
java_lang_Exception	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Exception				= JvmClass.new("java\/lang\/Exception", jlo);$/;"	d
java_lang_Float	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Float				= JvmClass.new("java\/lang\/Float", jln);$/;"	d
java_lang_Integer	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Integer				= JvmClass.new("java\/lang\/Integer", jlo);$/;"	d
java_lang_Math	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Math				= JvmClass.new("java\/lang\/Math", jlo);$/;"	d
java_lang_NegativeArraySizeException	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_NegativeArraySizeException	= JvmClass.new("java\/lang\/NegativeArraySizeException", jlo);$/;"	d
java_lang_Object	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_Object				= JvmClass.new(jlo, null);$/;"	d
java_lang_String	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_String				= JvmClass.new("java\/lang\/String", jlo);$/;"	d
java_lang_System	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def java_lang_System				= JvmClass.new("java\/lang\/System", jlo);$/;"	d
jc_rel	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jc_rel(cond: X86_64Cond, offset: int) -> this {$/;"	m
jc_rel_addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jc_rel_addr(cond: X86_64Cond, m: X86_64Addr) -> this {$/;"	m
jc_rel_far	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jc_rel_far(cond: X86_64Cond, label: X86_64Label) -> this {$/;"	m
jc_rel_near	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jc_rel_near(cond: X86_64Cond, label: X86_64Label) -> this {$/;"	m
jge	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jge(off: int) { j(off, 0x7d, 0x8d); }$/;"	m
jheap	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var jheap: JvmHeap;$/;"	d
jle	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jle(off: int) { j(off, 0x7e, 0x8e); }$/;"	m
jln	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def jln = "java\/lang\/Number";$/;"	d
jlo	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def jlo = "java\/lang\/Object";$/;"	d
jmp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jmp(off: int) {$/;"	m
jmp_abs	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_abs(abs: int) -> this { emitbd(0xEA, abs); } \/\/ jump absolute$/;"	m
jmp_abs_addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_abs_addr(m: X86_64Addr) -> this {$/;"	m
jmp_rel	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_rel(offset: int) -> this {$/;"	m
jmp_rel_addr	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_rel_addr(m: X86_64Addr) -> this {$/;"	m
jmp_rel_far	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_rel_far(label: X86_64Label) -> this {$/;"	m
jmp_rel_near	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def jmp_rel_near(label: X86_64Label) -> this {$/;"	m
jmpd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jmpd(abs: int) { emitbd(0xEA, abs); } \/\/ jump absolute$/;"	m
jmpl_near	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def jmpl_near(cond: ArmCond, label: Label) {$/;"	m
jmpl_near	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def jmpl_near(cond: X86Cond, label: Label) {$/;"	m
jmpx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jmpx(cond: X86Cond, off: int) {$/;"	m
jmpx_addr	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def jmpx_addr(cond: ArmCond, addr: Addr) {$/;"	m
jmpx_addr	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def jmpx_addr(cond: X86Cond, addr: Addr) {$/;"	m
jna	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jna(off: int) { j(off, 0x76, 0x86); }$/;"	m
jnc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jnc(off: int) { j(off, 0x73, 0x83); }$/;"	m
jno	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jno(off: int) { j(off, 0x71, 0x81); }$/;"	m
jnp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jnp(off: int) { j(off, 0x7b, 0x8b); }$/;"	m
jns	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jns(off: int) { j(off, 0x79, 0x89); }$/;"	m
jnz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def jnz(off: int) { j(off, 0x75, 0x85); }$/;"	m
jrep	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var jrep: JvmTypeReps;$/;"	d
jumpRiGc	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def jumpRiGc() {$/;"	m
jumpRiGc	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def jumpRiGc(asm: X86MacroAssembler) {$/;"	m
jumpTables	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	var jumpTables: List<(int, Array<SsaCfEdge>)>;$/;"	d
jvmClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def jvmClass(vtype: Type) -> JvmClass { return jrep.getJvmClass(vtype); }$/;"	m
jvmClasses	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def jvmClasses = TypeUtil.newTypeMap<JvmClass>();$/;"	d
jvmComps	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def jvmComps   = Strings.newMap<Type>();$/;"	d
jvmKind	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def jvmKind(vtype: Type) -> JvmKind { return jvmType(vtype).kind; }$/;"	m
jvmOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def jvmOpt = OptionGroup.new("JVM TARGET", options);$/;"	d
jvmRecords	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var jvmRecords: Array<JvmHI_Record>;$/;"	d
jvmReps	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def jvmReps    = TypeUtil.newTypeMap<JvmType>();$/;"	d
jvmSig	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def jvmSig(t: Type) -> JvmSig { return builder.jprog.jvmSig(t); }$/;"	m
jvmSigs	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def jvmSigs = TypeUtil.newTypeMap<JvmSig>();$/;"	d
jvmType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def jvmType(vtype: Type) -> JvmType {$/;"	m
kernel	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	var kernel: Kernel;$/;"	d
kernel	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	var kernel: Kernel;$/;"	d
kernelCallReturnType	$VIRGIL/aeneas/src/os/Linux.v3	/^	def kernelCallReturnType: Type;$/;"	d
kernelbuf	$VIRGIL/rt/x86-64-darwin/RiOs.v3	/^	private def kernelbuf = Array<long>.new(4);$/;"	d
key	$VIRGIL/lib/util/Map.v3	/^	def key: K;$/;"	d
keyList	$VIRGIL/lib/util/Map.v3	/^	def keyList<K, V>(map: PartialMap<K, V>) -> List<K> {$/;"	f
keyType	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def keyType: Type;$/;"	d
keys	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var keys = Vector<byte>.new();$/;"	d
keys	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var keys = Array<string>.new(INITIAL);$/;"	d
kill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def kill(constraint: int) {$/;"	m
kill	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def kill(fixed: int) -> int {$/;"	m
kill	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def kill() {$/;"	m
kill	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def kill(f: IrField) {$/;"	m
killBlock	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def killBlock(block: SsaBlock) {$/;"	m
killContinuation	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def killContinuation() {$/;"	m
killInstr	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def killInstr(i: SsaInstr) -> SsaInstr {$/;"	m
killSuccs	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def killSuccs(edges: Array<SsaCfEdge>) {$/;"	m
killVar	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	private def killVar(x: SsaInstr, v: int) {$/;"	m
killsFromPred	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def killsFromPred(storeRow: BitMatrixRow, block: SsaBlock) {$/;"	m
killsFromSucc	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def killsFromSucc(block: SsaBlock, succs: Array<SsaCfEdge>) -> BitMatrixRow {$/;"	m
kind	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var kind: JvmKind;		\/\/ JVM kind of the result$/;"	d
kind	$VIRGIL/aeneas/src/types/Type.v3	/^	def kind: Kind;			\/\/ kind of the type constructor$/;"	d
kind	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var kind = Kind.CLASS;$/;"	d
kwClass	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def kwClass   = Array<byte>.new(KWMAP_SIZE);$/;"	d
kwError	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def kwError(p: ParserState, id: Token) {$/;"	f
kwIndex	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def kwIndex(s: string) -> int {$/;"	f
kwKeys	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def kwKeys    = Array<string>.new(KWMAP_SIZE);$/;"	d
l2d	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def l2d() {$/;"	m
l2f	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def l2f() {$/;"	m
l2i	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def l2i() {$/;"	m
l2xf	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def l2xf(isDouble: bool) {$/;"	m
l_const	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def l_const(v: long) -> SsaInstr {$/;"	m
l_suffix	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var l_suffix: bool;$/;"	d
label	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def label: Label;$/;"	d
label	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def label = Label.new();$/;"	d
label	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def label: Label;$/;"	d
labelUses	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	var labelUses: List<(int, Label)>;$/;"	d
labelUses	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	private var labelUses: List<(int, Label)>;$/;"	d
labels	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def labels = Vector<(Type, int)>.new();$/;"	d
langOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def langOpt = OptionGroup.new("LANGUAGE", options);$/;"	d
last	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var last: Array<SsaJvmInstr>;	\/\/ last instruction at each stack height$/;"	d
last	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var last: ArchInstr;$/;"	d
last	$VIRGIL/lib/util/BitMatrix.v3	/^	def last() -> BitMatrixRow {$/;"	m
lastByte	$VIRGIL/lib/util/Token.v3	/^	def lastByte() -> FileRange {$/;"	m
lastFrame	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var lastFrame: IcFrame;$/;"	d
lastLivepoint	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def lastLivepoint = Vector<ArchInstr>.new();$/;"	d
lastMethodOffset	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var lastMethodOffset: int = Int.MAX_VALUE;$/;"	d
layoutAllRecordsAndFuncs	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def layoutAllRecordsAndFuncs() {$/;"	m
layoutClass	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def layoutClass(rc: RaClass) {$/;"	m
layoutData	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def layoutData(w: MachDataWriter) {$/;"	m
layoutDecl	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def layoutDecl: VstLayout;$/;"	d
layoutExRegion	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def layoutExRegion(startAddr: int) -> int {$/;"	m
layoutMeta	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def layoutMeta(w: MachDataWriter) {$/;"	m
layoutMtable	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def layoutMtable(rv: RaVirtual) {$/;"	m
layoutRecord	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	private def layoutRecord(r: Record) {$/;"	m
layoutRuntime	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def layoutRuntime(w: MachDataWriter) {$/;"	m
layoutVal	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	private def layoutVal(val: Val) {$/;"	m
layoutVtable	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def layoutVtable(rc: RaClass) {$/;"	m
layouts	$VIRGIL/aeneas/src/core/Program.v3	/^	var layouts: HashMap<string, VstLayout>;$/;"	d
layouts	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def layouts = Vector<VstLayout>.new();$/;"	d
lbinop	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def lbinop(opcode: byte) {$/;"	m
lbu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def lbu(rd: MipsReg, rs: MipsReg, offset: u16) { emit_r2i(0x90000000, rd, rs, offset); }$/;"	m
lcmp	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def lcmp() {$/;"	m
lcmp	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def lcmp: bool;$/;"	d
lconst	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def lconst(val: long) {$/;"	m
ldc	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def ldc(cp_index: int) {$/;"	m
ldc2_w	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def ldc2_w(cp_index: int) {$/;"	m
ldmxcsr_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ldmxcsr_m(a: X86_64Addr) -> this {$/;"	m
ldrbsx	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ldrbsx(rd: ArmReg, rn: ArmReg, off: ArmSmallOffset) { emitlss(0x011000D0, rd, rn, off); }$/;"	m
ldrbzx	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ldrbzx(rd: ArmReg, rn: ArmReg, off: ArmOffset) { emitls(0x05500000, rd, rn, off); }$/;"	m
ldrd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrd_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrd_r_r_r_ex_i(rt: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: MemRegExtend, imm: u1) -> this {$/;"	m
ldrhsx	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ldrhsx(rd: ArmReg, rn: ArmReg, off: ArmSmallOffset) { emitlss(0x011000F0, rd, rn, off); }$/;"	m
ldrhzx	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ldrhzx(rd: ArmReg, rn: ArmReg, off: ArmSmallOffset) { emitlss(0x011000B0, rd, rn, off); }$/;"	m
ldrliterald_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrliterald_r_i(rt: Arm64Reg, imm: i19) -> this {$/;"	m
ldrliteralq_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrliteralq_r_i(rt: Arm64Reg, imm: i19) -> this {$/;"	m
ldrpostd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrpostd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrpostq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrpostq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrpred_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrpred_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrpreq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrpreq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
ldrq_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrq_r_r_r_ex_i(rt: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: MemRegExtend, imm: u1) -> this {$/;"	m
ldrunsignedd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrunsignedd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: u12) -> this {$/;"	m
ldrunsignedq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def ldrunsignedq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: u12) -> this {$/;"	m
ldrw	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def ldrw(rd: ArmReg, rn: ArmReg, off: ArmOffset) { emitls(0x05100000, rd, rn, off); }$/;"	m
lea	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def lea(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
lea	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def lea(a: X86Reg, b: X86Addr) { \/\/ load effective address$/;"	m
len	$VIRGIL/aeneas/src/vst/Vst.v3	/^	private var len = if(list != null, -1);$/;"	d
length	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def length() -> int { return Arrays.length(info); }$/;"	m
length	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def length: int;$/;"	d
length	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var length = 0;$/;"	d
length	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def length(paramType: Type) -> int {$/;"	f
length	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def length() -> int {$/;"	m
length	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def length() -> int {$/;"	m
length	$VIRGIL/lib/util/Arrays.v3	/^	def length<T>(array: Array<T>) -> int {$/;"	f
length	$VIRGIL/lib/util/List.v3	/^	def length<T>(list: List<T>) -> int {$/;"	f
length	$VIRGIL/lib/util/StringBuilder.v3	/^	def var length: int;$/;"	d
length	$VIRGIL/lib/util/Vector.v3	/^	var length: int;$/;"	d
lengthIndex	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def lengthIndex() -> int { return size - 1; }$/;"	m
lengthOffset	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var lengthOffset: int;$/;"	d
level	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def level = if(CLOptions.O3.val, 3, if(CLOptions.O2.val, 2, if(CLOptions.O1.val, 1, if(CLOptions.O0.val, 0, 1))));$/;"	d
lhu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def lhu(rd: MipsReg, rs: MipsReg, offset: u16) { emit_r2i(0x94000000, rd, rs, offset); }$/;"	m
limit	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def limit(t: Type, len: int) -> (Type, Array<Type>) {$/;"	m
limit	$VIRGIL/lib/util/DataReader.v3	/^	def var limit: int = data.length;	\/\/ read limit within array$/;"	d
limit	$VIRGIL/lib/util/TextReader.v3	/^	def var limit = data.length;		\/\/ limit within array$/;"	d
line	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def line: int;$/;"	d
line	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def line(at: int) -> int {$/;"	m
line	$VIRGIL/lib/util/TextReader.v3	/^	def var line: int;			\/\/ current line number$/;"	d
lineEndOffset	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	def lineEndOffset(line: int) -> int {$/;"	m
lineEnds	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	var lineEnds: Vector<int>;$/;"	d
lineEnds	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def lineEnds = file.lineEnds; 		\/\/ mapping of line # -> end byte offset$/;"	d
lineEnds	$VIRGIL/lib/util/TextReader.v3	/^	def var lineEnds = Vector<int>.new();$/;"	d
lineEntries	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def lineEntries = Vector<DwarfLineEntry>.new();$/;"	d
lineStartOffset	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	def lineStartOffset(line: int) -> int {$/;"	m
lineStrStart	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var lineStrStart: int;$/;"	d
link	$VIRGIL/aeneas/src/types/Type.v3	/^	var link: Type;		\/\/ used as a link in the hash bucket chain$/;"	d
linuxComponent	$VIRGIL/aeneas/src/os/Linux.v3	/^	def linuxComponent = Kernel_TypeCon.new(Kernel.LINUX, kernelCallReturnType);$/;"	d
list	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var list: List<SpecMethod>;$/;"	d
list	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	var list: List<(Opt, string, string)>;$/;"	d
list	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var list: List<SsaLoopNode>;$/;"	d
list	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	var list: List<IrMethod>; \/\/ only report instrumented methods$/;"	d
list	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def list() -> List<T> {$/;"	m
list	$VIRGIL/lib/util/Map.v3	/^	var list: List<V>;$/;"	d
listHead	$VIRGIL/lib/util/WorkQueue.v3	/^	private var listHead: WorkUnit;$/;"	d
listTail	$VIRGIL/lib/util/WorkQueue.v3	/^	private var listTail: WorkUnit;$/;"	d
listen	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	private def listen() -> NetResult<void> {$/;"	m
lit	$VIRGIL/lib/term/Vt100.v3	/^	private def lit(s: string) -> void -> void {$/;"	f
littleEndIndex	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def littleEndIndex() -> int {$/;"	m
live	$VIRGIL/aeneas/src/ir/Normalization.v3	/^def live(facts: RaFact.set) -> bool {$/;"	f
live	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def live(facts: RaFact.set) -> bool {$/;"	f
live	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var live  = Array<byte>.new(1 + gen.vars.length);$/;"	d
live	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var live: bool;		\/\/ used for marking dead code$/;"	d
liveClasses	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def liveClasses = Vector<RaClass>.new();$/;"	d
liveFields	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var liveFields: Array<IrSpec>;		\/\/ normalized fields$/;"	d
liveMethods	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var liveMethods = Vector<RaMethod>.new();$/;"	d
livePoint	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def livePoint() -> int {$/;"	m
livemap	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def livemap  = BitMatrix.new(gen.numLivePoints, vars.length);$/;"	d
liveness	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var liveness: BitMatrix;$/;"	d
liveness	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var liveness: BitMatrix;$/;"	d
liveoutRow	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var liveoutRow: int;$/;"	d
livepoints	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def livepoints = Vector<(SsaBlock, ArchInstr, Operand.RefMap)>.new();$/;"	d
ln2HI	$VIRGIL/lib/math/Math.v3	/^def ln2HI	= [$/;"	d
ln2LO	$VIRGIL/lib/math/Math.v3	/^def ln2LO 	= [$/;"	d
ln2_hi	$VIRGIL/lib/math/Math.v3	/^def ln2_hi = 6.93147180369123816490e-1;		\/* 3FE62E42 FEE00000 *\/$/;"	d
ln2_lo	$VIRGIL/lib/math/Math.v3	/^def ln2_lo = 1.90821492927058770002e-10;	\/* 3DEA39EF 35793C76 *\/$/;"	d
load	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def load(kind: JvmKind, index: int) {$/;"	m
load	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def load(obj: SsaInstr, m: IrMember, apply: SsaApplyOp) -> SsaInstr {$/;"	m
load	$VIRGIL/lib/util/Option.v3	/^	def load(from: Options) {$/;"	m
loadVRegOntoStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def loadVRegOntoStack(vreg: VReg, next: ArchInstr) {$/;"	m
load_store	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def load_store(op0: byte, opK: byte, index: int) {$/;"	m
loads	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var loads: List<SsaInstr>;	\/\/ loads inserted after instruction$/;"	d
loads	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def loads = Vector<Operand.Use>.new();$/;"	d
loc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def loc() -> int {$/;"	m
loc	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var loc: int;			\/\/ location of the node$/;"	d
loc	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def loc(usepos: int) -> int {$/;"	m
locLists	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def locLists = Vector<DwarfLocList>.new();$/;"	d
locToGprArr	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def locToGprArr = Array<Arm64Gpr>.new(gprCount + 1);$/;"	d
locToSfrArr	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def locToSfrArr = Array<Arm64Sfr>.new(sfrCount + 1); \/\/ TODO$/;"	d
loc_gpr	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def loc_gpr(frame: MachFrame, loc: int) -> X86_64Gpr {$/;"	m
loc_m	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def loc_m(loc: int) -> X86_64Addr {$/;"	m
loc_r	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def loc_r(frame: MachFrame, loc: int) -> ArmReg {$/;"	m
loc_r	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def loc_r(loc: int) -> X86_64Gpr {$/;"	m
loc_r	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def loc_r(loc: int) -> X86Reg {$/;"	m
loc_r	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def loc_r(frame: MachFrame, loc: int) -> X86Reg {$/;"	m
loc_rm	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def loc_rm(loc: int) -> X86Rm {$/;"	m
loc_rm	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def loc_rm(frame: MachFrame, loc: int) -> X86Rm {$/;"	m
loc_s	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def loc_s(loc: int) -> X86_64Xmmr {$/;"	m
loc_s	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def loc_s(loc: int) -> SSEReg {$/;"	m
loc_s	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def loc_s(frame: MachFrame, loc: int) -> SSEReg {$/;"	m
loc_sm	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def loc_sm(loc: int) -> SSERm {$/;"	m
loc_sm	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def loc_sm(frame: MachFrame, loc: int) -> SSERm {$/;"	m
localPort	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def var localPort: int;$/;"	d
localVars	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def localVars = Vector<Variables>.new();$/;"	d
localVars	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var localVars: Array<VarDecl>;$/;"	d
locals	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def locals(size: int) {$/;"	m
localsSize	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def localsSize(instance: bool) -> int {$/;"	m
location	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var location: int;$/;"	d
locations	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var locations: Array<Interval>;	\/\/ a series of intervals indicating the position of all bits$/;"	d
loclistMap	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def loclistMap = Vector<int>.new(); \/\/ Map to the index in loclist, start from 1.$/;"	d
loclistOffset	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var loclistOffset: int;$/;"	d
loclists	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def loclists = DwarfLocListsSection.new();$/;"	d
log	$VIRGIL/lib/math/Math.v3	/^	def log = log0;$/;"	d
log	$VIRGIL/lib/util/Ints.v3	/^	def log(i: u32) -> int {$/;"	f
log	$VIRGIL/lib/util/Longs.v3	/^	def log(i: u64) -> int {$/;"	f
log0	$VIRGIL/lib/math/Math.v3	/^def log0(x: double) -> double {$/;"	f
longConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def longConst(v: long) -> SsaConst {$/;"	m
longFacts	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def longFacts(v: long) -> Fact.set {$/;"	f
longMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var longMap: HashMap<long, Addr>;$/;"	d
long_truncfp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def long_truncfp(il: X86Rm, ih: X86Rm, a: SSERm, isDouble: bool) {$/;"	m
lookup	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def lookup(name: string) -> TypeCon {$/;"	m
lookupArrayExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupArrayExprMember(expr: VarExpr, arrayType: Type) -> VarBinding {$/;"	m
lookupArrayTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupArrayTypeMember(expr: VarExpr, arrayType: Type) -> VarBinding {$/;"	m
lookupBinding	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def lookupBinding(expr: VarExpr, outer: Type) -> VarBinding {$/;"	m
lookupCase	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	def lookupCase(name: string) -> VstCaseMember {$/;"	m
lookupCase	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def lookupCase(name: string) -> VstEnumCase {$/;"	m
lookupCastOrEqual	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupCastOrEqual(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupClassExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupClassExprMember(expr: VarExpr, classType: ClassType, useThis: bool) -> VarBinding {$/;"	m
lookupClassTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupClassTypeMember(expr: VarExpr, classType: ClassType) -> VarBinding {$/;"	m
lookupClassVirtual	$VIRGIL/aeneas/src/core/Eval.v3	/^def lookupClassVirtual(args: Arguments, object: Record, member: IrMember) -> IrSpec {$/;"	f
lookupComponentExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupComponentExprMember(expr: VarExpr, etype: Type, useThis: bool) -> VarBinding {$/;"	m
lookupComponentMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupComponentMember(expr: VarExpr, receiver: Expr, etype: Type, name: string) -> VarBinding {$/;"	m
lookupComponentTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupComponentTypeMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupEnumConstMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupEnumConstMember(expr: VarExpr, enumType: EnumType, vc: VstEnumCase) -> VarBinding {$/;"	m
lookupEnumExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupEnumExprMember(expr: VarExpr, enumType: EnumType, useThis: bool) -> VarBinding {$/;"	m
lookupEnumSetExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupEnumSetExprMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupEnumSetTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupEnumSetTypeMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupEnumTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupEnumTypeMember(expr: VarExpr, enumType: EnumType) -> VarBinding {$/;"	m
lookupExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupExprMember(expr: VarExpr, etype: Type, useThis: bool) -> VarBinding {$/;"	m
lookupField	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def lookupField(load: SsaInstr, receiver: SsaInstr, field: IrField) -> SsaInstr {$/;"	m
lookupFloatExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupFloatExprMember(expr: VarExpr, ft: FloatType) -> VarBinding {$/;"	m
lookupFloatTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupFloatTypeMember(expr: VarExpr, ft: FloatType) -> VarBinding {$/;"	m
lookupFsi	$VIRGIL/aeneas/src/types/Int.v3	/^	def lookupFsi(name: string, signed: bool) -> Int_TypeCon {$/;"	f
lookupInfix	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupInfix(infix: V3Infix, ltype: Type, rtype: Type) -> Operator {$/;"	m
lookupIntTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupIntTypeMember(expr: VarExpr, etype: IntType) -> VarBinding {$/;"	m
lookupLayoutFieldMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupLayoutFieldMember(expr: VarExpr, decl: VstLayoutField) -> VarBinding {$/;"	m
lookupLayoutMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupLayoutMember(expr: VarExpr, decl: VstLayout) -> VarBinding {$/;"	m
lookupMember	$VIRGIL/aeneas/src/core/Member.v3	/^	def lookupMember(t: Type, name: string) -> LookupResult { return LookupResult.None; }$/;"	m
lookupMember	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def lookupMember(t: Type, name: string) -> LookupResult {$/;"	m
lookupMember	$VIRGIL/aeneas/src/os/Kernel.v3	/^	def lookupMember(t: Type, name: string) -> LookupResult {$/;"	m
lookupMember	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def lookupMember(t: Type, name: string) -> LookupResult {$/;"	m
lookupPointerExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupPointerExprMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupPointerTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupPointerTypeMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupRangeExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupRangeExprMember(expr: VarExpr, rangeType: Type) -> VarBinding {$/;"	m
lookupRangeTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupRangeTypeMember(expr: VarExpr, arrayType: Type) -> VarBinding {$/;"	m
lookupRefExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupRefExprMember(expr: VarExpr, refType: RefType) -> VarBinding {$/;"	m
lookupRefTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupRefTypeMember(expr: VarExpr, refType: RefType) -> VarBinding {$/;"	m
lookupSuperMember	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def lookupSuperMember(name: string) -> ResolvedMember {$/;"	m
lookupToplevelType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def lookupToplevelType(name: string) -> TypeCon {$/;"	f
lookupTupleExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupTupleExprMember(expr: VarExpr, tupleType: Type) -> VarBinding {$/;"	m
lookupTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupTypeMember(expr: VarExpr, etype: Type) -> VarBinding {$/;"	m
lookupVar	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupVar(expr: VarExpr) -> VarBinding {$/;"	m
lookupVar	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def lookupVar(name: string, scopeStart: int) -> VarDecl {$/;"	m
lookupVariantCaseMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupVariantCaseMember(expr: VarExpr, variantType: ClassType) -> VarBinding {$/;"	m
lookupVariantExprMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupVariantExprMember(expr: VarExpr, variantType: ClassType, useThis: bool) -> VarBinding {$/;"	m
lookupVariantTypeMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def lookupVariantTypeMember(expr: VarExpr, variantType: ClassType) -> VarBinding {$/;"	m
lookupVariantVirtual	$VIRGIL/aeneas/src/core/Eval.v3	/^def lookupVariantVirtual(args: Arguments, object: Record, member: IrMember) -> IrSpec {$/;"	f
lookupswitch	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def lookupswitch(npairs: int) -> int {$/;"	m
loop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var loop: SsaLoopInfo;  \/\/ loop information, if this block is a loop header$/;"	d
loopBody	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def loopBody: SsaBlock; \/\/ first block of loop body$/;"	d
loopEdges	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var loopEdges: List<SsaCfEdge>;$/;"	d
loopEnd	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def loopEnd: SsaBlock;  \/\/ first block outside of loop$/;"	d
loopEnd	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var loopEnd: VstSsaMerge;$/;"	d
loopFallThru	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def loopFallThru(env: VstSsaEnv, loopEnv: VstSsaEnv) -> SsaInstr {$/;"	m
loopHeaders	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def loopHeaders = Array<SsaLoopInfo>.new(count);$/;"	d
loopNum	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var loopNum: int;	\/\/ loop number, computed by verifier$/;"	d
loopRemainder	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def loopRemainder = Vector<List<SsaBlockInfo>>.new();$/;"	d
loopStack	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var loopStack: List<int>;	\/\/ stack of nested loops$/;"	d
loopStack	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def loopStack = Vector<SsaLoopInfo>.new();$/;"	d
loopStart	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var loopStart: VstSsaMerge;$/;"	d
loopVar	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var loopVar: VstSsaVar;	\/\/ loop control variable$/;"	d
loop_remainder	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var loop_remainder: bool;$/;"	d
loops	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var loops: Vector<SsaLoopInfo>;$/;"	d
low3	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def low3 = byte.view(regnum & 0b111);$/;"	d
low_pc	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var low_pc: long;$/;"	d
lower	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def lower = unify0(UnificationDir.LOWER, _, _);$/;"	d
lowerLeftChar	$VIRGIL/lib/term/Vt100.v3	/^def lowerLeftChar  = '\x6d'; \/\/ 192$/;"	d
lowerParMove	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def lowerParMove(i: ArchInstr) {$/;"	m
lowerRightChar	$VIRGIL/lib/term/Vt100.v3	/^def lowerRightChar = '\x6a'; \/\/ 217$/;"	d
lowestMark	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var lowestMark: int;$/;"	d
loword	$VIRGIL/lib/math/Math.v3	/^def loword(x: double) -> u32 {$/;"	f
lpPassStart	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var lpPassStart: int;$/;"	d
lps	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var lps: Vector<(SsaBlock, ArchInstr, Operand.RefMap)>;$/;"	d
lshift	$VIRGIL/aeneas/src/types/Int.v3	/^	def lshift = u6.view(64 - width);$/;"	d
lsli	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def lsli(rd: ArmReg, rm: ArmReg, imm: u5) { mov(rd, ArmOperand.RegShlImm(rm, imm)); }$/;"	m
lslr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def lslr(rd: ArmReg, rm: ArmReg, sh: ArmReg) { mov(rd, ArmOperand.RegShlReg(rm, sh)); }$/;"	m
lsra	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var lsra: LinearScanRegAlloc;$/;"	d
lsri	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def lsri(rd: ArmReg, rm: ArmReg, imm: u5) { mov(rd, ArmOperand.RegShrImm(rm, imm)); }$/;"	m
lsrr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def lsrr(rd: ArmReg, rm: ArmReg, sh: ArmReg) { mov(rd, ArmOperand.RegShrReg(rm, sh)); }$/;"	m
lsuffix	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def lsuffix: bool;$/;"	d
ltArrayLength	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def ltArrayLength(index: SsaInstr, array: SsaInstr) -> bool {$/;"	m
lteqArrayLength	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def lteqArrayLength(index: SsaInstr, array: SsaInstr) -> bool {$/;"	m
lu_const	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def lu_const(v: u64) -> SsaInstr {$/;"	m
lui	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def lui(rd: MipsReg, imm: u16)                 { emit_r2i(0x3c000000, MipsReg.R0, rd, imm); }$/;"	m
mach	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def mach: MachProgram;		  \/\/ machine program$/;"	d
mach	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def mach: MachProgram;$/;"	d
mach	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def mach: MachProgram;$/;"	d
mach	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def mach: MachProgram;		  \/\/ machine program$/;"	d
machBuffer	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	def machBuffer: MachDataWriter; \/\/ machine-level buffer$/;"	d
machBuffer	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def machBuffer: MachDataWriter; \/\/ machine-level buffer$/;"	d
machIndex	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var machIndex = -1;		\/\/ machine-level index$/;"	d
machLoweringConfig	$VIRGIL/aeneas/src/os/Linux.v3	/^	def machLoweringConfig: MachLoweringConfig;$/;"	d
machOffset	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var machOffset: int;	\/\/ machine-level offset$/;"	d
machSize	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var machSize: int = -1;$/;"	d
machType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def machType(t: Type) -> Type {$/;"	m
machTypeList	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def machTypeList(list: List<Type>) -> List<Type> {$/;"	m
machVal	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def machVal(val: Val) -> Val {$/;"	m
main	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def main(args: Array<string>) -> int {$/;"	f
mainMethod	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var mainMethod: VstMethod;$/;"	d
mainRootIndex	$VIRGIL/aeneas/src/core/Program.v3	/^	var mainRootIndex = -1;$/;"	d
make	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	private def make(loc: int) -> MoveNode {$/;"	m
makeAbstractClosureClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def makeAbstractClosureClass() -> JvmClassGen {$/;"	m
makeActive	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def makeActive(vreg: VReg) {$/;"	m
makeClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeClass(t: Type) -> RaClass {$/;"	m
makeDefaultVariantRecord	$VIRGIL/aeneas/src/v3/V3.v3	/^	def makeDefaultVariantRecord(prog: Program, t: Type) -> Record {$/;"	f
makeExecutable	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def makeExecutable(fileName: string) {$/;"	m
makeField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeField(op: SsaApplyOp, f: IrField, context: IrSpec) -> RaField {$/;"	m
makeField2	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeField2(raType: RaClass, f: IrField) -> RaField {$/;"	m
makeFuncRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def makeFuncRep(t: Type) -> Mach_FuncRep {$/;"	m
makeHeapSig	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def makeHeapSig(ctype: Type) -> JvmSig {$/;"	m
makeIrClass	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def makeIrClass(ctype: Type) -> IrClass {$/;"	m
makeIrMember	$VIRGIL/aeneas/src/ir/Ir.v3	/^	private def makeIrMember(m: VstMember) -> IrMember {$/;"	m
makeJar	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var makeJar: bool;$/;"	d
makeJvmArray	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	private def makeJvmArray(utype: Type) -> JvmType {$/;"	m
makeJvmClass	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	private def makeJvmClass(superRep: JvmType, utype: Type) -> JvmType {$/;"	m
makeJvmComponent	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	private def makeJvmComponent(utype: Type) -> JvmType {$/;"	m
makeJvmFunction	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	private def makeJvmFunction(utype: Type) -> JvmType {$/;"	m
makeJvmRtFileName	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def makeJvmRtFileName(fileName: string, ext: string) -> string {$/;"	f
makeJvmSig	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def makeJvmSig(receiver: JvmType, ftype: Type, retType: JvmType) -> JvmSig {$/;"	m
makeJvmTuple	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	private def makeJvmTuple(utype: Type) -> JvmType {$/;"	m
makeMachArray	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def makeMachArray(utype: Type) -> Mach_V3Array {$/;"	m
makeMachLoweringConfig	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def makeMachLoweringConfig() -> MachLoweringConfig {$/;"	f
makeMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeMethod(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {$/;"	m
makeMixedArrayRep	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def makeMixedArrayRep(arrayRep: Mach_V3Array, elemType: Type) {$/;"	m
makeNormFields	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def makeNormFields(rc: RaClass) {$/;"	m
makePolyField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makePolyField(raType: RaClass, f: IrField) -> RaField {$/;"	m
makeProgram	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def makeProgram(compiler: Compiler, args: Array<string>) -> Program {$/;"	f
makeRep	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def makeRep(utype: Type) -> JvmType {$/;"	m
makeSignature	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def makeSignature(m: VstMethod, returnThis: bool) -> Signature {$/;"	m
makeSimpleField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeSimpleField(raType: RaClass, f: IrField) -> RaField {$/;"	m
makeType	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def makeType(oldType: IntType) -> IntNorm {$/;"	m
makeType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def makeType(t: Type) -> RaType {$/;"	m
makeTypeArgs	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def makeTypeArgs(str: string, expr: VarExpr, typeParams: List<TypeParamType>) -> TypeArgs {$/;"	m
makeTypeArgsList	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def makeTypeArgsList(str: string, expr: VarExpr, typeParams: List<TypeParamType>) -> List<Type> {$/;"	m
makeVar	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def makeVar(i: SsaInstr) -> VReg {$/;"	m
makeVerifier	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def makeVerifier(decl: VstCompound, thisType: Type, file: VstFile) -> VstCompoundVerifier {$/;"	m
mangleB	$VIRGIL/aeneas/src/v3/Mangle.v3	/^	def mangleB(b1: StringBuilder, buffer: StringBuilder) -> StringBuilder {$/;"	f
mangleClosureName	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def mangleClosureName(memberRef: IrSpec) -> string {$/;"	m
mangleConvertName	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def mangleConvertName(prefix: string, exactType: Type, implicitType: Type) -> string {$/;"	m
mangleInto	$VIRGIL/aeneas/src/v3/Mangle.v3	/^	def mangleInto(s: string, max: int, buffer: StringBuilder) -> StringBuilder {$/;"	f
mangleIrMember	$VIRGIL/aeneas/src/v3/V3.v3	/^	def mangleIrMember(m: IrMember) -> string {$/;"	f
mangleTable	$VIRGIL/aeneas/src/v3/Mangle.v3	/^	var mangleTable  = Array<byte>.new(128);$/;"	d
mangleTypeName	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def mangleTypeName(prefix: string, t: Type) -> string {$/;"	m
mantissa32	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def mantissa32() -> (u32, int) {$/;"	m
mantissa64	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def mantissa64() -> (u64, int) {$/;"	m
map	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def map = TypeUtil.newTypeMap<OverflowTypeEntry>();$/;"	d
map	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def map = Strings.newMap<CiRuntime_Address>();$/;"	d
map	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var map   = Array<int>.new(gen.vars.length);$/;"	d
map	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	var map: HashMap<K, int>;$/;"	d
map	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def map = Array<MoveNode>.new(mapSize); \/\/ int -> node map$/;"	d
map	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var map: PartialMap<string, bool>;$/;"	d
map	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private var map: HashMap<SsaLink, int>;$/;"	d
map	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var map = Array<(int, int)>.new(32);$/;"	d
map	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def map = Strings.newMap<Operator>();$/;"	d
map	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def map<R>(f: T -> R) -> VstList<R> { return VstList.new(src, Lists.map(list, f)); }$/;"	m
map	$VIRGIL/lib/util/Arrays.v3	/^	def map<A, B>(array: Array<A>, func: A -> B) -> Array<B> {$/;"	f
map	$VIRGIL/lib/util/List.v3	/^	def map<A, B>(list: List<A>, func: A -> B) -> List<B> {$/;"	f
map	$VIRGIL/lib/util/Map.v3	/^	var map: HashMap<K, V>;$/;"	d
map	$VIRGIL/lib/util/Option.v3	/^	def map   = Strings.newMap<Opt>();$/;"	d
map0	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def map0(i_old: SsaInstr) {$/;"	m
map0	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def map0(i_old: SsaInstr) {$/;"	m
map1	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def map1(i_old: SsaInstr, i_new: SsaInstr) {$/;"	m
map1	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def map1(i_old: SsaInstr, ni: SsaInstr) {$/;"	m
map1keep	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def map1keep(i_old: SsaInstr, i_new: SsaInstr) {$/;"	m
mapArray	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def mapArray<R>(f: T -> R) -> Array<R> { return Arrays.map(asArray(), f); }$/;"	m
mapBlockEnd	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapBlockEnd(b_old: SsaBlock) -> SsaBlock {$/;"	m
mapBlockStart	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapBlockStart(b_old: SsaBlock) -> SsaBlock {$/;"	m
mapComponentParams	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def mapComponentParams(params: Array<SsaParam>) {$/;"	m
mapEdge	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapEdge(edge: SsaCfEdge) -> SsaBlock {$/;"	m
mapInto	$VIRGIL/lib/util/Arrays.v3	/^	def mapInto<A, B>(array: Array<A>, func: A -> B, dest: Array<B>) {$/;"	f
mapList	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def mapList<R>(f: T -> R) -> List<R> { return Lists.map(list, f); }$/;"	m
mapMask	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def mapMask = 0b111;	\/\/ mask for looking up in map$/;"	d
mapMultiReturn	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def mapMultiReturn(i_old: SsaInstr, i_new: SsaInstr, tn: TypeNorm) {$/;"	m
mapN	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def mapN(i_old: SsaInstr, ai_new: Array<SsaInstr>) {$/;"	m
mapN	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapN(i_old: SsaInstr, na: Array<SsaInstr>) {$/;"	m
mapNkeep	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def mapNkeep(i_old: SsaInstr, ai_new: Array<SsaInstr>) {$/;"	m
mapNnf	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapNnf(i_old: SsaInstr, na: Array<SsaInstr>) {$/;"	m
mapNonReceiverParams	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def mapNonReceiverParams(params: Array<SsaParam>, args: Array<SsaDfEdge>) {$/;"	m
mapNorm	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def mapNorm(i_old: SsaInstr, ni: SsaInstr, tn: TypeNorm) {$/;"	m
mapParam1	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def mapParam1(params: Vector<SsaParam>, i_old: SsaParam, t: Type) {$/;"	m
mapParams	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def mapParams() {$/;"	m
mapParams	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def mapParams(params: Array<SsaParam>) {$/;"	m
mapReg	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def mapReg(i: SsaInstr) -> int {$/;"	m
mapRegClasses	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def mapRegClasses(v: Array<(RegClass, byte)>) -> Array<byte> {$/;"	f
mapRegClasses	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def mapRegClasses(v: Array<(RegClass, byte)>) -> Array<byte> {$/;"	f
mapSimple	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def mapSimple(t: Type) -> TypeNorm {$/;"	m
mapSize	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def mapSize = 8;	\/\/ TUNABLE: size of move graph$/;"	d
mapValue	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def mapValue(i_old: SsaInstr, v: Val, tn: TypeNorm) -> SsaConst {$/;"	m
mapValueN	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def mapValueN(i_old: SsaInstr, v: Val, tn: TypeNorm) -> Array<SsaInstr> {$/;"	m
mapVar	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	private def mapVar(v: int) -> int {$/;"	m
mapVar	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def mapVar(v: VReg) -> VReg {$/;"	m
mapWide	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def mapWide(i_old: SsaApplyOp, i_new: SsaInstr, tn: IntNorm, truncate: bool) {$/;"	m
mark	$VIRGIL/aeneas/src/mach/Memory.v3	/^	var mark: int;		\/\/ the current end of the allocations$/;"	d
mark	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var mark: int = -1;		\/\/ fast mapping of instr->int$/;"	d
mark	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def mark = ++context.graph.markGen;$/;"	d
markAllLiveVars	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def markAllLiveVars() {$/;"	m
markAsConsumed	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def markAsConsumed(sji: SsaJvmInstr, edge: SsaDfEdge) {$/;"	m
markAsNotUsableAsTemp	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def markAsNotUsableAsTemp(mr: MoveResolver, loc: int) {$/;"	m
markAsUsedAsTemp	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def markAsUsedAsTemp(mr: MoveResolver, loc: int) {$/;"	m
markBlockInstrs	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def markBlockInstrs(block: SsaBlock, mark: int) {$/;"	m
markBlocks	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def markBlocks(block: SsaBlock, end: Array<SsaBlock>, mark: int) {$/;"	m
markBody	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def markBody(mark: int) {$/;"	m
markGen	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var markGen: int;		\/\/ marking generation$/;"	d
markHeader	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def markHeader(mark: int) {$/;"	m
markLastDefAsConsumedFromStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def markLastDefAsConsumedFromStack(vreg: VReg) {$/;"	m
markLive	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def markLive(v: VReg) {$/;"	m
markLoopBlocks	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def markLoopBlocks(s: SsaBlock, h: SsaBlock, loop: SsaLoopInfo) {$/;"	m
markMember	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def markMember(m: IrMember) {$/;"	m
markNontrivial	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def markNontrivial() { if (initIndex < -1) initIndex = -1; }$/;"	m
markQueue	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def markQueue = Vector<VReg>.new();$/;"	d
markRestore	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def markRestore(block: SsaBlock, cur: ArchInstr) {$/;"	m
markRestoreVreg	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def markRestoreVreg(block: SsaBlock, cur: ArchInstr, vreg: VReg) {$/;"	m
markRestoreVregLoop	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def markRestoreVregLoop(block: SsaBlock, cur: ArchInstr, vreg: VReg) {$/;"	m
markUsesLive	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def markUsesLive(v: VReg) {$/;"	m
marker	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def marker = SsaInternalMarker.new();$/;"	d
marker	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var marker = SsaInternalMarker.new();$/;"	d
marks	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	private var marks = 0;$/;"	d
marks	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def marks = newMap<int>();$/;"	d
mask	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def mask = ~add;$/;"	d
maskRow	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var maskRow: int;$/;"	d
match1	$VIRGIL/lib/util/DataReader.v3	/^	def match1(b: byte) -> bool {$/;"	m
matchAddImm	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def matchAddImm(i: SsaInstr, disp: Val) -> (SsaInstr, Val) {$/;"	m
matchAddress	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def matchAddress(a: SsaInstr) -> (Val, SsaInstr) {$/;"	m
matchAll	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	def matchAll(s: string) -> bool {$/;"	f
matchCmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def matchCmp(i: SsaInstr) -> X86CmpMatch {$/;"	m
matchCompareBranch	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def matchCompareBranch(b: SsaJvmBlock) -> SsaJvmCompareBranch {$/;"	m
matchEdge	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def matchEdge(e: SsaDfEdge, optag: u8) -> bool {$/;"	m
matchInc	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def matchInc(e: SsaInstr) -> Box<int> {$/;"	m
matchInt	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def matchInt(i: SsaInstr) -> Box<int> { \/\/ XXX: move this utility elsewhere$/;"	m
matchIv	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def matchIv(phi: SsaPhi, prev: List<SsaLinearIv>) -> List<SsaLinearIv> {$/;"	m
matchLoad	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def matchLoad(t: Type, size: int) -> (string, (X86Assembler, X86Reg, X86Rm) -> void) {$/;"	m
matchMrrsd	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def matchMrrsd(i: SsaInstr) -> (SsaInstr, SsaInstr, byte, Val) {$/;"	m
matchPatterns	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def matchPatterns(keyType: Type, pl: List<MatchPattern>, val: Val) -> bool {$/;"	m
matchScale	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def matchScale(i: SsaInstr) -> (SsaInstr, byte) {$/;"	m
matchScale	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def matchScale(e: SsaDfEdge) -> (SsaInstr, byte) {$/;"	m
matchSwitchCmp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def matchSwitchCmp(key: SsaInstr, block: SsaBlock) -> SwitchCmp {$/;"	m
matcher	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def matcher = SsaInstrMatcher.new();$/;"	d
matches	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	def matches(m: VstMember) -> bool {$/;"	m
matches	$VIRGIL/lib/util/GlobMatcher.v3	/^	def matches(input: string) -> bool {$/;"	m
matrix	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def matrix = BitMatrix.new(physRegs + 1, regSets.length);$/;"	d
matrix	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var matrix: BitMatrix;$/;"	d
max	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	var max = 0;$/;"	d
max	$VIRGIL/aeneas/src/types/Float.v3	/^	def max(itt: IntType) -> Val {$/;"	m
max	$VIRGIL/aeneas/src/types/Int.v3	/^	var max: Val;$/;"	d
max	$VIRGIL/lib/util/DataWriter.v3	/^	private var max: int;			\/\/ the maximum position ever accessed$/;"	d
maxClassId	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var maxClassId: int;$/;"	d
maxClassId	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var maxClassId = -1;			\/\/ maximum class ID$/;"	d
maxDepth	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var maxDepth = 5;$/;"	d
maxInlineBlocks	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var maxInlineBlocks = 5;$/;"	d
maxInlineSize	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var maxInlineSize = 20;$/;"	d
maxSpecialAddrDelta	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def maxSpecialAddrDelta: u32 = (255u - DWARFLineOpcodeBase) \/ DWARFLineRange;$/;"	d
maxValue	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def maxValue: int;$/;"	d
max_locals	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var max_locals: int;$/;"	d
max_locals	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var max_locals: int;$/;"	d
max_stack	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	var max_stack: int;$/;"	d
max_stack	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var max_stack: int;$/;"	d
maxpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
maxplus1	$VIRGIL/aeneas/src/types/Float.v3	/^	def maxplus1(itt: IntType) -> Val {$/;"	m
maxplus1d	$VIRGIL/aeneas/src/types/Float.v3	/^	def maxplus1d(itt: IntType) -> double {$/;"	m
maxprot	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var maxprot: int;$/;"	d
maxps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
maxsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def maxsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5F, a, b); }$/;"	m
maxsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
maxsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
maxss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def maxss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5F, a, b); }$/;"	m
maxss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
maxss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def maxss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
maybeCast	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def maybeCast(t1: Type, t2: Type, eq: TypeCast, neq: TypeCast) -> TypeCast {$/;"	f
maybeDead	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var maybeDead: List<SsaInstr>;$/;"	d
maybeDeadCodeLater	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def maybeDeadCodeLater(i: SsaInstr) {$/;"	m
maybeEqual	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def maybeEqual(t1: Type, t2: Type) -> bool {$/;"	f
maybeQuery	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def maybeQuery(t1: Type, t2: Type, eq: TypeQuery, neq: TypeQuery) -> TypeQuery {$/;"	f
mdecl	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def mdecl: VstMethod;$/;"	d
member	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var member: VstField;$/;"	d
memberMap	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var memberMap: HashMap<string, VstMember>;$/;"	d
memberRef	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var memberRef: IrSpec;$/;"	d
memberRef	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def memberRef: IrSpec;$/;"	d
memberinits	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var memberinits: List<VstField>;$/;"	d
memberinits	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var memberinits: List<VstField>;$/;"	d
members	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var members: List<VstMember>;$/;"	d
merge	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def merge(env: VstSsaEnv) {$/;"	m
mergeBuilder	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	private var mergeBuilder = context.newBuilder();$/;"	d
mergeConversions	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def mergeConversions(a: Conversion, b: Conversion) -> Conversion {$/;"	f
mergeEdge	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def mergeEdge(env: VstSsaEnv, edge: SsaCfEdge) {$/;"	m
mergeFlow	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def mergeFlow(a: int, b: int) -> int {$/;"	m
mergeIncoming	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def mergeIncoming(env: VstSsaEnv) {$/;"	m
mergeLists	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def mergeLists(tl1: List<Type>, tl2: List<Type>, tc: TypeCon, mergefun: (Type, Type) -> Type) -> Type {$/;"	f
mergeMoves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def mergeMoves(dst: int, src: int) {$/;"	m
mergeNewest	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	private def mergeNewest() {$/;"	m
metaRegion	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def metaRegion    = Region.new("meta", code);$/;"	d
meth	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def meth = context.method.source;	\/\/ the VST method$/;"	d
methList	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	var methList: List<IrMethod>;$/;"	d
methType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def methType: Type;$/;"	d
method	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def method: IrMethod;$/;"	d
method	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	var method: IrMethod;$/;"	d
methodEnv	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var methodEnv: MethodEnv;$/;"	d
methodID	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def methodID: int;$/;"	d
methodMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def methodMap     = IrUtil.newIrItemMap<Address<IrMethod>>();$/;"	d
methodTable	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def methodTable(spec: IrSpec) -> Addr {$/;"	m
methodTableRaw	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def methodTableRaw(spec: IrSpec) -> Addr {$/;"	m
methods	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def methods: Array<IrMethod>;		\/\/ method dispatch table, #0 = constructor$/;"	d
methods	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var methods = Array<List<RaMethod>>.new(orig.methods.length); \/\/ index of methods$/;"	d
methods	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def methods = Vector<IrMethod>.new();$/;"	d
methods	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def methods = Vector<JvmMethod>.new();$/;"	d
mfhi	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def mfhi(rd: MipsReg) { w.put_b32be(0x00000010 | int.view(rd.tag) << 11); }$/;"	m
mflo	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def mflo(rd: MipsReg) { w.put_b32be(0x00000012 | int.view(rd.tag) << 11); }$/;"	m
min	$VIRGIL/aeneas/src/types/Float.v3	/^	def min(itt: IntType) -> Val {$/;"	m
min	$VIRGIL/aeneas/src/types/Int.v3	/^	var min: Val;$/;"	d
min	$VIRGIL/lib/util/Ints.v3	/^	def min(a: int, b: int) -> int {$/;"	f
min	$VIRGIL/lib/util/Longs.v3	/^	def min(a: long, b: long) -> long {$/;"	f
minClassId	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var minClassId: int;$/;"	d
minClassId	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var minClassId = -1;			\/\/ minimum class ID$/;"	d
mind	$VIRGIL/aeneas/src/types/Float.v3	/^	def mind(itt: IntType) -> double {$/;"	m
minpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
minps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
minsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def minsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5D, a, b); }$/;"	m
minsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
minsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
minss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def minss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5D, a, b); }$/;"	m
minss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
minss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def minss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
mixedCmp	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def mixedCmp(ltype: Type, rtype: Type, op: VstOperator) -> Operator {$/;"	m
mkWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def mkWorklist() {$/;"	m
mono	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def mono(t: Type, spec: IrSpec) -> Type {$/;"	m
more	$VIRGIL/lib/util/DataReader.v3	/^	def more() -> bool {$/;"	m
moreInfo	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def moreInfo(more: bool) {$/;"	m
mostlyRoundUpIntType	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def mostlyRoundUpIntType(it: IntType) -> IntType {$/;"	m
mov	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def mov(rd: ArmReg, op: ArmOperand) { data1_1(26, rd, op); }$/;"	m
movaps_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movaps_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
movaps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movaps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movb_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movb_m_i(a: X86_64Addr, i: int) -> this {$/;"	m
movb_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movb_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
movb_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movb_r_i(a: X86_64Gpr, i: int) -> this {$/;"	m
movb_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movb_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movb_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movb_r_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movb_r_rm(a: X86Reg, b: X86Rm) { emitb_rm(0x8A, b, a.index); }$/;"	m
movb_rm_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movb_rm_i(a: X86Rm, i: int) { \/\/ move immediate byte$/;"	m
movb_rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movb_rm_r(a: X86Rm, b: X86Reg) { emitb_rm(0x88, a, b.index); }$/;"	m
movbsx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movbsx(a: X86Reg, b: X86Rm) { emitbb_rm(0x0F, 0xBE, b, a.index); } \/\/ byte load, sign extend$/;"	m
movbsx_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movbsx_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movbsx_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movbsx_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movbzx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movbzx(a: X86Reg, b: X86Rm) { emitbb_rm(0x0F, 0xB6, b, a.index); } \/\/ byte load, zero extend$/;"	m
movbzx_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movbzx_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movbzx_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movbzx_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movd_l_fval	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movd_l_fval(frame: MachFrame, loc: int, val: Val) {$/;"	m
movd_l_val	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movd_l_val(frame: MachFrame, loc: int, val: Val) {$/;"	m
movd_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_m_i(a: X86_64Addr, i: int) -> this {$/;"	m
movd_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
movd_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def movd_r_i(rd: Arm64Reg, imm: u16) -> this { emit_r_i(rd, imm, 0xA5); }$/;"	m
movd_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_r_i(a: X86_64Gpr, i: int) -> this {$/;"	m
movd_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movd_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def movd_r_r(rd: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
movd_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movd_r_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movd_r_rm(a: X86Reg, b: X86Rm) {$/;"	m
movd_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_r_s(b: X86_64Reg, a: X86_64Xmmr) -> this {$/;"	m
movd_rm_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movd_rm_i(a: X86Rm, i: int) { \/\/ move immediate doubleword$/;"	m
movd_rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movd_rm_r(a: X86Rm, b: X86Reg) {$/;"	m
movd_rm_rm	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movd_rm_rm(d: X86Rm, s: X86Rm, scratch: X86Reg) {$/;"	m
movd_rm_s	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movd_rm_s(a: X86Rm, b: SSEReg) {$/;"	m
movd_s_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movd_s_r(a: X86_64Xmmr, b: X86_64Reg) -> this {$/;"	m
movd_s_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movd_s_rm(a: SSEReg, b: X86Rm) {$/;"	m
movddup_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movddup_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movdqu_m_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movdqu_m_s(a: X86_64Addr, b: X86_64Xmmr) -> this {$/;"	m
movdqu_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movdqu_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
move	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var move: int;$/;"	d
move	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def move(rd: MipsReg, rs: MipsReg) { or(rd, rs, MipsReg.R0); }$/;"	m
moveCursor	$VIRGIL/lib/term/Vt100.v3	/^	def moveCursor(x: int, y: int) {$/;"	f
moveCursorBackward	$VIRGIL/lib/term/Vt100.v3	/^	def moveCursorBackward = icmd('D');$/;"	d
moveCursorDown	$VIRGIL/lib/term/Vt100.v3	/^	def moveCursorDown = icmd('B');$/;"	d
moveCursorForward	$VIRGIL/lib/term/Vt100.v3	/^	def moveCursorForward = icmd('C');$/;"	d
moveCursorUp	$VIRGIL/lib/term/Vt100.v3	/^	def moveCursorUp = icmd('A');$/;"	d
moveHome	$VIRGIL/lib/term/Vt100.v3	/^	def moveHome = esc("[H");$/;"	d
moveIR	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def moveIR: (Type, SsaInstr, int) -> void;$/;"	d
moveIR	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def moveIR(t: Type, i: SsaInstr, dst: int) {$/;"	m
moveOpcode	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def moveOpcode(regClass: RegClass) -> int {$/;"	m
moveRR	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def moveRR: (Type, int, int) -> void;$/;"	d
moveRR	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def moveRR(t: Type, src: int, dst: int) {$/;"	m
moveResolver	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def moveResolver = MoveResolver.new(codegen.mach.prog.ERROR);$/;"	d
moveStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def moveStack = Vector<int>.new();$/;"	d
moveToDomList	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def moveToDomList(bi: SsaBlockInfo, ci: SsaBlockInfo) {$/;"	m
moves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var moves = Vector<int>.new();$/;"	d
moves	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def moves = MoveSet.new(regSet);$/;"	d
moves	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var moves: MachMoves;	\/\/ moves to be inserted before instruction$/;"	d
movesCnt	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var movesCnt: int = 0;$/;"	d
movesNext	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def movesNext = GlobalMoveSet.new(regSet);$/;"	d
movesPrev	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def movesPrev = GlobalMoveSet.new(regSet);$/;"	d
movesWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var movesWorklist = Vector<(int,int,int)>.new(); \/\/ var, var, weight$/;"	d
movesWorklistCmp	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def movesWorklistCmp(x: (int, int, int), y: (int, int, int)) -> bool {$/;"	m
movhlps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movhlps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movlhps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movlhps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movmskpd_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movmskpd_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
movmskps_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movmskps_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
movq_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_m_i(a: X86_64Addr, i: int) -> this {$/;"	m
movq_m_m	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movq_m_m(d: SSERm, s: SSERm) {$/;"	m
movq_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
movq_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def movq_r_i(rd: Arm64Reg, imm: u16) -> this { emit_r_i(rd, imm, 0x1A5); }$/;"	m
movq_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_i(a: X86_64Gpr, i: int) -> this {$/;"	m
movq_r_l	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_l(a: X86_64Gpr, l: long) -> this {$/;"	m
movq_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movq_r_p	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_p(a: X86_64Gpr, l: long) -> int {$/;"	m
movq_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def movq_r_r(rd: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
movq_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movq_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_r_s(b: X86_64Reg, a: X86_64Xmmr) -> this {$/;"	m
movq_s_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movq_s_r(a: X86_64Xmmr, b: X86_64Reg) -> this {$/;"	m
movq_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movq_s_sm(a: SSEReg, b: SSERm) {$/;"	m
movq_sm_s	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movq_sm_s(a: SSERm, b: SSEReg) {$/;"	m
movs	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def movs(rd: ArmReg, op: ArmOperand) { data1_1(27, rd, op); }$/;"	m
movsb	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movsb() -> this { emitb(0xA4); }$/;"	m
movsb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movsb() { emitb(0xA4); }$/;"	m
movsd_m_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movsd_m_s(a: X86_64Addr, b: X86_64Xmmr) -> this {$/;"	m
movsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
movsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movsd_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movsd_s_sm(a: SSEReg, b: SSERm) { \/\/ load double$/;"	m
movsd_sm_s	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movsd_sm_s(a: SSERm, b: SSEReg) { \/\/ store double$/;"	m
movsd_sm_sm	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movsd_sm_sm(d: SSERm, s: SSERm) {$/;"	m
movshdup_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movshdup_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
movshdup_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movshdup_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movss_m_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movss_m_s(a: X86_64Addr, b: X86_64Xmmr) -> this {$/;"	m
movss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
movss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
movss_s_sm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movss_s_sm(a: SSEReg, b: SSERm) { \/\/ load float$/;"	m
movss_sm_s	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movss_sm_s(a: SSERm, b: SSEReg) { \/\/ store float$/;"	m
movss_sm_sm	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def movss_sm_sm(d: SSERm, s: SSERm) {$/;"	m
movw_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movw_m_i(a: X86_64Addr, imm: int) -> this {$/;"	m
movw_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movw_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
movw_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movw_r_i(a: X86_64Gpr, imm: int) -> this {$/;"	m
movw_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movw_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movw_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movw_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movw_rm_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movw_rm_i(a: X86Rm, imm: int) { \/\/ word store$/;"	m
movw_rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movw_rm_r(a: X86Rm, b: X86Reg) { emitbb_rm(0x66, 0x89, a, b.index); } \/\/ word store$/;"	m
movwsx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movwsx(a: X86Reg, b: X86Rm) { emitbb_rm(0x0F, 0xBF, b, a.index); } \/\/ word load, sign extend$/;"	m
movwsx_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movwsx_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movwsx_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movwsx_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
movwzx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def movwzx(a: X86Reg, b: X86Rm) { emitbb_rm(0x0F, 0xB7, b, a.index); } \/\/ word load, zero extend$/;"	m
movwzx_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movwzx_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
movwzx_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def movwzx_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
mrMap	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def mrMap = Int.newMap<int>();$/;"	d
msg_arg_data_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_arg_data_copy(dst: i32, offset: i32, size: i32);				\/\/ I U Q Ry F$/;"	f
msg_arg_data_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_arg_data_size() -> i32;								\/\/ I U Q Ry F$/;"	f
msg_caller_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_caller_copy(dst: i32, offset: i32, size: i32);		 			\/\/ I G U Q F$/;"	f
msg_caller_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_caller_size() -> i32;								\/\/ I G U Q F$/;"	f
msg_cycles_accept	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_accept(max_amount: i64) -> i64;		  				\/\/ U Rt Ry$/;"	f
msg_cycles_accept128	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_accept128(max_amount_high: i64, max_amount_low: i64, dst: i32);		\/\/ U Rt Ry$/;"	f
msg_cycles_available	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_available() -> i64;							\/\/ U Rt Ry$/;"	f
msg_cycles_available128	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_available128(dst: i32);				  			\/\/ U Rt Ry$/;"	f
msg_cycles_refunded	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_refunded() -> i64;							\/\/ Rt Ry$/;"	f
msg_cycles_refunded128	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_cycles_refunded128(dst: i32);				  			\/\/ Rt Ry$/;"	f
msg_method_name_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_method_name_copy(dst: i32, offset: i32, size: i32);				\/\/ F$/;"	f
msg_method_name_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_method_name_size() -> i32;							\/\/ F$/;"	f
msg_reject	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reject(src: i32, size: i32);							\/\/ U Q Ry Rt$/;"	f
msg_reject_code	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reject_code() -> i32;								\/\/ Ry Rt$/;"	f
msg_reject_msg_copy	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reject_msg_copy(dst: i32, offset: i32, size: i32);				\/\/ Rt$/;"	f
msg_reject_msg_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reject_msg_size() -> i32;							\/\/ Rt$/;"	f
msg_reply	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reply();						 			\/\/ U Q Ry Rt$/;"	f
msg_reply_data_append	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def msg_reply_data_append(src: i32, size: i32);			 			\/\/ U Q Ry Rt$/;"	f
mtable	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def mtable: IrMtable;$/;"	d
mtable	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var mtable: IrMtable;		\/\/ mtable used for machine-level virtual calls$/;"	d
mtableMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def mtableMap     = IrUtil.newIrItemMap<Addr>();$/;"	d
mtlayout	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var mtlayout: RefType;$/;"	d
mtref	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def mtref: MemoryTypeRef;$/;"	d
mttype	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var mttype: Type;$/;"	d
mul	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def mul(rd: ArmReg, rs: ArmReg, rm: ArmReg) { emit_rrr(0x00000090, rd, rm, rs); }$/;"	m
mul	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def mul(b: X86Rm) { emitb_rm(0xF7, b, 4); } \/\/ unsigned multiply (output in edx:eax)$/;"	m
mulAdd32	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def mulAdd32(factor: u32, carry: u32) -> this {$/;"	m
mulPow10	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def mulPow10(exp: u32) -> this {$/;"	m
mul_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mul_m(b: X86_64Addr) -> this {$/;"	m
mul_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mul_r(b: X86_64Gpr) -> this {$/;"	m
muld_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def muld_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
mulpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
mulps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
mulq_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def mulq_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
muls	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def muls(rd: ArmReg, rs: ArmReg, rm: ArmReg) { emit_rrr(0x00100090, rd, rm, rs); }$/;"	m
mulsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def mulsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x59, a, b); }$/;"	m
mulsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
mulsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
mulss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def mulss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x59, a, b); }$/;"	m
mulss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
mulss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def mulss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
mult	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def mult(rs: MipsReg, rt: MipsReg)              { emit_r2i(0x00000000, rs, rt, 0x18); }$/;"	m
multiBlock	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var multiBlock: bool;$/;"	d
multiBuckets	$VIRGIL/aeneas/src/types/Type.v3	/^	var multiBuckets  = Array<Type>.new(13);$/;"	d
multu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def multu(rs: MipsReg, rt: MipsReg)             { emit_r2i(0x00000000, rs, rt, 0x19); }$/;"	m
mutableMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var mutableMap = TypeUtil.newTypeMap<List<int>>();$/;"	d
n_op	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def n_op(i: SsaApplyOp) -> Val {$/;"	m
name	$VIRGIL/aeneas/src/core/Opcode.v3	/^type Opcode {$/;"	d
name	$VIRGIL/aeneas/src/core/Program.v3	/^	def name() -> string {$/;"	m
name	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var name: int;$/;"	d
name	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IntUnop {$/;"	d
name	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type PackingField #unboxed {$/;"	d
name	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def name: string;$/;"	d
name	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^type Operand {$/;"	d
name	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def name: string;		\/\/ name of address space$/;"	d
name	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def name() -> string {$/;"	m
name	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def name: string;$/;"	d
name	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^type BoundOp {$/;"	d
name	$VIRGIL/aeneas/src/types/Int.v3	/^	def name(width: byte, signed: bool) -> string {$/;"	f
name	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	def name(scalar: Scalar) -> string {$/;"	f
name	$VIRGIL/aeneas/src/types/Type.v3	/^	def name: string;		\/\/ name of the type$/;"	d
name	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VstRepHint {$/;"	d
name	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^type VstMatcher {$/;"	d
name	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^type CfgInstr {$/;"	d
name	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^type WasmType {$/;"	d
name	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	var name: string;$/;"	d
name	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmSmallOffset {$/;"	d
name	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def name: string;$/;"	d
name	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^type MipsReg {$/;"	d
name	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def name: string;$/;"	d
name	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def name(size: int) -> string {$/;"	m
name	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^type NetResult<T> {$/;"	d
name	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiSourceEntry #unboxed {$/;"	d
name16	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def name16: string;$/;"	d
name32	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def name32: string;$/;"	d
name32	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def name32: string;$/;"	d
name64	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def name64: string;$/;"	d
name64	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def name64: string;$/;"	d
name8	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def name8: string;$/;"	d
names	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def names: Array<string>;		\/\/ names of each register and set$/;"	d
names	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	var names: Record;$/;"	d
names	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	var names: Record;$/;"	d
names	$VIRGIL/lib/util/Option.v3	/^	var names = Vector<string>.new();$/;"	d
nargs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var nargs: int;$/;"	d
near_uses	$VIRGIL/aeneas/src/util/Label.v3	/^	var near_uses: List<int>;$/;"	d
near_uses	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var near_uses: List<int>;$/;"	d
needsNullCheck	$VIRGIL/aeneas/src/core/Operator.v3	/^	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {$/;"	f
neg	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def neg(a: Arm64Cond, b: Arm64Cond) {$/;"	f
neg	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def neg(a: X86_64Cond, b: X86_64Cond) {$/;"	f
neg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def neg(a: X86Rm) { emitb_rm(0xF7, a, 3); }$/;"	m
neg64	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def neg64(a: X86Reg, b: X86Reg) {$/;"	m
neg_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def neg_m(a: X86_64Addr) -> this {$/;"	m
neg_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def neg_r(a: X86_64Gpr) -> this {$/;"	m
negate	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def negate() -> X86_64CondPair {$/;"	m
negate	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def negate() -> X86CmpMatch { return X86CmpMatch.new(cond.negate, x, y, val); }$/;"	m
negate	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def negate() -> ArmCond {$/;"	m
negate	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	var negate: Arm64Cond;$/;"	d
negate	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var negate: X86_64Cond;$/;"	d
negate	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var negate: X86Cond;$/;"	d
negative	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def negative: bool;$/;"	d
negativeHeaders	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var negativeHeaders = false; \/\/ object headers are at negative offsets$/;"	d
nested	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def nested: Array<TypeNorm>;$/;"	d
nested	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var nested: int;		\/\/ nested time, last entry time$/;"	d
nested	$VIRGIL/aeneas/src/types/Type.v3	/^	def nested: List<Type>;	\/\/ nested types, if any$/;"	d
new	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	new(context: SsaContext, mach: MachProgram, rt, asm, buffer: MachDataWriter) super(context, mach, ArmMachRegs.regs, buffer) {$/;"	m
new	$VIRGIL/aeneas/src/arm/ArmLinux.v3	/^	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter,$/;"	m
new	$VIRGIL/aeneas/src/arm/ArmMacroAssembler.v3	/^	new(mach, machBuffer, codeStartOffset) super(machBuffer) { }$/;"	m
new	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	new(mach, stub, alwaysGc) { }$/;"	m
new	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	new(name: string, test) super(name) { }$/;"	m
new	$VIRGIL/aeneas/src/arm64/Arm64MacroAssembler.v3	/^	new(mw) super(mw) {}$/;"	m
new	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	new(context: SsaContext, mach: MachProgram, asm, w: MachDataWriter, dwarf)$/;"	m
new	$VIRGIL/aeneas/src/core/Member.v3	/^	new(name: string, kind: Kind, arity: int, typeCache: TypeCache)$/;"	m
new	$VIRGIL/aeneas/src/core/Opcode.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/core/Program.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	new(prog: Program) {$/;"	m
new	$VIRGIL/aeneas/src/ic/Ic.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	new(i: IcInterpreter) {$/;"	m
new	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	new(compiler: Compiler, prog) {$/;"	m
new	$VIRGIL/aeneas/src/ir/Ir.v3	/^	new(receiver: Type, typeArgs, sig: Signature) super(receiver) { }$/;"	m
new	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	new() { vn = VariantNormalizer.new(config, this, CLOptions.PRINT_RA.get()); }$/;"	m
new	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	new(index, src: SpecMethod, dst: SpecMethod) super(src, dst) { }$/;"	m
new	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	new(oldType: Type, orig, parent) super(oldType) {$/;"	m
new	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	new(context: SsaContext, norm) super(context) {$/;"	m
new	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)$/;"	m
new	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	new(oldType: Type, newType: Type, sub: Array<Type>, fields, tag)$/;"	m
new	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	new(name_index: int, descriptor_index: int) super(name_index, descriptor_index) { }$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	new(builder: JvmClassfileBuilder, tupleType) super(builder) { }$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	new(rval, jtype: JvmType) super(jtype) { }$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	new(name: string, jar, test) super(name) {$/;"	m
new	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	new(name: string, superName) super(name, JvmTypes.KIND_OBJECT) { }$/;"	m
new	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	new(lcmp, op, args) { }$/;"	m
new	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	new(ptrType, typeCache: TypeCache) super("CiRuntime", Kind.VOID, 0, typeCache) { }$/;"	m
new	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	new(pos: int, vreg: VReg) super(pos, vreg) { }$/;"	m
new	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	new(ssa, varNum, varSize, isConst: bool) {$/;"	m
new	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	new(pageAlign, startAddr, initialSize: int) {$/;"	m
new	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	new(prog: Program, code, data, intNorm) super(prog) {$/;"	m
new	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/mach/Memory.v3	/^	new(region: Region, val) super(region, null, 0) { }$/;"	m
new	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	new(loc) { }$/;"	m
new	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	new(typeCon: TypeCon, width) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/main/Compiler.v3	/^	new(input: string, ERROR: ErrorGen) {$/;"	m
new	$VIRGIL/aeneas/src/main/Error.v3	/^	new(range: FileRange, sourceLine: string) super(range, sourceLine, null, null) { }$/;"	m
new	$VIRGIL/aeneas/src/os/Kernel.v3	/^	new() super(kernel.typename, Kind.VOID, 0, TypeUtil.globalCache) { }$/;"	m
new	$VIRGIL/aeneas/src/os/Linux.v3	/^	new(name: string, space, intNorm, machLoweringConfig, newBackend, elf_machine, kernelCallReturnType) super(name) {$/;"	m
new	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	new(vtype, block, a: Array<SsaInstr>) super(a) { }$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	new(context, graph, block) { }$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	new(ssa) {$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	new(context, allocate, moveIR, moveRR) { }$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	new(params, returnType) { }$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	new(context: SsaContext, call, inlinee) super(context) {$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	new(phi, init, step) {}$/;"	m
new	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	new(size: int, gen, parent, block: SsaBlock) super(gen.context, gen.graph, block) {$/;"	m
new	$VIRGIL/aeneas/src/types/Bool.v3	/^	new(typeCon: TypeCon) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/types/Float.v3	/^	new(exp_width, fraction_width, typeCon: Float_TypeCon) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/types/Function.v3	/^	new(kind: Kind) super("closure", kind, 2, TypeUtil.globalCache) { }$/;"	m
new	$VIRGIL/aeneas/src/types/Int.v3	/^	new(width: byte, signed: bool) super(Int.name(width, signed), Kind.INT, 0, TypeUtil.globalCache) {$/;"	m
new	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	new(scalar: Scalar, tc: Int_TypeCon) super(IntRep.name(scalar), Kind.INT, 0, TypeUtil.globalCache) {$/;"	m
new	$VIRGIL/aeneas/src/types/Tuple.v3	/^	new(hash: int, typeCon: TypeCon, nested: List<Type>) super(hash, typeCon, nested) { }$/;"	m
new	$VIRGIL/aeneas/src/types/Type.v3	/^	new(token: Token, typeParam, typeCache: TypeCache) super(typeParam.token.image, Kind.TYPE_VAR, 0, typeCache) {$/;"	m
new	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	new(parent, typeParams, other) {$/;"	m
new	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	new(name: string, kind: Kind, arity: int, typeCache: TypeCache, allocFunc) super(name, kind, arity, typeCache) { }$/;"	m
new	$VIRGIL/aeneas/src/types/Void.v3	/^	new(typeCon: TypeCon) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/util/Char.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/util/ParsedFile.v3	/^	new(fileName, input) {$/;"	m
new	$VIRGIL/aeneas/src/util/Progress.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/v3/Mangle.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/v3/Ref.v3	/^	new(layoutDecl, writeable, typeCache: TypeCache)$/;"	m
new	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	new(hash: int, writeable, typeCon: TypeCon, nested: List<Type>) super(hash, typeCon, nested) { }$/;"	m
new	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	new(hash: int, classDecl, typeCon: V3Class_TypeCon, nested: List<Type>) super(hash, typeCon, nested) { }$/;"	m
new	$VIRGIL/aeneas/src/v3/V3Component.v3	/^	new(typeCon: TypeCon, componentDecl) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	new(hash: int, enumDecl, typeCon: TypeCon) super(hash, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	new(typeCon: TypeCon) super(typeCon.uid, typeCon, null) { }$/;"	m
new	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	new(compound, mdecl, thisParam, verifier, env) { \/\/ XXX: remove compound; redundant with verifier.compound$/;"	m
new	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	new() {$/;"	m
new	$VIRGIL/aeneas/src/vst/Parser.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	new(file, ERROR, skipFunc, typeCache) {$/;"	m
new	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	new() { reset(); }$/;"	m
new	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	new(compound, thisType, verifier, file) {$/;"	m
new	$VIRGIL/aeneas/src/vst/Vst.v3	/^	new(token: Token, val: Val, t: Type, lsuffix: bool, usuffix: bool, negative) super(token, val, t, lsuffix, usuffix) { }$/;"	m
new	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	new() { p = Printer.new(this); }$/;"	m
new	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	new(context: SsaContext, wasm: WasmProgram, rt, w: MachDataWriter) super(context, wasm.mach, REGS, w) {$/;"	m
new	$VIRGIL/aeneas/src/wasm/WasmOp.v3	/^	new() {$/;"	f
new	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	new(pageAlign: Alignment, initialSize: int) super(pageAlign, 0, initialSize) {$/;"	m
new	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	new(index: u32, parent, fields) super(index) { }$/;"	m
new	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	new(x86codegen, prog: Program, regSet: MachRegSet) super(x86codegen, prog, regSet) { }$/;"	m
new	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf, test)$/;"	m
new	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	new(name: string, test) super(name) { }$/;"	m
new	$VIRGIL/aeneas/src/x86-64/X86_64Linux.v3	/^	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf,$/;"	m
new	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	new(mw) super(mw, X86_64Assemblers.REX_W) {$/;"	m
new	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, test)$/;"	m
new	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	new(name: string, emitFunc, params) super(name) { }$/;"	m
new	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	new(name: string, test) super(name) { }$/;"	m
new	$VIRGIL/aeneas/src/x86/X86Linux.v3	/^	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter,$/;"	m
new	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	new(mach, machBuffer, codeStartOffset) super(machBuffer) { }$/;"	m
new	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	new() {$/;"	f
new	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	new(name64, name32, regnum: u5) super(regnum) {}$/;"	m
new	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	new(name8, name16, name32, name64, regnum: byte) super(regnum) { }$/;"	m
new	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	new() {$/;"	m
new	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	new(port: int, isV6: bool) super(if(isV6, Net.ANY_V6, Net.ANY_V4), port, -1 \/* localPort *\/, SocketType.Udp, -1 \/* fd *\/) {$/;"	m
new	$VIRGIL/lib/util/DataReader.v3	/^	new(data) { }$/;"	m
new	$VIRGIL/lib/util/Edge.v3	/^	new(src, dest) {$/;"	m
new	$VIRGIL/lib/util/IO.v3	/^	new(bufSize, ffunc) {$/;"	m
new	$VIRGIL/lib/util/Map.v3	/^	new(key, val: V, next: Bucket<K,V>) {$/;"	m
new	$VIRGIL/lib/util/Option.v3	/^	new(prefix: string) : super(prefix) { }$/;"	m
new	$VIRGIL/lib/util/TextReader.v3	/^	new(fileName, data) {$/;"	m
new	$VIRGIL/lib/util/Token.v3	/^	new(fileName: string, image, beginLine: int, beginColumn: int) $/;"	m
newAddrOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newAddrOption(name: string, defval: u64, help: string) -> Option<u64> {$/;"	m
newAddrOption	$VIRGIL/lib/util/Option.v3	/^	def newAddrOption(name: string, val: u64) -> Option<u64> {$/;"	m
newAlloc	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newAlloc(ptrType: Type) -> Operator {$/;"	f
newApplyCompBinding	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def newApplyCompBinding(expr: VarExpr, receiver: Expr, comp: Operator) -> VarBinding {$/;"	m
newArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def newArgs(tempRp: int, numParams: int) -> Array<int> {$/;"	m
newArrayAlloc	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayAlloc(arrayType: Type) -> Operator {$/;"	f
newArrayAlloc	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def newArrayAlloc(arrayType: Type, source: Source, length: SsaInstr) -> SsaInstr {$/;"	m
newArrayGetElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayGetElem(arrayType: Type, indexType: IntType) -> Operator {$/;"	f
newArrayGetElemElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {$/;"	f
newArrayGetLength	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayGetLength(arrayType: Type) -> Operator {$/;"	f
newArrayInit	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayInit(arrayType: Type, length: int) -> Operator {$/;"	f
newArraySetElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArraySetElem(arrayType: Type, indexType: IntType) -> Operator {$/;"	f
newArraySetElemElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArraySetElemElem(arrayType: Type, indexType: Type, index: int) -> Operator {$/;"	f
newArrayTupleInit	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newArrayTupleInit(arrayType: Type, elems: int, length: int) -> Operator {$/;"	f
newBackend	$VIRGIL/aeneas/src/os/Linux.v3	/^	def newBackend: (Compiler, Program, MachProgram, MachDataWriter, Dwarf) -> MachBackend;$/;"	d
newBlock	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def newBlock() -> SsaBuilder {$/;"	m
newBlockMap	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def newBlockMap<T>() -> PartialMap<SsaBlock, T> {$/;"	f
newBoolOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newBoolOption(name: string, defval: bool, help: string) -> Option<bool> {$/;"	m
newBoolOption	$VIRGIL/lib/util/Option.v3	/^	def newBoolOption(name: string, val: bool) -> Option<bool> {$/;"	m
newBoundsCheck	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newBoundsCheck(rtype: Type) -> Operator {$/;"	f
newBuilder	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def newBuilder(block: SsaBlock) -> SsaBuilder {$/;"	m
newBuilder	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def newBuilder() -> SsaBuilder {$/;"	m
newByteArrayGetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newByteArrayGetField(offset: int, fieldType: Type, startType: Type) -> Operator {$/;"	f
newByteArraySetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newByteArraySetField(offset: int, fieldType: Type, startType: Type) -> Operator {$/;"	f
newCallAddress	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallAddress(rep: Mach_FuncRep) -> Operator {$/;"	f
newCallClassMethod	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallClassMethod(methodRef: IrSpec) -> Operator {$/;"	f
newCallClassSelector	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallClassSelector(methodRef: IrSpec) -> Operator {$/;"	f
newCallClassVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallClassVirtual(methodRef: IrSpec) -> Operator {$/;"	f
newCallClosure	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallClosure(ftype: Type) -> Operator {$/;"	f
newCallFunction	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallFunction(ftype: Type) -> Operator {$/;"	f
newCallKernel	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallKernel(kernel: Kernel, typeParams: Array<Type>, sig: Signature) -> Operator {$/;"	f
newCallMethod	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallMethod(methodRef: IrSpec) -> Operator {$/;"	f
newCallVariantSelector	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallVariantSelector(methodRef: IrSpec) -> Operator {$/;"	f
newCallVariantVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallVariantVirtual(methodRef: IrSpec) -> Operator {$/;"	f
newCallerIp	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallerIp(ptrType: Type) -> Operator {$/;"	f
newCallerSp	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCallerSp(ptrType: Type) -> Operator {$/;"	f
newClassAlloc	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassAlloc(newRef: IrSpec) -> Operator {$/;"	f
newClassAllocOp	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def newClassAllocOp(spec: IrSpec, funcType: Type, env: VstSsaEnv) -> Operator {$/;"	m
newClassGetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassGetField(fieldRef: IrSpec) -> Operator {$/;"	f
newClassGetMethod	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassGetMethod(methodRef: IrSpec) -> Operator {$/;"	f
newClassGetSelector	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassGetSelector(methodRef: IrSpec) -> Operator {$/;"	f
newClassGetVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassGetVirtual(methodRef: IrSpec) -> Operator {$/;"	f
newClassInitField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassInitField(fieldRef: IrSpec) -> Operator {$/;"	f
newClassSetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newClassSetField(fieldRef: IrSpec) -> Operator {$/;"	f
newClassref	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newClassref(name: string) -> int {$/;"	m
newClosure	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def newClosure(memberRef: IrSpec) -> JvmClass {$/;"	m
newClosureAdapter	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def newClosureAdapter(exactType: Type, implicitType: Type) -> JvmV3ClosureAdapterGen {$/;"	m
newCmp2	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def newCmp2(i: SsaInstr, cond: X86Cond) -> X86CmpMatch {$/;"	m
newCodeBuilder	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newCodeBuilder() -> JvmCodeBuilder {$/;"	m
newCompBinding	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def newCompBinding(expr: VarExpr, comp: Operator) -> VarBinding {$/;"	m
newComponentGetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newComponentGetField(fieldRef: IrSpec) -> Operator {$/;"	f
newComponentSetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newComponentSetField(fieldRef: IrSpec) -> Operator {$/;"	f
newConditionalThrow	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newConditionalThrow(exception: string) -> Operator {$/;"	f
newCreateClosure	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newCreateClosure(methodRef: IrSpec, closure: Type) -> Operator {$/;"	f
newEmptyClassAlloc	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newEmptyClassAlloc(classType: Type) -> Operator {$/;"	f
newEmptyClassAllocP	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newEmptyClassAllocP(classType: Type, paramTypes: Array<Type>) -> Operator {$/;"	f
newEmptyOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newEmptyOption(name: string, help: string) -> Option<bool> {$/;"	m
newEqual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newEqual(t: Type) -> Operator {$/;"	f
newExceptionDest	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def newExceptionDest(ex: string, source: Source) -> Addr {$/;"	m
newField	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newField(name: string, desc: string) -> JvmField {$/;"	m
newField	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def newField(prefix: string, ref: JvmHI_Ref, jtype: JvmType) {$/;"	m
newField	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^def newField(receiver: Type, fieldType: Type, facts: Fact.set) -> IrField {$/;"	f
newFieldref	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newFieldref(clname: string, fname: string, desc: string) -> int {$/;"	m
newFloat32ViewI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloat32ViewI(ft: Type) -> Operator {$/;"	f
newFloat64ViewI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloat64ViewI(ft: Type) -> Operator {$/;"	f
newFloatCastI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloatCastI(ft: Type, tt: Type) -> Operator {$/;"	f
newFloatPromoteI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloatPromoteI(ft: Type, tt: Type) -> Operator {$/;"	f
newFloatQueryI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloatQueryI(ft: Type, tt: Type) -> Operator {$/;"	f
newFloatRound	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloatRound(t: Type) -> Operator {$/;"	f
newFloatRoundI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newFloatRoundI(ft: Type, tt: Type) -> Operator {$/;"	f
newForgeClosure	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newForgeClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {$/;"	f
newForgeRange	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newForgeRange(elementType: Type, ptrType: Type) -> Operator {$/;"	f
newGraph	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var newGraph: SsaGraph;$/;"	d
newInit	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newInit(meth: IrMethod) -> Operator {$/;"	f
newIntCastF	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntCastF(ft: Type, tt: Type) -> Operator {$/;"	f
newIntEq	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntEq(t: Type) -> Operator {$/;"	f
newIntOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newIntOption(name: string, defval: int, help: string) -> Option<int> {$/;"	m
newIntOption	$VIRGIL/lib/util/Option.v3	/^	def newIntOption(name: string, val: int) -> Option<int> {$/;"	m
newIntQueryF	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntQueryF(ft: Type, tt: Type) -> Operator {$/;"	f
newIntRepCreate	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntRepCreate(ft: Type, tt: IntRepType) -> Operator {$/;"	f
newIntRepView	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntRepView(ft: IntRepType, tt: Type) -> Operator {$/;"	f
newIntTruncF	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntTruncF(ft: Type, tt: Type) -> Operator {$/;"	f
newIntViewI	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntViewI(ft: Type, tt: Type) -> Operator {$/;"	f
newIntWide	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newIntWide(op: Operator, normal: Array<Type>, result: Type) -> Operator {$/;"	f
newIr	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var newIr = IrModule.new();$/;"	d
newIrClass	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def newIrClass(ctype: Type, superClass: IrClass, decl: VstCompound) -> IrClass {$/;"	m
newIrClassWithSuper	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def newIrClassWithSuper(ctype: Type, decl: VstCompound) -> IrClass {$/;"	m
newIrItemMap	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def newIrItemMap<T>() -> HashMap<IrItem, T> {$/;"	f
newIrMethod	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def newIrMethod(m: VstMethod) -> IrMethod {$/;"	m
newIrSpec	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var newIrSpec: IrSpec;			\/\/ IrSpec with sets substituted in$/;"	d
newIrSpecMap	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def newIrSpecMap<T>() -> HashMap<IrSpec, T> {$/;"	f
newIrType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var newIrType: Type;$/;"	d
newLabel	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def newLabel() -> X86_64Label {$/;"	m
newLiteralFromIdent	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def newLiteralFromIdent(p: ParserState, id: VstIdent<TypeRef>, val: Val, t: Type) -> Literal {$/;"	f
newLivepoint	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def newLivepoint() -> int {$/;"	m
newLoop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def newLoop(h: SsaBlock) -> SsaLoopInfo {$/;"	m
newMap	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def newMap<T>() -> PartialMap<SsaInstr, T> {$/;"	f
newMap	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^def newMap<T>() -> HashMap<SsaLink, T> {$/;"	f
newMap	$VIRGIL/aeneas/src/types/Int.v3	/^	def newMap<V>() -> HashMap<int, V> {$/;"	f
newMap	$VIRGIL/lib/util/Strings.v3	/^	def newMap<V>() -> HashMap<string, V> {$/;"	f
newMatcherOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newMatcherOption(name: string, help: string) -> Option<VstMatcher> {$/;"	m
newMethod	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var newMethod: IrMethod;		\/\/ new IrMethod$/;"	d
newMethod	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newMethod(name: string, desc: string) -> JvmMethod {$/;"	m
newMethodref	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newMethodref(clname: string, fname: string, desc: string) -> int {$/;"	m
newNormRangeGetElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newNormRangeGetElem(arrayType: Type, indexType: Type) -> Operator {$/;"	f
newNormRangeGetElemElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newNormRangeGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {$/;"	f
newNormRangeSetElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newNormRangeSetElem(arrayType: Type, indexType: Type) -> Operator {$/;"	f
newNormRangeSetElemElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newNormRangeSetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {$/;"	f
newNotEqual	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^def newNotEqual(t: Type) -> Operator {$/;"	f
newNullCheck	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newNullCheck(rtype: Type) -> Operator {$/;"	f
newOp	$VIRGIL/aeneas/src/os/Kernel.v3	/^def newOp(kernel: Kernel, retType: Type) -> Operator {$/;"	f
newOp	$VIRGIL/aeneas/src/types/Float.v3	/^def newOp(op: Opcode, typeArgs: Array<Type>, sig: Signature) -> Operator {$/;"	f
newOp0	$VIRGIL/aeneas/src/core/Operator.v3	/^	private def newOp0(opcode: Opcode, typeArgs: Array<Type>, paramTypes: Array<Type>, returnType: Type) -> Operator {$/;"	f
newOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newOption<T>(name: string, defval: T, typename: string, parseFun: string -> T, help: string) -> Option<T> {$/;"	m
newOption	$VIRGIL/lib/util/Option.v3	/^	def newOption<T>(name: string, val: T, parseFun: string -> T) -> Option<T> {$/;"	m
newParam	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	private def newParam(p: ParamDecl) -> SsaParam {$/;"	m
newPathOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newPathOption(name: string, defval: string, help: string) -> Option<string> {$/;"	m
newPhi	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {$/;"	m
newPhi2	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def newPhi2(t: Type, a: SsaInstr, b: SsaInstr) -> SsaPhi {$/;"	m
newPtrAdd	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAdd(ptrType: Type, it: IntType) -> Operator {$/;"	f
newPtrAdd	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def newPtrAdd(pt: Type) -> Operator { \/\/ XXX: cache Pointer add operator$/;"	m
newPtrAddRangeStart	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAddRangeStart(ptrType: Type) -> Operator {$/;"	f
newPtrAtArrayElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtArrayElem(arrayType: Type, indexType: IntType, ptrType: Type) -> Operator {$/;"	f
newPtrAtComponentField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtComponentField(spec: IrSpec, ptrType: Type) -> Operator {$/;"	f
newPtrAtContents	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtContents(rangeType: Type, ptrType: Type) -> Operator {$/;"	f
newPtrAtEnd	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtEnd(objType: Type, ptrType: Type) -> Operator {$/;"	f
newPtrAtLength	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtLength(arrayType: Type, ptrType: Type) -> Operator {$/;"	f
newPtrAtObject	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtObject(objType: Type, ptrType: Type) -> Operator {$/;"	f
newPtrAtObjectField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtObjectField(spec: IrSpec, ptrType: Type) -> Operator {$/;"	f
newPtrAtRangeElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtRangeElem(rangeType: Type, indexType: IntType, ptrType: Type) -> Operator {$/;"	f
newPtrAtRef	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtRef(layoutType: Type, ptrType: Type) -> Operator {$/;"	f
newPtrAtRefLayoutField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrAtRefLayoutField(refType: Type, offset: int, ptrType: Type) -> Operator {$/;"	f
newPtrCmpSwp	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrCmpSwp(ptrType: Type, valueType: Type) -> Operator {$/;"	f
newPtrLoad	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {$/;"	f
newPtrLt	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrLt(ptrType: Type) -> Operator {$/;"	f
newPtrLteq	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrLteq(ptrType: Type) -> Operator {$/;"	f
newPtrStore	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {$/;"	f
newPtrSub	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newPtrSub(ptrType: Type, it: IntType) -> Operator {$/;"	f
newRaClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def newRaClass(oldType: Type, ic: IrClass, parent: RaClass) -> RaClass {$/;"	m
newRangeFromPlus	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRangeFromPlus(rangeType: Type, startType: Type, lengthType: Type) -> Operator {$/;"	f
newRangeFromTo	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRangeFromTo(rangeType: Type, startType: Type, endType: Type) -> Operator {$/;"	f
newRangeGetLength	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRangeGetLength(rangeType: Type) -> Operator {$/;"	f
newRangeStartFromPointer	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRangeStartFromPointer(rangeType: Type, ptrType: PointerType) -> Operator {$/;"	f
newRangeStartPlusIndex	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRangeStartPlusIndex(rangeType: Type, indexType: IntType) -> Operator {$/;"	f
newRecord	$VIRGIL/aeneas/src/core/Program.v3	/^	def newRecord(rtype: Type, size: int) -> Record {$/;"	m
newRecord	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def newRecord(rval: Record) -> JvmHI_Record {$/;"	m
newRecordMap	$VIRGIL/aeneas/src/v3/V3.v3	/^	def newRecordMap<T>() -> HashMap<Record, T> {$/;"	f
newRefEq	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefEq(t: Type) -> Operator {$/;"	f
newRefLayoutAt	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutAt(refType: RefType) -> Operator {$/;"	f
newRefLayoutAtRepeatedField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutAtRepeatedField(refType: RefType, offset: int, scale: int, max: int, result: RefType) -> Operator {$/;"	f
newRefLayoutGetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutGetField(refType: RefType, offset: int, fieldType: Type) -> Operator {$/;"	f
newRefLayoutGetRepeatedField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutGetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type) -> Operator {$/;"	f
newRefLayoutIn	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutIn(refType: RefType, offset: int, result: RefType) -> Operator {$/;"	f
newRefLayoutOf	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutOf(refType: RefType) -> Operator {$/;"	f
newRefLayoutSetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutSetField(refType: RefType, offset: int, fieldType: Type) -> Operator {$/;"	f
newRefLayoutSetRepeatedField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newRefLayoutSetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type) -> Operator {$/;"	f
newSegmentLoad	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def newSegmentLoad(header: MachO_Header, name: string, prot: int) ->  MachO_SegmentLoad {$/;"	m
newSegmentLoad	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def newSegmentLoad(header: MachO_Header, name: string, prot: int) ->  MachO_SegmentLoad {$/;"	m
newShadowSpTmp	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def newShadowSpTmp() -> VReg;					\/\/ arch-specific$/;"	m
newShadowSpTmp	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def newShadowSpTmp() -> VReg {$/;"	m
newSizeOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newSizeOption(name: string, defval: u32, help: string) -> Option<u32> {$/;"	m
newSizeOption	$VIRGIL/lib/util/Option.v3	/^	def newSizeOption(name: string, val: u32) -> Option<u32> {$/;"	m
newSource	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def newSource(source: Source) -> Source {$/;"	m
newSsaConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def newSsaConst(index: int, t: Type, v: Val, facts: Fact.set) -> SsaConst {$/;"	m
newStaticMethod	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newStaticMethod(name: string, desc: string) -> JvmMethod {$/;"	m
newString	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newString(bytes: string) -> int {$/;"	m
newStringOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def newStringOption(name: string, defval: string, help: string) -> Option<string> {$/;"	m
newStringOption	$VIRGIL/lib/util/Option.v3	/^	def newStringOption(name: string, val: string) -> Option<string> {$/;"	m
newSuperClause	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def newSuperClause(where: FileRange) -> SuperClause {$/;"	f
newSystemCall	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newSystemCall(syscall: SystemCall, paramTypes: Array<Type>, returnType: Type) -> Operator {$/;"	f
newThisParam	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def newThisParam() -> ParamDecl {$/;"	m
newTmp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def newTmp() -> int {$/;"	m
newTmp	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def newTmp(t: Type) -> VReg {$/;"	m
newTmpVReg	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def newTmpVReg(wasmType: WasmType) -> VReg {$/;"	m
newTupleCast	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def newTupleCast(ff: Type, tt: Type) -> TypeCast {$/;"	f
newTupleCreate	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newTupleCreate(tupleType: Type) -> Operator {$/;"	f
newTupleGetElem	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newTupleGetElem(tupleType: Type, index: int) -> Operator {$/;"	f
newTupleQuery	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def newTupleQuery(ff: Type, tt: Type) -> TypeQuery {$/;"	f
newType	$VIRGIL/aeneas/src/types/Function.v3	/^	def newType(paramType: Type, returnType: Type) -> Type {$/;"	f
newType	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def newType(types: List<Type>) -> Type {$/;"	f
newType	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	def newType(elementType: Type) -> Type {$/;"	f
newType	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def newType(elementType: Type) -> Type {$/;"	f
newTypeCast	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newTypeCast(f: Type, t: Type) -> Operator {$/;"	f
newTypeCast	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def newTypeCast(fromType: Type, toType: Type) -> TypeCast {$/;"	f
newTypeMap	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def newTypeMap<T>() -> HashMap<Type, T> {$/;"	f
newTypePairMap	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def newTypePairMap<T>() -> PartialMap<(Type, Type), T> {$/;"	f
newTypeParam	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def newTypeParam(token: Token, typeCache: TypeCache) -> TypeParamType {$/;"	f
newTypeParamWithConstraint	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def newTypeParamWithConstraint(token: Token, typeCache: TypeCache,$/;"	f
newTypeParams	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	var newTypeParams: List<TypeParamType>;$/;"	d
newTypeQuery	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newTypeQuery(f: Type, t: Type) -> Operator {$/;"	f
newTypeQuery	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def newTypeQuery(fromType: Type, toType: Type) -> TypeQuery {$/;"	f
newTypeSubsume	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {$/;"	f
newTypeVar	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def newTypeVar(typeParam: TypeParamType, token: Token) -> Type {$/;"	m
newUnpackClosure	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newUnpackClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {$/;"	f
newUtf8	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newUtf8(bytes: string) -> int {$/;"	m
newVReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def newVReg(i: SsaInstr) -> VReg {$/;"	m
newVariantGetField	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantGetField(fieldRef: IrSpec) -> Operator {$/;"	f
newVariantGetMethod	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantGetMethod(methodRef: IrSpec) -> Operator {$/;"	f
newVariantGetSelector	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantGetSelector(methodRef: IrSpec) -> Operator {$/;"	f
newVariantGetTag	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantGetTag(vtype: Type) -> Operator {$/;"	f
newVariantGetVirtual	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantGetVirtual(methodRef: IrSpec) -> Operator {$/;"	f
newVariantReplaceNull	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVariantReplaceNull(vtype: Type) -> Operator {$/;"	f
newVreg	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var newVreg: VReg;$/;"	d
newVstSugar	$VIRGIL/aeneas/src/core/Operator.v3	/^	def newVstSugar(op: VstOperator, typeParams: Array<Type>, paramTypes: Array<Type>, result: Type) -> Operator {$/;"	f
newarray	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newarray(elementType: JvmType) {$/;"	m
newempty	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newempty(jclass: JvmClass) {$/;"	m
newobject	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def newobject(jclass: JvmClass) {$/;"	m
next	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var next: IcFrame;$/;"	d
next	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def next(t: Type) -> IrSpec {$/;"	m
next	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var next: LsraPoint;$/;"	d
next	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	var next: ArchInstr;$/;"	d
next	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var next: VReg;			\/\/ next link for list management$/;"	d
next	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var next: SsaLink;$/;"	d
next	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var next: SsaLink;			\/\/ instruction after the current instruction$/;"	d
next	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def next() -> byte {$/;"	m
next	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var next = Array<int>.new(INITIAL);$/;"	d
next	$VIRGIL/lib/util/Edge.v3	/^	var next: Edge<T>;	\/\/ the forward link for the use list$/;"	d
next	$VIRGIL/lib/util/Map.v3	/^	var next: Bucket<K, V>;$/;"	d
next	$VIRGIL/lib/util/Random.v3	/^	def next() -> int {$/;"	f
next	$VIRGIL/lib/util/Stack.v3	/^	def next() -> T {$/;"	m
next	$VIRGIL/lib/util/UID.v3	/^	var next: int; \/\/ a global counter for unique ids$/;"	d
next	$VIRGIL/lib/util/WorkQueue.v3	/^	var next: WorkUnit;$/;"	d
nextId	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def nextId() -> int {$/;"	m
nextInstr	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def nextInstr(i: SsaLink) -> SsaInstr {$/;"	m
noErrors	$VIRGIL/aeneas/src/main/Error.v3	/^	var noErrors: bool = true;$/;"	d
noMovesNeeded	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def noMovesNeeded(start: int, end: int) -> bool {$/;"	m
nodes	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def nodes = Array<Node>.new(varsCnt);$/;"	d
nonSsaVars	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var nonSsaVars: Array<VarDecl>;		\/\/ variables that are assigned more than once$/;"	d
none	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def none = '\x00';$/;"	d
none	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var none: bool;$/;"	d
none	$VIRGIL/aeneas/src/types/Float.v3	/^	def none() -> Operator {$/;"	m
none	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def none() -> bool { return this.tag == 0; }$/;"	m
nonnull	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var nonnull: List<SsaInstr>;$/;"	d
nonnull	$VIRGIL/lib/util/Strings.v3	/^	def nonnull(s: string) -> string {$/;"	f
nontrivial	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def nontrivial() -> bool { return initIndex > -2; }$/;"	m
nonzero	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def nonzero(tn: TypeNorm) -> TypeNorm {$/;"	m
nop	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def nop() -> SsaConst {$/;"	m
nop	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def nop() -> this { emit_i_type(7, RiscV64Gpr.X0, 3, RiscV64Gpr.X0, 0); }$/;"	m
nop	$VIRGIL/lib/util/Utf8.v3	/^	private def nop(u: u32) { }$/;"	f
nop1	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def nop1() -> this {$/;"	m
nop2	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def nop2() -> this {$/;"	m
nop3	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def nop3() -> this {$/;"	m
nop4	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def nop4() -> this {$/;"	m
norm	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def norm(t: Type) -> TypeNorm {$/;"	m
norm	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var norm: IrMethod;$/;"	d
norm	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def norm: ReachabilityNormalizer;$/;"	d
norm2	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def norm2(i: SsaApplyOp) {$/;"	m
normArgs	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArgs(funcNorm: FuncNorm, args: Array<SsaInstr>) -> Array<SsaInstr> {$/;"	m
normArrayAlloc	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArrayAlloc(i_old: SsaApplyOp, op: Operator) {$/;"	m
normArrayGetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArrayGetElem(i_old: SsaApplyOp, op: Operator) {$/;"	m
normArrayGetLength	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArrayGetLength(i_old: SsaApplyOp, op: Operator) {$/;"	m
normArrayInit	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArrayInit(i_old: SsaApplyOp, op: Operator, len: int) {$/;"	m
normArrayOrRangeGetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArrayOrRangeGetElem(i_old: SsaApplyOp, arrayNorm: ArrayNorm, indexType: IntType, width: int, ai_new: Array<SsaInstr>, index: SsaInstr, facts: Fact.set) {$/;"	m
normArraySetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normArraySetElem(i_old: SsaApplyOp, op: Operator) {$/;"	m
normAsTupleVal	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normAsTupleVal(v: Val, tn: TypeNorm) -> Val {$/;"	m
normBinopArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private def normBinopArgs(args: Array<int>) -> Array<int> {$/;"	m
normBoundsCheck	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normBoundsCheck(i_old: SsaApplyOp, op: Operator) {$/;"	m
normCall	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normCall(i_old: SsaApplyOp, funcNorm: FuncNorm, newOp: Operator, ai_new: Array<SsaInstr>) -> SsaInstr {$/;"	m
normClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var normClass: IrClass;			\/\/ normalized class$/;"	d
normClassAlloc	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normClassAlloc(i_old: SsaApplyOp, m: IrMethod, op: Operator) {$/;"	m
normClassRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normClassRecord(rc: RaClass, oldRecord: Record, array: Array<Val>) {$/;"	m
normClassSetField	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normClassSetField(i_old: SsaApplyOp, field: IrField, op: Operator, init: bool) {$/;"	m
normCode	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normCode(rm: RaMethod) {$/;"	m
normCode	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def normCode(context: SsaContext, rm: RaMethod) -> bool {$/;"	m
normComplexArrayRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normComplexArrayRecord(rt: ArrayNorm, oldRecord: Record, newRecords: Array<Record>) {$/;"	m
normComponentGetField	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normComponentGetField(i_old: SsaApplyOp, field: IrField, op: Operator) {$/;"	m
normComponentSetField	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normComponentSetField(i_old: SsaApplyOp, field: IrField, op: Operator) {$/;"	m
normConst	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normConst(i_old: SsaConst) {$/;"	m
normConstAsArray	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normConstAsArray(tn: TypeNorm, v: SsaConst) -> Array<SsaInstr> {$/;"	m
normDefault	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normDefault(i_old: SsaApplyOp, op: Operator) {$/;"	m
normEqual	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normEqual(i_old: SsaApplyOp, tn: TypeNorm, refs: Array<SsaInstr>) -> SsaInstr {$/;"	m
normEqual1	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normEqual1(i_old: SsaApplyOp, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
normEqualOp	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normEqualOp(i_old: SsaApplyOp, op: Operator) {$/;"	m
normFields	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var normFields: Array<Array<Type>>;$/;"	d
normFuncType	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def normFuncType(t: Type) -> FuncNorm {$/;"	m
normGetField	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField, op: Operator) {$/;"	m
normId	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normId(i_old: SsaApplyOp) -> SsaInstr {$/;"	m
normIndex	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var normIndex = -1;			\/\/ new method index$/;"	d
normIndex	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var normIndex = -1;$/;"	d
normIndices	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var normIndices: (int, int) = (-1, -1);$/;"	d
normInputs	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normInputs(i_old: SsaInstr) -> SsaInstr {$/;"	m
normIntIntoArray	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def normIntIntoArray(tt: IntType, v: int, array: Array<Val>, index: int) {$/;"	m
normIntType	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normIntType(t: Type) -> IntNorm {$/;"	m
normIntViewI	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normIntViewI(i_old: SsaApplyOp, op: Operator) {$/;"	m
normLongIntoArray	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def normLongIntoArray(tt: IntType, v: long, array: Array<Val>, index: int) {$/;"	m
normMethods	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var normMethods: Array<IrMethod>;	\/\/ normalized methods$/;"	d
normMixedArrayRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normMixedArrayRecord(rt: ArrayNorm, oldRecord: Record, newRecord: Record) {$/;"	m
normNullCheck	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normNullCheck(oldApp: SsaApplyOp, op: Operator) {$/;"	m
normOf	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def normOf<T>(r: Range<T>) -> Range<T> {$/;"	m
normPhi	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normPhi(i_old: SsaPhi) {$/;"	m
normRangeFromPlus	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normRangeFromPlus(i_old: SsaApplyOp, op: Operator) {$/;"	m
normRangeFromTo	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normRangeFromTo(i_old: SsaApplyOp, op: Operator) {$/;"	m
normRangeGetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normRangeGetElem(i_old: SsaApplyOp, op: Operator) {$/;"	m
normRangeSetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normRangeSetElem(i_old: SsaApplyOp, op: Operator) {$/;"	m
normRecordAsArray	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	private def normRecordAsArray(rc: RaClass, oldRecord: Record, array: Array<Val>) {$/;"	m
normRef1	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normRef1(e: SsaDfEdge) -> SsaInstr {$/;"	m
normRefN	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normRefN(e: SsaDfEdge) -> Array<SsaInstr> {$/;"	m
normRefs	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normRefs(ai_old: Array<SsaDfEdge>) -> Array<SsaInstr> {$/;"	m
normReturnType	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def normReturnType(op: Operator) -> TypeNorm {$/;"	m
normSimpleArrayRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normSimpleArrayRecord(record: Record) {$/;"	m
normSimpleEqualOp	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normSimpleEqualOp(i_old: SsaApplyOp, op: Operator) {$/;"	m
normSimpleVal	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normSimpleVal(tn: TypeNorm, v: Val) -> Val {$/;"	m
normSingleArg	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def normSingleArg(op: Operator, args: Array<SsaInstr>) -> Array<SsaInstr> {$/;"	m
normTuple	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def normTuple(t: Type) -> TypeNorm {$/;"	m
normTupleGetElem	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTupleGetElem(i_old: SsaInstr, args: Array<SsaDfEdge>, op: Operator, index: int) {$/;"	m
normTupleMap	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def normTupleMap = TypeUtil.newTypeMap<TypeNorm>();$/;"	d
normType	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def normType(t: Type) -> IntNorm {$/;"	m
normType	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def normType(t: Type) -> TypeNorm {$/;"	m
normType	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normType(t: Type) -> TypeNorm {$/;"	m
normType	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normType(t: Type) -> TypeNorm;$/;"	m
normType	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def normType(t: Type) -> TypeNorm {$/;"	m
normType	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def normType(t: Type) -> TypeNorm;$/;"	m
normType1	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normType1(t: Type) -> Type {$/;"	m
normTypeArg	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	private def normTypeArg(op: Operator, index: int) -> TypeNorm {$/;"	m
normTypeCast	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTypeCast(i_old: SsaApplyOp, op: Operator) {$/;"	m
normTypeCastRec	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTypeCastRec(ai_old: Array<SsaInstr>, offset: int, atn: TypeNorm, rtn: TypeNorm, result: Vector<SsaInstr>) {$/;"	m
normTypeQ	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normTypeQ(t: Type) -> bool {$/;"	m
normTypeQuery	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTypeQuery(i_old: SsaApplyOp, op: Operator) {$/;"	m
normTypeQueryRec	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTypeQueryRec(ai_old: Array<SsaInstr>, offset: int, atn: TypeNorm, rtn: TypeNorm, left: SsaInstr) -> SsaInstr {$/;"	m
normTypeSubsume	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normTypeSubsume(i_old: SsaApplyOp, op: Operator) {$/;"	m
normTypeTuple	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def normTypeTuple(t: Type) -> TupleNorm {$/;"	m
normUnboxedVariantCaseEqual	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normUnboxedVariantCaseEqual(i_old: SsaApplyOp, vn: VariantNorm, refs: Array<SsaInstr>) -> SsaInstr {$/;"	m
normUnboxedVariantEqual	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normUnboxedVariantEqual(i_old: SsaApplyOp, vn: VariantNorm, refs: Array<SsaInstr>) -> SsaInstr {$/;"	m
normValIntoArray	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normValIntoArray(v: Val, tn: TypeNorm, array: Array<Val>, index: int) {$/;"	m
normVariant	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def normVariant(t: Type, rc: RaClass) -> TypeNorm {$/;"	m
normVariantEqual	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normVariantEqual(i_old: SsaApplyOp, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
normVariantGetTag	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def normVariantGetTag(vn: VariantNorm, args: Range<SsaInstr>) -> SsaInstr {$/;"	m
normVariantVal	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normVariantVal(vn: VariantNorm, x: Record) -> Array<Val> {$/;"	m
norm_binop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def norm_binop(i: SsaApplyOp) -> Val {$/;"	m
norm_intbinop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def norm_intbinop(i: SsaApplyOp) -> int {$/;"	m
normalize	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normalize() {$/;"	m
normalizeArgs	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def normalizeArgs(paramTypes: Array<Type>, args: Array<SsaInstr>) -> Array<SsaInstr> {$/;"	m
normalizeMethodRef	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normalizeMethodRef(spec: IrSpec) -> (RaMethod, IrSpec) {$/;"	m
normalizeRecord	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def normalizeRecord(rc: RaClass, vn: VariantNorm, input: Array<Val>, output: Array<Val>) {$/;"	m
not	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def not(a: X86Rm) { emitb_rm(0xF7, a, 2); }$/;"	m
notSpillable	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var notSpillable: bool;		\/\/ true if this var cannot be spill anymore$/;"	d
notTooMany	$VIRGIL/aeneas/src/main/Error.v3	/^	var notTooMany: bool = true;$/;"	d
not_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def not_m(a: X86_64Addr) -> this {$/;"	m
not_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def not_r(a: X86_64Gpr) -> this {$/;"	m
notwider	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def notwider(dir: UnificationDir) -> UnificationDir {$/;"	f
nreloc	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var nreloc: int;$/;"	d
nsects	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var nsects: int;$/;"	d
ntMap	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def ntMap = Int.newMap<int>();$/;"	d
nullCheck	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def nullCheck() -> bool {$/;"	m
nullConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def nullConst(t: Type) -> SsaConst {$/;"	m
nullReceiver	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def nullReceiver() -> SsaConst {$/;"	m
nullcheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def nullcheck(i: SsaApplyOp) -> SsaInstr {$/;"	m
nullity	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def nullity(app: SsaInstr, obj: SsaInstr) -> Fact.set {$/;"	m
numArgs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def numArgs() -> int {$/;"	m
numCases	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def numCases = V3.classDecl(root.ctype).cases.length;$/;"	d
numComponents	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numComponents: int;				\/\/ total number of components$/;"	d
numErrors	$VIRGIL/aeneas/src/main/Error.v3	/^	var numErrors: int;$/;"	d
numFields	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def numFields(ctype: Type) -> int {$/;"	m
numFields	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numFields: int;$/;"	d
numFiles	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var numFiles: int;$/;"	d
numFunctions	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var numFunctions = 0;$/;"	d
numImports	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var numImports = 0;$/;"	d
numInstrs	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var numInstrs = 0;$/;"	d
numLivePoints	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var numLivePoints: int;$/;"	d
numLivepoints	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var numLivepoints = 0;$/;"	d
numLoops	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numLoops: int;$/;"	d
numMapped	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var numMapped = 0;$/;"	d
numMethods	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var numMethods: int;$/;"	d
numMethods	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numMethods: int;$/;"	d
numNonSsa	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numNonSsa: int;$/;"	d
numParams	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numParams: int;$/;"	d
numRegs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var numRegs: int;$/;"	d
numStrings	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var numStrings: int;				\/\/ total number of string constants$/;"	d
numValues	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var numValues: int;		\/\/ used in SSA interpreter$/;"	d
numVars	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def numVars(i: SsaInstr) -> int {$/;"	m
number	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	private def number(s: SsaBlock) {$/;"	m
numberBlock	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def numberBlock(s: SsaBlock, loop: SsaLoopInfo) {$/;"	m
numberLoop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def numberLoop(s: SsaBlock, newLoop: SsaLoopInfo, loop: SsaLoopInfo) {$/;"	m
numberSucc	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def numberSucc(s: SsaBlock, loop: SsaLoopInfo) {$/;"	m
numberVariant	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def numberVariant(rc: RaClass) {$/;"	m
o_threshold	$VIRGIL/lib/math/Math.v3	/^def o_threshold	= 7.09782712893383973096e+2;		\/* 40862E42 FEFA39EF *\/$/;"	d
objExpr	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def objExpr(useThis: bool, token: Token, expr: VarExpr) -> Expr {$/;"	m
objLoc	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var objLoc: int;$/;"	d
objLoc	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	var objLoc: int;$/;"	d
objReg	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var objReg: Arm64Gpr;$/;"	d
objReg	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var objReg: X86_64Gpr;$/;"	d
objectTag	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def objectTag(t: Type) -> Val {$/;"	m
of1	$VIRGIL/lib/util/Vector.v3	/^	def of1<T>(e: T) -> Vector<T> {$/;"	f
ofExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def ofExpr(e: Expr) -> FileRange {$/;"	f
ofN	$VIRGIL/lib/util/Vector.v3	/^	def ofN<T>(a: Array<T>) -> Vector<T> {$/;"	f
ofStmt	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def ofStmt(s: Stmt) -> FileRange {$/;"	f
offset	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var offset: int;$/;"	d
offset	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var offset: int;$/;"	d
offset	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def offset() -> int {$/;"	m
offset	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def offset: Literal;$/;"	d
offsets	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def offsets: Array<int>;$/;"	d
offsets	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var offsets: Array<int>;$/;"	d
oldIr	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def oldIr = prog.ir;$/;"	d
oldTypeParams	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	var oldTypeParams: List<Type>;$/;"	d
onEOF	$VIRGIL/lib/util/DataReader.v3	/^	var onEOF = DataReader.setEOFError;	\/\/ EOF callback$/;"	d
onEntry	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def onEntry(meth: IrMethod, time: int) {$/;"	m
onError	$VIRGIL/lib/util/DataReader.v3	/^	var onError = DataReader.setFirstError;	\/\/ error callback$/;"	d
onError	$VIRGIL/lib/util/TextReader.v3	/^	var onError = TextReader.setFirstError;	\/\/ error callback$/;"	d
onGen	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def onGen(memberRef: IrSpec, icm: IcMethod) {$/;"	m
onGen	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def onGen(memberRef: IrSpec, icm: IcMethod) {$/;"	m
onGen	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def onGen(memberRef: IrSpec, icm: IcMethod) {$/;"	m
onGen	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def onGen(memberRef: IrSpec) {$/;"	m
onGen	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def onGen(memberRef: IrSpec) {$/;"	m
onGen	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	def onGen(memberRef: IrSpec) {$/;"	m
onRet	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def onRet(time: int) {$/;"	m
onSocketOpen	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def onSocketOpen() -> NetResult<void> {$/;"	m
oneConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def oneConst() -> SsaConst {$/;"	m
ones	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	private def ones = Arm64Gpr.new("", "", 0x1F); \/\/ register with all ones for regnum$/;"	d
onstack	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	var onstack: bool;$/;"	d
onstack	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var onstack: bool;$/;"	d
op1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def op1(opcode: byte, operand: int) {$/;"	m
op2	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def op2(opcode: byte, operand: int) {$/;"	m
opAbs	$VIRGIL/aeneas/src/types/Float.v3	/^	def opAbs = newOp(Opcode.FloatAbs(ft.is64), typeArgs, unopSig);$/;"	d
opAdd	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opAdd = V3Op.newPtrAdd(ptrType, it);$/;"	d
opAdd	$VIRGIL/aeneas/src/types/Float.v3	/^	def opAdd = newOp(Opcode.FloatAdd(ft.is64), typeArgs, binopSig);$/;"	d
opAdd	$VIRGIL/aeneas/src/types/Int.v3	/^	def opAdd() -> Operator { return opcache().arith(V3Infix.Add, Opcode.IntAdd); }$/;"	m
opAnd	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def opAnd(left: SsaInstr, right: SsaInstr) -> SsaInstr {$/;"	m
opAnd	$VIRGIL/aeneas/src/types/Int.v3	/^	def opAnd() -> Operator { return opcache().arith(V3Infix.And, Opcode.IntAnd); }$/;"	m
opArrayAlloc	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opArrayAlloc(arrayType: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opArrayGetElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opArrayGetElem(arrayType: Type, indexType: IntType, facts: Fact.set, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opArrayGetLength	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opArrayGetLength(arrayType: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opArrayInit	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opArrayInit(arrayType: Type, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opArraySetElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opArraySetElem(arrayType: Type, indexType: IntType, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {$/;"	m
opBitwiseNeg	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBitwiseNeg(it: IntType, e: SsaInstr) -> SsaInstr {$/;"	m
opBoolAnd	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opBoolAnd = Operator.new(Opcode.BoolAnd, arr_v, sig_zz_z);$/;"	d
opBoolAnd	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoolAnd(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBoolAnd	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def opBoolAnd(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBoolAnd0	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoolAnd0(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBoolEq	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opBoolEq = Operator.new(Opcode.BoolEq, arr_z, sig_zz_z);$/;"	d
opBoolNot	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opBoolNot = Operator.new(Opcode.BoolNot, arr_v, sig_z_z);$/;"	d
opBoolNot	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoolNot(x: SsaInstr) -> SsaInstr {$/;"	m
opBoolOr	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opBoolOr = Operator.new(Opcode.BoolOr, arr_v, sig_zz_z);$/;"	d
opBoolOr	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoolOr(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBoolOr0	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoolOr0(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBoundsCheck	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opBoundsCheck(rtype: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opBuilder	$VIRGIL/aeneas/src/core/Program.v3	/^	var opBuilder: IrOpMethodBuilder;$/;"	d
opBuilder	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def opBuilder: IrOpMethodBuilder;	\/\/ builder for IrOpMethods$/;"	d
opByteArrayGetField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opByteArrayGetField(fieldType: Type, startType: Type, offset: int, facts: Fact.set, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opByteArraySetField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opByteArraySetField(fieldType: Type, startType: Type, offset: int, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {$/;"	m
opCallClosure	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opCallClosure(ftype: Type, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opCallMethod	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opCallMethod(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opCallVirtual	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opCallVirtual(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opCeil	$VIRGIL/aeneas/src/types/Float.v3	/^	def opCeil = newOp(Opcode.FloatCeil(ft.is64), typeArgs, unopSig);$/;"	d
opClassAlloc	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opClassAlloc(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opClassSetField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opClassSetField(f: IrSpec, x: SsaInstr, v: SsaInstr, init: bool) -> SsaInstr {$/;"	m
opCmpSwp	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opCmpSwp = V3Op.newPtrCmpSwp(ptrType, typeParam);$/;"	d
opComponentSetField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opComponentSetField(f: IrSpec, x: SsaInstr, v: SsaInstr) -> SsaInstr {$/;"	m
opConditionalThrow	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opConditionalThrow(ex: string, x: SsaInstr) -> SsaInstr {$/;"	m
opCreateClosure	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opCreateClosure(m: IrSpec, x: SsaInstr) -> SsaInstr {$/;"	m
opDiv	$VIRGIL/aeneas/src/types/Float.v3	/^	def opDiv = newOp(Opcode.FloatDiv(ft.is64), typeArgs, binopSig);$/;"	d
opDiv	$VIRGIL/aeneas/src/types/Int.v3	/^	def opDiv() -> Operator { return opcache().arith(V3Infix.Div, Opcode.IntDiv); }$/;"	m
opDstReg	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private var opDstReg: int;$/;"	d
opEnumSetHas	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opEnumSetHas(etc: EnumSetType, set: SsaInstr, e: SsaInstr) -> SsaInstr {$/;"	m
opEq	$VIRGIL/aeneas/src/types/Int.v3	/^	def opEq() -> Operator { return opcache().compare(V3Infix.EqEq, Opcode.IntEq); }$/;"	m
opEqual	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opEqual	$VIRGIL/aeneas/src/types/Float.v3	/^	def opEqual = newOp(Opcode.FloatEq(ft.is64), typeArgs, cmpSig);$/;"	d
opEqualOf	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opEqualOf(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opExponent	$VIRGIL/aeneas/src/types/Float.v3	/^	def opExponent = V3Op.newVstSugar(VstOperator.FloatExponent, arr_t, arr_t, Int.getType(true, ft.exp_width));$/;"	d
opFloatBitEq	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opFloatBitEq(isDouble: bool, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opFloatBitEq32	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatBitEq32 = newOp0(Opcode.FloatBitEq(false), arr_f, arr_ff, type_z);$/;"	d
opFloatBitEq64	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatBitEq64 = newOp0(Opcode.FloatBitEq(true), arr_d, arr_dd, type_z);$/;"	d
opFloatBitField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opFloatBitField(op: Operator, ft: FloatType, shift: byte, plus: int, x: SsaInstr) -> SsaInstr {$/;"	m
opFloatCastD	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatCastD = newOp0(Opcode.FloatCastD, arr_d, arr_d, type_f);$/;"	d
opFloatPromoteF	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatPromoteF = newOp0(Opcode.FloatPromoteF, arr_f, arr_f, type_d);$/;"	d
opFloatQueryD	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatQueryD = newOp0(Opcode.FloatQueryD, arr_d, arr_d, type_z);$/;"	d
opFloatRoundD	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opFloatRoundD = newOp0(Opcode.FloatRoundD, arr_v, arr_d, type_f);$/;"	d
opFloor	$VIRGIL/aeneas/src/types/Float.v3	/^	def opFloor = newOp(Opcode.FloatFloor(ft.is64), typeArgs, unopSig);$/;"	d
opFraction	$VIRGIL/aeneas/src/types/Float.v3	/^	def opFraction = V3Op.newVstSugar(VstOperator.FloatFraction, arr_t, arr_t, Int.getType(false, ft.fraction_width));$/;"	d
opGetField	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opGetField(f: IrSpec, x: SsaInstr) -> SsaInstr {$/;"	m
opGetSelector	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opGetSelector(m: IrSpec, x: SsaInstr) -> SsaInstr {$/;"	m
opGetVirtual	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opGetVirtual(m: IrSpec, x: SsaInstr) -> SsaInstr {$/;"	m
opGt	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opGt = V3Op.newVstSugar(VstOperator.Commute(opLt), opLt.typeArgs, opLt.sig.paramTypes, Bool.TYPE);$/;"	d
opGt	$VIRGIL/aeneas/src/types/Float.v3	/^	def opGt = V3Op.newVstSugar(VstOperator.Commute(opLt), arr_t, [ft, ft], Bool.TYPE);$/;"	d
opGteq	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opGteq = V3Op.newVstSugar(VstOperator.Commute(opLteq), opLt.typeArgs, opLt.sig.paramTypes, Bool.TYPE);$/;"	d
opGteq	$VIRGIL/aeneas/src/types/Float.v3	/^	def opGteq = V3Op.newVstSugar(VstOperator.Commute(opLteq), arr_t, [ft, ft], Bool.TYPE);$/;"	d
opInit	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opInit(meth: IrMethod) -> SsaInstr {$/;"	m
opIntAdd	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntAdd(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntAnd	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntAnd(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntCastI	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntCastI(ift: IntType, itt: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
opIntCompare	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntCompare(eq: bool, infix: IntType -> Operator, xt: Type, yt: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntGteq	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntGteq(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntLt	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntLt(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntLtZero	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntLtZero(t: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
opIntMul	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntMul(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntQueryI	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntQueryI(ift: IntType, itt: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
opIntRangeCheck	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntRangeCheck(scale: int, low: int, high: int, val: SsaInstr) -> SsaInstr {$/;"	m
opIntSignedPromote	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntSignedPromote(st: IntType, ut: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
opIntSub	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntSub(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntULt	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntULt(leftType: IntType, rightType: IntType, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opIntView	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntView(ft: Type, itt: IntType, e: SsaInstr) -> SsaInstr {$/;"	m
opIntViewF32	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opIntViewF32 = newOp0(Opcode.IntViewF(false), arr_f, arr_f, type_u);$/;"	d
opIntViewF64	$VIRGIL/aeneas/src/core/Operator.v3	/^	def opIntViewF64 = newOp0(Opcode.IntViewF(true), arr_d, arr_d, Int.getType(false, 64));$/;"	d
opIntViewI	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntViewI(op: Operator, x: SsaInstr) -> SsaInstr {$/;"	m
opIntViewI0	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opIntViewI0(from: Type, to: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opIntViewINorm	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def opIntViewINorm(ft: IntType, tt: IntType, x: SsaInstr) -> SsaInstr {$/;"	m
opIntersect	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opIntersect = V3Op.newVstSugar(VstOperator.EnumSetIntersect, TypeUtil.NO_TYPES, binopTypes, t);$/;"	d
opLoad	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opLoad = V3Op.newPtrLoad(ptrType, typeParam);$/;"	d
opLt	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opLt = V3Op.newPtrLt(ptrType);$/;"	d
opLt	$VIRGIL/aeneas/src/types/Float.v3	/^	def opLt = newOp(Opcode.FloatLt(ft.is64), typeArgs, cmpSig);$/;"	d
opLt	$VIRGIL/aeneas/src/types/Int.v3	/^	def opLt() -> Operator { return opcache().compare(V3Infix.Lt, Opcode.IntLt); }$/;"	m
opLtEq	$VIRGIL/aeneas/src/types/Int.v3	/^	def opLtEq() -> Operator { return opcache().compare(V3Infix.LtEq, Opcode.IntLteq); }$/;"	m
opLteq	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opLteq = V3Op.newPtrLteq(ptrType);$/;"	d
opLteq	$VIRGIL/aeneas/src/types/Float.v3	/^	def opLteq = newOp(Opcode.FloatLteq(ft.is64), typeArgs, cmpSig);$/;"	d
opMethod	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def opMethod(op: SsaApplyOp, m: IrMethod, context: IrSpec) -> RaMethod {$/;"	m
opMod	$VIRGIL/aeneas/src/types/Int.v3	/^	def opMod() -> Operator { return opcache().arith(V3Infix.Mod, Opcode.IntMod); }$/;"	m
opMul	$VIRGIL/aeneas/src/types/Float.v3	/^	def opMul = newOp(Opcode.FloatMul(ft.is64), typeArgs, binopSig);$/;"	d
opMul	$VIRGIL/aeneas/src/types/Int.v3	/^	def opMul() -> Operator { return opcache().arith(V3Infix.Mul, Opcode.IntMul); }$/;"	m
opNormRangeGetElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNormRangeGetElem(rangeType: Type, indexType: IntType, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {$/;"	m
opNormRangeGetElemElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNormRangeGetElemElem(rangeType: Type, indexType: IntType, elem: int, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {$/;"	m
opNormRangeSetElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNormRangeSetElem(rangeType: Type, indexType: IntType, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr, w: SsaInstr) -> SsaInstr {$/;"	m
opNormRangeSetElemElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNormRangeSetElemElem(rangeType: Type, indexType: IntType, elem: int, facts: Fact.set, x: SsaInstr, y: SsaInstr, z: SsaInstr, w: SsaInstr) -> SsaInstr {$/;"	m
opNotEqual	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opNotEqual	$VIRGIL/aeneas/src/types/Float.v3	/^	def opNotEqual = newOp(Opcode.FloatNe(ft.is64), typeArgs, cmpSig);$/;"	d
opNullCheck	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opNullCheck(rtype: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opOr	$VIRGIL/aeneas/src/types/Int.v3	/^	def opOr() -> Operator { return opcache().arith(V3Infix.Or, Opcode.IntOr); }$/;"	m
opRangeStartFromPointer	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opRangeStartFromPointer(rangeType: Type, ptrType: PointerType, facts: Fact.set, x: SsaInstr) -> SsaInstr {$/;"	m
opRangeStartPlusIndex	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opRangeStartPlusIndex(rangeType: Type, indexType: IntType, facts: Fact.set, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opSar	$VIRGIL/aeneas/src/types/Int.v3	/^	def opSar() -> Operator { return opcache().shift(V3Infix.Sar, if(signed, Opcode.IntSar, Opcode.IntShr)); }$/;"	m
opShl	$VIRGIL/aeneas/src/types/Int.v3	/^	def opShl() -> Operator { return opcache().shift(V3Infix.Shl, Opcode.IntShl); }$/;"	m
opShr	$VIRGIL/aeneas/src/types/Int.v3	/^	def opShr() -> Operator { return opcache().shift(V3Infix.Shr, Opcode.IntShr); }$/;"	m
opSign	$VIRGIL/aeneas/src/types/Float.v3	/^	def opSign = V3Op.newVstSugar(VstOperator.FloatSign, arr_t, arr_t, Int.getType(false, 1));$/;"	d
opSqrt	$VIRGIL/aeneas/src/types/Float.v3	/^	def opSqrt = newOp(Opcode.FloatSqrt(ft.is64), typeArgs, unopSig);$/;"	d
opStore	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opStore = V3Op.newPtrStore(ptrType, typeParam);$/;"	d
opStrictSubset	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opStrictSubset = V3Op.newVstSugar(VstOperator.EnumSetStrictSubset, TypeUtil.NO_TYPES, binopTypes, Bool.TYPE);$/;"	d
opStrictSuperset	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opStrictSuperset = V3Op.newVstSugar(VstOperator.EnumSetStrictSuperset, TypeUtil.NO_TYPES, binopTypes, Bool.TYPE);$/;"	d
opSub	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opSub = V3Op.newPtrSub(ptrType, it);$/;"	d
opSub	$VIRGIL/aeneas/src/types/Float.v3	/^	def opSub = newOp(Opcode.FloatSub(ft.is64), typeArgs, binopSig);$/;"	d
opSub	$VIRGIL/aeneas/src/types/Int.v3	/^	def opSub() -> Operator { return opcache().arith(V3Infix.Sub, Opcode.IntSub); }$/;"	m
opSub	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opSub = V3Op.newVstSugar(VstOperator.EnumSetSubtract, TypeUtil.NO_TYPES, binopTypes, t);$/;"	d
opSubset	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opSubset = V3Op.newVstSugar(VstOperator.EnumSetSubset, TypeUtil.NO_TYPES, binopTypes, Bool.TYPE);$/;"	d
opSuperset	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opSuperset = V3Op.newVstSugar(VstOperator.EnumSetSuperset, TypeUtil.NO_TYPES, binopTypes, Bool.TYPE);$/;"	d
opTailCall	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var opTailCall: bool;$/;"	d
opTupleCreate	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opTupleCreate(tupleType: Type, x: Array<SsaInstr>) -> SsaInstr {$/;"	m
opTupleGetElem	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opTupleGetElem(tupleType: Type, i: int, x: SsaInstr) -> SsaInstr {$/;"	m
opTypeCast	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opTypeCast(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opTypeQuery	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opTypeQuery(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opTypeSubsume	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opTypeSubsume(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {$/;"	m
opU32Lt	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opU32Lt(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opU32LtEq	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opU32LtEq(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opU64Lt	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opU64Lt(x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opUnion	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opUnion = V3Op.newVstSugar(VstOperator.EnumSetUnion, TypeUtil.NO_TYPES, binopTypes, t);$/;"	d
opWideBoundsCheck	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def opWideBoundsCheck(arrayType: Type, it: IntType, x: SsaInstr, y: SsaInstr) -> SsaInstr {$/;"	m
opXor	$VIRGIL/aeneas/src/types/Int.v3	/^	def opXor() -> Operator { return opcache().arith(V3Infix.Xor, Opcode.IntXor); }$/;"	m
opcache	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def opcache() -> Pointer_OpCache {$/;"	m
opcache	$VIRGIL/aeneas/src/types/Float.v3	/^	def opcache() -> FloatOpCache {$/;"	m
opcache	$VIRGIL/aeneas/src/types/Int.v3	/^	def opcache() -> IntOpCache {$/;"	m
opcache	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def opcache() -> V3EnumSet_OpCache {$/;"	m
opcode	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def opcode() -> i28 { return i28.view(op); }$/;"	m
open	$VIRGIL/aeneas/src/types/Type.v3	/^	def open() -> bool { return (hash & TypeConst.OPEN_MASK) != 0; }$/;"	m
open	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def open() -> NetResult<void> {$/;"	m
openFiles	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def openFiles = Array<int>.new(128);$/;"	d
openness	$VIRGIL/aeneas/src/core/Operator.v3	/^	private var openness: Open;			\/\/ lazily computed open \/ closed$/;"	d
operands	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def operands = Vector<Operand>.new();$/;"	d
opt	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	var opt: SsaOptimizer;$/;"	d
opt1	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def opt1(ch: byte) -> int {$/;"	m
opt1	$VIRGIL/lib/util/TextReader.v3	/^	def opt1(ch: byte) -> int {$/;"	m
optBlock	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optBlock(block: SsaBlock) {$/;"	m
optBoundedIv	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optBoundedIv(iv: SsaLinearIv) {$/;"	m
optBoundedIvUse	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optBoundedIvUse(iv: SsaLinearIv, use: SsaInstr) {$/;"	m
optBoundsCheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optBoundsCheck(iv: SsaLinearIv, use: SsaInstr, array: SsaInstr) {$/;"	m
optEdge	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optEdge(edge: SsaCfEdge) -> bool {$/;"	m
optError	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def optError = ErrorGen.new(1);$/;"	d
optFoldCast	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optFoldCast(i: SsaInstr, queryTypes: Array<Type>) -> SsaInstr {$/;"	m
optGraph	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optGraph() {$/;"	m
optIf	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optIf(block: SsaBlock, sw: SsaIf) {$/;"	m
optInstr	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optInstr(apply: SsaApplyOp) -> SsaInstr {$/;"	m
optKeyword	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def optKeyword(p: ParserState, kw: string) -> FilePoint {$/;"	f
optLoop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optLoop(header: SsaBlock, loopBody: SsaBlock, loopEnd: SsaBlock) {$/;"	m
optN	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def optN(s: string) -> int {$/;"	m
optN	$VIRGIL/lib/util/TextReader.v3	/^	def optN(s: string) -> int {$/;"	m
optNullCheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optNullCheck(i: SsaInstr) -> SsaInstr {$/;"	m
optPhi	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optPhi(phi: SsaPhi) -> bool {$/;"	m
optag	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def optag() -> int { return op.opcode.tag; }$/;"	m
optimize	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def optimize() {$/;"	m
optimize	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def optimize() {$/;"	m
optimizeElse	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def optimizeElse(i: int) -> int {$/;"	m
optimizeEnd	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def optimizeEnd(i: int) -> int {$/;"	m
optimizePerfectHashTable	$VIRGIL/aeneas/src/vst/Parser.v3	/^	private def optimizePerfectHashTable(keywords: Array<(string, byte)>) -> (int, int) {$/;"	f
optimize_bounds	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var optimize_bounds = true;$/;"	d
optimize_inits	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var optimize_inits = false;		\/\/ activates init elimination$/;"	d
optimize_loads	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var optimize_loads = true;		\/\/ activates load elimination$/;"	d
optimize_nullchecks	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var optimize_nullchecks = true;		\/\/ activates null check elimination$/;"	d
options	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def options = BasicOptions.new(null);$/;"	d
or_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def or_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 1); }$/;"	m
or_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def or_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 1); }$/;"	m
or_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def or_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 1); }$/;"	m
or_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def or_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 1); }$/;"	m
or_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def or_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 1); }$/;"	m
order	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var order: Vector<SsaBlockInfo>;$/;"	d
order	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var order: SsaBlockOrder;$/;"	d
order	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def order = Vector<SsaBlockInfo>.new();$/;"	d
orderFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def orderFile(name: string, info: DwarfFile) {$/;"	m
orderMove	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	private def orderMove(alloc: int -> int, move: (int, int) -> void, node: MoveNode) {$/;"	m
ori	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def ori(rd: MipsReg, rs: MipsReg, imm: u16)     { emit_r2i(0x00000034, rd, rs, imm); }$/;"	m
ori	$VIRGIL/lib/util/BitMatrix.v3	/^	def ori(a: int) {$/;"	m
orig	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def orig: IrClass;			\/\/ original, polymorphic IrClass$/;"	d
origIndices	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var origIndices: (int, int) = (-1, -1);$/;"	d
originVarsCnt	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var originVarsCnt: int;$/;"	d
orpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def orpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
orps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def orps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
orr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def orr(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(24, rd, rn, op); }$/;"	m
orrs	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def orrs(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(25, rd, rn, op); }$/;"	m
other	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def other: string -> TypeCon;$/;"	d
other	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def other = Vector<WasmType>.new();$/;"	d
out	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var out: ArchInstrBuffer;$/;"	d
out	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	var out: ArchInstrBuffer;$/;"	d
out	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def out() {$/;"	m
out	$VIRGIL/lib/term/Vt100.v3	/^	def out(n: int) {$/;"	m
out	$VIRGIL/lib/util/StringBuilder.v3	/^	def out(f: (Array<byte>, int, int) -> void) -> this {$/;"	m
out	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def out = darwinFileStream(DarwinConst.STDOUT);$/;"	d
out16	$VIRGIL/aeneas/src/exe/MachO.v3	/^	def out16(w: DataWriter, str: string) {$/;"	m
outBuf	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def outBuf = TerminalBuffer.new();$/;"	d
outK	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def outK(a: Array<byte>, start: int, len: int) {$/;"	m
outK	$VIRGIL/lib/util/IO.v3	/^	def outK(data: Array<byte>, start: int, len: int);$/;"	m
outN	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def outN(n: int) {$/;"	m
outln	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def outln() -> this {$/;"	m
outln	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def outln() -> this {$/;"	m
output	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def output(order: Vector<SsaBlockInfo>, loopDepth: int) {$/;"	m
outt	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def outt() -> this {$/;"	m
overflow	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def overflow: int;		\/\/ number of overflow stack arguments$/;"	d
overflowDecimal	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def overflowDecimal() -> Val {$/;"	m
overwrite	$VIRGIL/lib/util/Vector.v3	/^	def overwrite<T>(vec: Vector<T>, array: Array<T>) -> Vector<T> {$/;"	f
overwrite_uleb32	$VIRGIL/lib/util/DataWriter.v3	/^	def overwrite_uleb32(val: int) -> this {$/;"	m
ovfAlloc	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var ovfAlloc: OverflowFieldAllocator;$/;"	d
ovfParamFields	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var ovfParamFields: Array<IrSpec>;$/;"	d
ovfParamTypes	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def ovfParamTypes: Array<Type>;$/;"	d
ovfReturnFields	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var ovfReturnFields: Array<IrSpec>;$/;"	d
ovfReturnTypes	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def ovfReturnTypes: Array<Type>;$/;"	d
ovwReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ovwReg(d: SsaInstr, u: SsaInstr) {$/;"	m
ovwRegFixed	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ovwRegFixed(d: SsaInstr, u: SsaInstr, constraint: int) {$/;"	m
ovwv	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ovwv(d: VReg, u: VReg, constraint: int) {$/;"	m
p_align	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_align: long;$/;"	d
p_filesz	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_filesz: long;$/;"	d
p_flags	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_flags: int;$/;"	d
p_memsz	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_memsz: long;$/;"	d
p_offset	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_offset: long;$/;"	d
p_paddr	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_paddr: long;$/;"	d
p_type	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_type: int;$/;"	d
p_vaddr	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var p_vaddr: long;$/;"	d
pabsb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pabsb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pabsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pabsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pabsw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pabsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pabsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
packed	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var packed: bool;$/;"	d
packedByteSize	$VIRGIL/aeneas/src/types/Int.v3	/^	def packedByteSize() -> int {$/;"	m
packedByteSize	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def packedByteSize() -> int {$/;"	m
packings	$VIRGIL/aeneas/src/core/Program.v3	/^	var packings: HashMap<string, VstPacking>;$/;"	d
packings	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var packings: HashMap<string, VstPacking>;$/;"	d
packings	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def packings = Vector<VstPacking>.new();$/;"	d
packssdw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def packssdw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
packsswb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def packsswb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
packusdw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def packusdw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
packuswb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def packuswb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pad	$VIRGIL/lib/util/List.v3	/^	def pad<T>(list: List<T>, item: T, length: int) -> List<T> {$/;"	f
pad	$VIRGIL/lib/util/StringBuilder.v3	/^	def pad(ch: byte, nlen: int) -> this {$/;"	m
padNum	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def padNum = 6;$/;"	d
paddb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddsb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddsb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddusb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddusb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddusw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddusw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
paddw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def paddw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
padr	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	private def padr(nwords: int) -> bool {$/;"	m
pageAlign	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def pageAlign(v: int) -> int {$/;"	m
pageAlign	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def pageAlign: Alignment;$/;"	d
pageAlign	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def pageAlign: Alignment;$/;"	d
pand_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pand_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
param	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def param(name: string, param: string, list: List<Expr>, exactType: Type, implicitType: Type, indent: int) {$/;"	m
paramArray	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def paramArray = TypeUtil.toTypeArray(typeParams);$/;"	d
paramLocs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def paramLocs: Array<int>;	\/\/ locations of parameters$/;"	d
paramRegs	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def paramRegs: Array<int> = [S.R0, S.R1, S.R2, S.R3];$/;"	d
paramRegs	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def paramRegs = [R.EDI, R.EAX, R.EDX, R.ECX, R.ESI];$/;"	d
paramType	$VIRGIL/aeneas/src/types/Function.v3	/^	def paramType() -> Type { return nested.head; }$/;"	m
paramTypes	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def paramTypes: Array<Type>;	\/\/ parameter types$/;"	d
paramTypes	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def paramTypes: Array<Type>;$/;"	d
paramTypes	$VIRGIL/aeneas/src/types/Function.v3	/^	def paramTypes: Array<Type>;$/;"	d
parameterized	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def parameterized() -> bool {$/;"	m
params	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var params: Array<SsaParam>;$/;"	d
params	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var params: VstList<ParamDecl>;$/;"	d
params	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var params = 0;$/;"	d
params	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def params: Array<WasmType>;$/;"	d
params	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def params: T;$/;"	d
paramsSize	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def paramsSize = paramsSizeOf(paramTypes);$/;"	d
paramsSizeOf	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^def paramsSizeOf(paramTypes: Array<JvmType>) -> int {$/;"	f
paranoid	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def paranoid = true;$/;"	d
parent	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def parent: IrClass;			\/\/ parent class if any$/;"	d
parent	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def parent: RaClass;			\/\/ super class, if any$/;"	d
parent	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def parent: VstSsaEnv;$/;"	d
parent	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def parent: TypeEnv;$/;"	d
parent	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def parent: WasmStruct;$/;"	d
parmoveDests	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def parmoveDests = Vector<(VReg, List<Operand.Def>)>.new();$/;"	d
parmoveDests	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def parmoveDests = Vector<(VReg, List<Operand.Def>)>.new();$/;"	d
parmoveDests	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	private def parmoveDests = Vector<(VReg, List<Operand.Def>)>.new();$/;"	d
parmoveDests	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def parmoveDests = Vector<(VReg, List<Operand.Def>)>.new();$/;"	d
parmoveState	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var parmoveState: int;$/;"	d
parse	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def parse(s: string) -> ScalarPattern {$/;"	f
parse	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def parse() -> bool {$/;"	m
parse	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parse() -> bool {$/;"	m
parse	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	def parse(pattern: string) -> VstMatcher {$/;"	f
parse	$VIRGIL/lib/util/Option.v3	/^	def parse(val: string);$/;"	m
parse0bBin	$VIRGIL/lib/util/Ints.v3	/^	def parse0bBin(a: Array<byte>, pos: int) -> (int, u32) {$/;"	f
parse0bBin	$VIRGIL/lib/util/Longs.v3	/^	def parse0bBin(a: Array<byte>, pos: int) -> (int, u64) {$/;"	f
parse0xHex	$VIRGIL/lib/util/Ints.v3	/^	def parse0xHex(a: Array<byte>, pos: int) -> (int, u32) {$/;"	f
parse0xHex	$VIRGIL/lib/util/Longs.v3	/^	def parse0xHex(a: Array<byte>, pos: int) -> (int, u64) {$/;"	f
parseAddr	$VIRGIL/lib/util/Option.v3	/^	def parseAddr(str: string) -> u64 {$/;"	m
parseArrayLiteral	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseArrayLiteral(p: ParserState) -> ArrayExpr {$/;"	f
parseBin	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseBin() -> bool {$/;"	m
parseBin	$VIRGIL/lib/util/Ints.v3	/^	def parseBin(a: Array<byte>, pos: int) -> (int, u32) {$/;"	f
parseBin	$VIRGIL/lib/util/Longs.v3	/^	def parseBin(a: Array<byte>, pos: int) -> (int, u64) {$/;"	f
parseBin0	$VIRGIL/lib/util/Ints.v3	/^	private def parseBin0(a: Array<byte>, pos: int, prefix: int) -> (int, u32) {$/;"	f
parseBin0	$VIRGIL/lib/util/Longs.v3	/^	private def parseBin0(a: Array<byte>, pos: int, prefix: int) -> (int, u64) {$/;"	f
parseBlockStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseBlockStmt(p: ParserState) -> BlockStmt {$/;"	f
parseBool	$VIRGIL/lib/util/Option.v3	/^	def parseBool(str: string) -> bool {$/;"	m
parseBreakStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseBreakStmt(p: ParserState) -> Stmt {$/;"	f
parseBreakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parseBreakpoint(args: string) -> (\/*fileName*\/string, \/*line*\/int) {$/;"	m
parseByteLiteral	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseByteLiteral(p: ParserState) -> Literal {$/;"	f
parseCM	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	def parseCM(pattern: string) -> VstPattern {$/;"	f
parseClass	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseClass(p: ParserState, file: VstFile, isPrivate: bool) -> bool {$/;"	f
parseClassParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseClassParam = parseParamCommon(_, true, true, true);$/;"	d
parseCommand	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parseCommand(command: string) -> (DbgCommand, \/*args*\/string) {$/;"	m
parseComponent	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseComponent(p: ParserState, file: VstFile, isPrivate: bool) -> bool {$/;"	f
parseContinueStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseContinueStmt(p: ParserState) -> Stmt {$/;"	f
parseControlExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseControlExpr(p: ParserState) -> Expr {$/;"	f
parseDec	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseDec() -> bool {$/;"	m
parseDecM	$VIRGIL/lib/util/Ints.v3	/^	private def parseDecM(a: Array<byte>, pos: int, maxdiv10: u32, maxmod10: u32) -> (int, u32) {$/;"	f
parseDecimal	$VIRGIL/lib/util/Ints.v3	/^	def parseDecimal(a: Array<byte>, pos: int) -> (\/*status:*\/int, \/*value:*\/int) {$/;"	f
parseDecimal	$VIRGIL/lib/util/Longs.v3	/^	def parseDecimal(a: Array<byte>, pos: int) -> i64;$/;"	f
parseDef	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseDef(p: ParserState, prev: List<VstMember>, importName: Token) -> List<VstMember> {$/;"	m
parseDefStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseDefStmt(p: ParserState, start: FilePoint) -> Stmt {$/;"	f
parseDisplay	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parseDisplay(args: string) -> DbgDisplay {$/;"	m
parseDottedVarExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseDottedVarExpr(p: ParserState, id: VstIdent<TypeRef>) -> VarExpr {$/;"	f
parseEmpty	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def parseEmpty(str: string) -> bool {$/;"	m
parseEmptyStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseEmptyStmt(p: ParserState) -> Stmt {$/;"	f
parseEnum	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseEnum(p: ParserState, file: VstFile, isPrivate: bool) -> bool {$/;"	f
parseEnumCase	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseEnumCase(p: ParserState, tag: int) -> VstEnumCase {$/;"	f
parseEnumParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseEnumParam = parseParamCommon(_, false, true, true);$/;"	d
parseEscape	$VIRGIL/lib/util/Chars.v3	/^	def parseEscape(a: Array<byte>, pos: int) -> (int, byte) {$/;"	f
parseExponent	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseExponent(wstart: int, wend: int, fstart: int, fend: int) -> bool {$/;"	m
parseExport	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseExport(p: ParserState, file: VstFile) -> bool {$/;"	f
parseExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseExpr(p: ParserState) -> Expr {$/;"	f
parseExprStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseExprStmt(p: ParserState) -> Stmt {$/;"	f
parseFieldSuffix	$VIRGIL/aeneas/src/vst/Parser.v3	/^	private def parseFieldSuffix(p: ParserState, id: VstIdent<void>, prev: List<VstMember>) -> List<VstMember> {$/;"	m
parseFile	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseFile(fileName: string, input: Array<byte>, ERROR: ErrorGen, typeCache: TypeCache) -> VstFile {$/;"	f
parseFlag	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def parseFlag(p: ParserState) {$/;"	m
parseFlags	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def parseFlags(p: ParserState) {$/;"	m
parseForStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseForStmt(p: ParserState) -> Stmt {$/;"	f
parseFractional	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseFractional(wstart: int, wend: int) -> bool {$/;"	m
parseFun	$VIRGIL/lib/util/Option.v3	/^	def parseFun: string -> T;$/;"	d
parseGlob	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^	def parseGlob(pattern: string) -> string -> bool {$/;"	f
parseHex	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseHex() -> bool {$/;"	m
parseHex	$VIRGIL/lib/util/Ints.v3	/^	def parseHex(a: Array<byte>, pos: int) -> (int, u32) {$/;"	f
parseHex	$VIRGIL/lib/util/Longs.v3	/^	def parseHex(a: Array<byte>, pos: int) -> (int, u64) {$/;"	f
parseHex0	$VIRGIL/lib/util/Ints.v3	/^	private def parseHex0(a: Array<byte>, pos: int, prefix: int) -> (int, u32) {$/;"	f
parseHex0	$VIRGIL/lib/util/Longs.v3	/^	private def parseHex0(a: Array<byte>, pos: int, prefix: int) -> (int, u64) {$/;"	f
parseIdMatchPattern	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIdMatchPattern(p: ParserState) -> MatchPattern {$/;"	f
parseIdent	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIdent<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {$/;"	f
parseIdentCommon	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIdentCommon<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {$/;"	f
parseIdentUnchecked	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIdentUnchecked<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {$/;"	f
parseIdentVoid	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIdentVoid(p: ParserState) -> VstIdent<void> {$/;"	f
parseIfStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIfStmt(p: ParserState) -> Stmt {$/;"	f
parseIndexSuffix	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIndexSuffix(p: ParserState, expr: Expr) -> Expr {$/;"	f
parseIndexed	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIndexed(p: ParserState, prev: List<VstMember>) -> List<VstMember> {$/;"	m
parseInfix	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseInfix(p: ParserState) -> InfixOp {$/;"	f
parseInfo	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parseInfo(args: string) -> (DbgInfo, Array<int>) {$/;"	m
parseInt	$VIRGIL/lib/util/Option.v3	/^	def parseInt(str: string) -> int {$/;"	m
parseIntLiteral	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseIntLiteral(p: ParserState) -> IntLiteral {$/;"	f
parseLayout	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseLayout(p: ParserState, file: VstFile) -> bool {$/;"	f
parseLayoutField	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseLayoutField(p: ParserState, prev: List<VstMember>) -> List<VstMember> {$/;"	f
parseList	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseList<T>(min: int, p: ParserState, begDelim: byte, sepByte: byte, endDelim: byte, f: ParserState -> T) -> VstList<T> {$/;"	f
parseLiteral	$VIRGIL/lib/util/Chars.v3	/^	def parseLiteral(a: Array<byte>, pos: int) -> (int, byte) {$/;"	f
parseLiteral	$VIRGIL/lib/util/Strings.v3	/^	def parseLiteral(a: Array<byte>, pos: int) -> (int, string) {$/;"	f
parseLocal	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseLocal(p: ParserState) -> VarDecl {$/;"	m
parseMatchCase	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMatchCase(p: ParserState) -> MatchCase {$/;"	f
parseMatchParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMatchParam(p: ParserState) -> VarDecl {$/;"	f
parseMatchPattern	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMatchPattern(p: ParserState) -> MatchPattern {$/;"	f
parseMatchStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMatchStmt(p: ParserState) -> Stmt {$/;"	f
parseMatcher	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def parseMatcher(str: string) -> VstMatcher {$/;"	f
parseMember	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMember(p: ParserState, prev: List<VstMember>, allowImportName: bool) -> List<VstMember> {$/;"	f
parseMembers	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMembers(p: ParserState, allowImportName: bool) -> List<VstMember> {$/;"	f
parseMemoryTypeRef	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMemoryTypeRef(p: ParserState) -> MemoryTypeRef {$/;"	f
parseMethodParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMethodParam = parseParamCommon(_, true, false, false);$/;"	d
parseMethodParams	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseMethodParams = Parser.parseList(0, _, '(', Parser.COMMA, ')', Parser.parseMethodParam);$/;"	d
parseNestedExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseNestedExpr(p: ParserState, f: (FilePoint, Expr) -> Expr) -> Expr {$/;"	f
parseNew	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseNew(p: ParserState, isPrivate: bool, start: FilePoint) -> VstNew {$/;"	f
parseNumber	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseNumber(p: ParserState) -> Literal {$/;"	f
parseOct	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def parseOct() -> bool {$/;"	m
parseOptString	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseOptString(p: ParserState) -> Token {$/;"	f
parseOption	$VIRGIL/lib/util/Option.v3	/^	def parseOption(arg: string) {$/;"	m
parseOptionalParams	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseOptionalParams(p: ParserState, func: ParserState -> ParamDecl) -> VstList<ParamDecl> {$/;"	f
parsePacking	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parsePacking(p: ParserState, file: VstFile, isPrivate: bool) -> bool {$/;"	f
parsePackingExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parsePackingExpr(p: ParserState, inDecl: bool, allowSolve: bool) -> VstPackingExpr {$/;"	f
parsePackingExprs	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parsePackingExprs(p: ParserState) -> VstList<VstPackingExpr> {$/;"	f
parsePackingParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parsePackingParam(p: ParserState) -> PackingParamDecl {$/;"	f
parseParamCommon	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseParamCommon(p: ParserState, varAllowed: bool, defReadOnly: bool, typeRequired: bool) -> ParamDecl {$/;"	f
parseParamExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseParamExpr(p: ParserState) -> Expr {$/;"	f
parsePosDecimal	$VIRGIL/lib/util/Ints.v3	/^	def parsePosDecimal(a: Array<byte>, pos: int) -> (\/*status:*\/int, \/*value:*\/u32) {$/;"	f
parsePosDecimal	$VIRGIL/lib/util/Longs.v3	/^	def parsePosDecimal(a: Array<byte>, pos: int) -> u64;$/;"	f
parseRedefField	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseRedefField(p: ParserState) -> VstRedefField {$/;"	f
parseRedefFields	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseRedefFields(fileName: string, input: Array<byte>, skip: int, ERROR: ErrorGen) -> (VstFile, VstList<VstRedefField>) {$/;"	f
parseRepHints	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseRepHints(p: ParserState) -> List<VstRepHint> {$/;"	f
parseReturnStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseReturnStmt(p: ParserState) -> Stmt {$/;"	f
parseReturnTypeAndBody	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseReturnTypeAndBody(p: ParserState, isDef: bool) -> (ReturnType, Stmt) {$/;"	f
parseSize	$VIRGIL/lib/util/Option.v3	/^	def parseSize(str: string) -> u32 {$/;"	m
parseSource	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parseSource(args: string) -> int {$/;"	m
parseStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseStmt(p: ParserState) -> Stmt {$/;"	f
parseString	$VIRGIL/lib/util/Option.v3	/^	def parseString(str: string) -> string {$/;"	m
parseStringArray	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def parseStringArray(str: string) -> Array<string> {$/;"	f
parseStringLiteral	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseStringLiteral(p: ParserState) -> StringExpr {$/;"	f
parseSubExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseSubExpr(p: ParserState) -> Expr {$/;"	f
parseTerm	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTerm(p: ParserState) -> Expr {$/;"	f
parseTestInputs	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def parseTestInputs(prog: Program, error: ErrorGen, expected: int) -> Array<Array<Val>> {$/;"	m
parseToplevelDecl	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseToplevelDecl(p: ParserState, file: VstFile) -> bool {$/;"	f
parseTupleExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTupleExpr(p: ParserState) -> TupleExpr {$/;"	f
parseTypeParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTypeParam(p: ParserState) -> TypeParamType {$/;"	f
parseTypeRef	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTypeRef(p: ParserState) -> TypeRef {$/;"	f
parseTypedMethodParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTypedMethodParam = parseParamCommon(_, true, false, true);$/;"	d
parseTypedMethodParams	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseTypedMethodParams = Parser.parseList(0, _, '(', Parser.COMMA, ')', Parser.parseTypedMethodParam);$/;"	d
parseVar	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVar(p: ParserState, prev: List<VstMember>) -> List<VstMember> {$/;"	m
parseVarExpr	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVarExpr(p: ParserState) -> Expr {$/;"	f
parseVarStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVarStmt(p: ParserState, start: FilePoint) -> Stmt {$/;"	f
parseVariant	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVariant(p: ParserState, file: VstFile, isPrivate: bool) -> bool {$/;"	f
parseVariantCase	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVariantCase(p: ParserState, desugar: VariantDesugaring, prev: List<VstMember>) -> List<VstMember> {$/;"	f
parseVariantCaseParam	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVariantCaseParam = parseEnumParam;$/;"	d
parseVariantCases	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVariantCases(p: ParserState, desugar: VariantDesugaring) -> List<VstMember> {$/;"	f
parseVars	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseVars(p: ParserState, id: VstIdent<void>) -> List<VarDecl> {$/;"	m
parseWhileStmt	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def parseWhileStmt(p: ParserState) -> Stmt {$/;"	f
parser	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def parser = DebuggerParser.new();$/;"	d
pass	$VIRGIL/aeneas/src/util/Progress.v3	/^	def pass() {$/;"	m
passed	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def passed(v: bool) -> int {$/;"	f
passed	$VIRGIL/aeneas/src/util/Progress.v3	/^	var passed: int;$/;"	d
patch	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def patch(f: (MachDataWriter, Addr, int) -> void) {$/;"	m
patch	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def patch(addr: Addr, posAddr: int, absAddr: int) {$/;"	m
patchAddress	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def patchAddress(mach: MachProgram, w: MachDataWriter, a: Addr, posAddr: int) {$/;"	m
patchBranch	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def patchBranch(index: int) {$/;"	m
patchBranch	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def patchBranch(target: SsaBlock, offset: int) {$/;"	m
patchCodeAddr	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int, pos: int) {$/;"	m
patchCodeAddr	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int) {$/;"	m
patchCodeAddr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int);$/;"	m
patchCodeAddr	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int) {$/;"	m
patchCodeAddr	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int) {$/;"	m
patchExEntry	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def patchExEntry(exstrIndex: int, source: Source, exIndex: int) {$/;"	m
patchLabels	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def patchLabels() {$/;"	m
patchSize	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^def patchSize(w: MachDataWriter, offset: int, size: int) {$/;"	f
patchSwitch	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def patchSwitch(s: Array<SsaCfEdge>, m: IcInstr.Switch) {$/;"	m
patchTypeRef	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def patchTypeRef() {$/;"	m
patch_lookupswitch	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def patch_lookupswitch(s: int, default: int, pairs: Array<(int, int)>) {$/;"	m
patch_tableswitch	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def patch_tableswitch(s: int, default: int, off: Array<int>) {$/;"	m
patcher	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var patcher: X86_64AddrPatcher;$/;"	d
patcherImpl	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def patcherImpl = X86_64AddrPatcherImpl.new(mw);$/;"	d
pathName	$VIRGIL/rt/x86-64-darwin/System.v3	/^	private def pathName(fileName: string) -> Pointer {$/;"	f
pathbuf	$VIRGIL/rt/x86-64-darwin/System.v3	/^	var pathbuf = Array<byte>.new(100);$/;"	d
pausedInstr	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var pausedInstr: IcInstr;	\/\/ instruction that was last paused$/;"	d
pavgb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pavgb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pavgb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pavgb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pavgw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pavgw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pavgw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pavgw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pblendw_s_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pblendw_s_s_i(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pclmulqdq_s_s_imm	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pclmulqdq_s_s_imm(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pcmpeqb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpeqb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpeqd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pcmpeqd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x76, a, b); }$/;"	m
pcmpeqd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpeqd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpeqq	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pcmpeqq(a: SSEReg, b: SSERm) { emitbbbb_s_sm(0x66, 0x0F, 0x38, 0x29, a, b); }$/;"	m
pcmpeqq_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqq_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpeqq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpeqw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpeqw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpeqw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpgtb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpgtb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpgtd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpgtd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpgtq_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtq_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpgtq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pcmpgtw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pcmpgtw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pcmpgtw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
peek	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def peek(i: int) -> byte {$/;"	m
peek	$VIRGIL/lib/util/Stack.v3	/^	def peek() -> T;$/;"	m
peek1	$VIRGIL/lib/util/DataReader.v3	/^	def peek1() -> int {$/;"	m
peekN	$VIRGIL/lib/util/DataReader.v3	/^	def peekN(length: int) -> bool {$/;"	m
peekRel	$VIRGIL/lib/util/TextReader.v3	/^	def peekRel(offset: int) -> byte {$/;"	m
peekn	$VIRGIL/lib/util/Stack.v3	/^	def peekn(n: int) -> Range<T> {$/;"	m
percent	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def percent(icm: IcMethod) -> (IcMethod, int) {$/;"	m
performance_counter	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def performance_counter(t: i32) -> i64;							\/\/ * s$/;"	f
pextrb_r_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pextrb_r_s_i(a: X86_64Gpr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pextrd_r_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pextrd_r_s_i(a: X86_64Gpr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pextrq_m_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pextrq_m_s_i(a: X86_64Addr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pextrq_r_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pextrq_r_s_i(a: X86_64Gpr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pextrw_r_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pextrw_r_s_i(a: X86_64Gpr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pheaders	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def pheaders = Vector<ElfProgramHeader>.new();$/;"	d
phi	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def phi: SsaPhi;	\/\/ x$/;"	d
phiList	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var phiList: List<SsaPhi>;$/;"	d
phiMoves	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var phiMoves = Vector<(SsaPhi, Val)>.new();$/;"	d
phiQueue	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	var phiQueue: Vector<SsaPhi>;$/;"	d
phis	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var phis: List<SsaPhi>;$/;"	d
physRegs	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	def physRegs = cursor;$/;"	d
physRegs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def physRegs: int;			\/\/ number of physical registers$/;"	d
pinsrb_s_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pinsrb_s_r_i(a: X86_64Xmmr, b: X86_64Gpr, imm: u8) -> this {$/;"	m
pinsrd_s_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pinsrd_s_r_i(a: X86_64Xmmr, b: X86_64Gpr, imm: u8) -> this {$/;"	m
pinsrq_s_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pinsrq_s_r_i(a: X86_64Xmmr, b: X86_64Gpr, imm: u8) -> this {$/;"	m
pinsrw_s_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pinsrw_s_r_i(a: X86_64Xmmr, b: X86_64Gpr, imm: u8) -> this {$/;"	m
plus	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def plus(i: int, f: byte -> bool) -> int {$/;"	m
plus	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def plus(disp: int) -> X86_64Addr {$/;"	m
plus	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def plus(disp: int) -> X86Addr {$/;"	m
plus	$VIRGIL/lib/util/BitMatrix.v3	/^	def plus(delta: int) -> BitMatrixRow {$/;"	m
plusR	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def plusR(r: X86_64Gpr, scale: byte, disp: int) -> X86_64Addr {$/;"	m
plusSSE	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def plusSSE(disp: int) -> SSEAddr {$/;"	m
plus_rel	$VIRGIL/lib/util/TextReader.v3	/^	def plus_rel(offset: int, f: byte -> bool) -> int {$/;"	m
pmOnEntry	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def pmOnEntry(i: IcInterpreter, probeIp: int) {$/;"	m
pmOnEntry	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def pmOnEntry(i: IcInterpreter, probeIp: int) {$/;"	m
pmOnRet	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def pmOnRet(i: IcInterpreter, probeIp: int) {$/;"	m
pmOnRet	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def pmOnRet(i: IcInterpreter, probeIp: int) {$/;"	m
pmaddubsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaddubsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaddwd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaddwd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxsb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxsb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxsw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxub_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxub_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxub_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxub_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxud_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxud_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxud_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxud_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmaxuw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxuw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmaxuw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmaxuw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminsb_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsb_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminsb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminsw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminub_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminub_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminub_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminub_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminud_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminud_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminud_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminud_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pminuw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminuw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pminuw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pminuw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovmskb_r_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovmskb_r_s(a: X86_64Gpr, b: X86_64Xmmr) -> this {$/;"	m
pmovsxbw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxbw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovsxbw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxbw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovsxdq_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxdq_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovsxdq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxdq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovsxwd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxwd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovsxwd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovsxwd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovzxbw_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxbw_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovzxbw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxbw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovzxdq_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxdq_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovzxdq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxdq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmovzxwd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxwd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
pmovzxwd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmovzxwd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmuldq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmuldq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmulhrsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmulhrsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmulhuw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmulhuw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmulhw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmulhw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmulld_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmulld_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmullw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmullw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pmuludq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pmuludq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pname	$VIRGIL/aeneas/src/mach/Memory.v3	/^def pname(width: int) -> string {$/;"	f
point	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def point() -> FilePoint {$/;"	m
point	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def point: FilePoint;$/;"	d
pointList	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var pointList: LsraPoint;$/;"	d
pointType	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def pointType(l: LsraPoint) -> string {$/;"	m
pointerRangeStartConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def pointerRangeStartConst(addr: Addr) -> SsaConst {$/;"	m
polyMap	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def polyMap = IrUtil.newIrItemMap<List<SsaApplyOp>>();$/;"	d
polySignature	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def polySignature(apply: SsaApplyOp, sig: SpecSignature) {$/;"	m
pop	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def pop() {$/;"	m
pop	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pop(a: X86Rm) {$/;"	m
pop	$VIRGIL/lib/util/Stack.v3	/^	def pop() -> T;$/;"	m
pop1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def pop1() {$/;"	m
pop2	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def pop2() {$/;"	m
popBranchOperands	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def popBranchOperands(opcode: byte) {$/;"	m
popFrame	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def popFrame() -> IcFrame {$/;"	m
popK	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def popK(kind: JvmKind) {$/;"	m
popLastOperand	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def popLastOperand() -> Operand { \/\/ XXX: clean up uses of this$/;"	m
popLoop	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def popLoop() {$/;"	m
popN	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def popN(size: int) {$/;"	m
popValAndPushConst	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def popValAndPushConst(t1: Type, val: int) {$/;"	m
popcnt	$VIRGIL/lib/util/Ints.v3	/^	def popcnt(i: u32) -> int { \/\/ XXX: intrinsic on platforms where possible.$/;"	f
popcnt	$VIRGIL/lib/util/Longs.v3	/^	def popcnt(i: u64) -> int {$/;"	f
popcnt_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def popcnt_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
popcnt_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def popcnt_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
popq_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def popq_m(a: X86_64Addr) -> this {$/;"	m
popq_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def popq_r(a: X86_64Gpr) -> this {$/;"	m
port	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	var port: int;$/;"	d
pos	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var pos: int;$/;"	d
pos	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var pos: int;$/;"	d
pos	$VIRGIL/aeneas/src/mach/RegState.v3	/^	var pos: int;    \/\/ an accumulated number$/;"	d
pos	$VIRGIL/aeneas/src/util/Label.v3	/^	var pos = -1;$/;"	d
pos	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var pos = 0;$/;"	d
pos	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def pos() -> int {$/;"	m
pos	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def pos() -> int { return w.pos; }$/;"	m
pos	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def pos() -> int { return w.pos; }$/;"	m
pos	$VIRGIL/lib/asm/riscv64/RiscV64Assembler.v3	/^	def pos() -> int {$/;"	m
pos	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var pos = -1;$/;"	d
pos	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pos() -> int {$/;"	m
pos	$VIRGIL/lib/util/DataReader.v3	/^	def var pos: int;			\/\/ current position$/;"	d
pos	$VIRGIL/lib/util/DataWriter.v3	/^	def var pos: int;			\/\/ current position$/;"	d
pos	$VIRGIL/lib/util/TextReader.v3	/^	def var pos: int;			\/\/ current position$/;"	d
posAddr	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def posAddr() -> int {$/;"	m
posIntBound	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def posIntBound(x: SsaInstr) -> int {$/;"	m
posIntBoundFromType	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def posIntBoundFromType(x: SsaInstr) -> int {$/;"	m
posToColumn	$VIRGIL/lib/util/TextReader.v3	/^	def posToColumn(at: int) -> int {$/;"	m
posToLine	$VIRGIL/lib/util/TextReader.v3	/^	def posToLine(at: int) -> int {$/;"	m
pos_offset	$VIRGIL/lib/util/DataReader.v3	/^	def var pos_offset: int;		\/\/ address of pos = 0$/;"	d
pow10	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^def pow10 = [  \/\/ cached powers of 10 for small cases$/;"	d
pparams	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def pparams: VstList<PackingParamDecl>;$/;"	d
precoloredCoalesceCheck	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def precoloredCoalesceCheck(precolored: int, y: Node) -> bool{$/;"	m
predValues	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def predValues = Vector<Array<SsaInstr>>.new();$/;"	d
preds	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var preds: Array<SsaCfEdge> = Ssa.NO_CF_EDGES;$/;"	d
prepareParMove	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def prepareParMove(i: ArchInstr) {$/;"	m
prepend	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def prepend(i: SsaInstr) {$/;"	m
prepend	$VIRGIL/lib/util/Arrays.v3	/^	def prepend<T>(val: T, array: Array<T>) -> Array<T> {$/;"	f
prependParamType	$VIRGIL/aeneas/src/types/Function.v3	/^	def prependParamType(ptype: Type, ftype: Type) -> Type {$/;"	f
prependParamTypes	$VIRGIL/aeneas/src/types/Function.v3	/^	def prependParamTypes(ptypes: Array<Type>, ftype: Type) -> Type {$/;"	f
preprocess	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def preprocess(block: SsaBlock, cur: ArchInstr) {$/;"	m
prev	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var prev: LsraPoint;$/;"	d
prev	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	var prev: ArchInstr;$/;"	d
prev	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var prev: VReg;			\/\/ prev link for list management$/;"	d
prev	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var prev: SsaLink;$/;"	d
prev	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var prev: SsaIntFrame;$/;"	d
prev	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var prev: SsaLink;  			\/\/ instruction before the current instruction$/;"	d
prev	$VIRGIL/lib/util/Edge.v3	/^	var prev: Edge<T>;	\/\/ the backward link for the use list$/;"	d
primitive	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var primitive: bool;$/;"	d
primitive	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var primitive: bool;$/;"	d
print	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def print(m: IcMethod, percent: int) {$/;"	m
print	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def print(ip: int, i: IcInstr) {$/;"	m
print	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def print(buf: TerminalBuffer) {$/;"	m
print	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def print() {$/;"	m
print	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def print(m: IrMethod, executed: int, count: int) {$/;"	m
print	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def print(out: ArchInstrBuffer, context: SsaContext, regSet: MachRegSet, code: Vector<CfgInstr>) {$/;"	m
print	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def print() {$/;"	m
printBin	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def printBin(irm: IrMethod, methodStart: int, w: MachDataWriter) {$/;"	m
printBitmap	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def printBitmap() {$/;"	m
printBits	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def printBits(row: int) {$/;"	m
printBlock	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def printBlock(pm: IcMethodProf, range: (int, int), count: int) {$/;"	m
printBlock	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printBlock(block: SsaBlock) {$/;"	m
printBlockHeader	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printBlockHeader(block: SsaBlock) {$/;"	m
printBlocks	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printBlocks(blocks: Array<SsaBlock>) {$/;"	m
printCases	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printCases(c: MatchCase, indent: int) {$/;"	m
printCfEdge	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printCfEdge(e: SsaCfEdge) {$/;"	m
printChain	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printChain(start: SsaLink) -> this {$/;"	m
printClass	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printClass(cldecl: VstClass) {$/;"	m
printCode	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def printCode(iccode: Array<IcInstr>) {$/;"	m
printColonType	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printColonType(t: Type) {$/;"	m
printColor	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def printColor() {$/;"	m
printCommaList	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printCommaList<T>(list: List<T>, print: T -> void) {$/;"	m
printComponent	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printComponent(cdecl: VstComponent) {$/;"	m
printConsts	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def printConsts(firstConst: int, consts: Array<Val>) {$/;"	m
printDest	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printDest(edge: SsaCfEdge) {$/;"	m
printDominators	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def printDominators() {$/;"	m
printEnd	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printEnd(block: SsaBlock, end: SsaEnd) {$/;"	m
printExecuteResult	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def printExecuteResult() {$/;"	m
printExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printExpr(expr: Expr, indent: int) {$/;"	m
printFacts	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printFacts(facts: Fact.set) {$/;"	m
printFacts	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printFacts(facts: Fact.set) -> bool {$/;"	m
printFailure	$VIRGIL/aeneas/src/util/Progress.v3	/^	def printFailure(a: string, b: string) {$/;"	m
printField	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printField(f: IrField, ic: IrClass) {$/;"	m
printField	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printField(fdecl: VstField) {$/;"	m
printGraph	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printGraph(phase: string, render: StringBuilder -> StringBuilder, graph: SsaGraph, sig: Signature) {$/;"	m
printHelp	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def printHelp(args: Array<string>) {$/;"	f
printHelp	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def printHelp(args: string) {$/;"	m
printIc	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	var printIc: bool;$/;"	d
printIcMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def printIcMatcher = CLOptions.PRINT_IC.get();$/;"	d
printInstr	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printInstr(i: SsaInstr, types: bool, args: bool, facts: bool, uses: bool) {$/;"	m
printInstrLn	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printInstrLn(i: SsaInstr) {$/;"	m
printIrClass	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printIrClass(ic: IrClass) {$/;"	m
printLiveness	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def printLiveness(where: string, block: SsaBlock, livein: BitMatrix) {$/;"	m
printLong	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printLong(ic: IrClass, m: IrMember) {$/;"	m
printMachMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def printMachMatcher = CLOptions.PRINT_MACH.get();$/;"	d
printMember	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printMember(decl: VstMember) {$/;"	m
printMethod	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printMethod(m: IrMethod, ic: IrClass) {$/;"	m
printMethod	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printMethod(mdecl: VstMethod) {$/;"	m
printMethodName	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	def printMethodName(m: IrMethod, ic: IrClass) {$/;"	m
printMoveStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def printMoveStack() {$/;"	m
printNew	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printNew(cdecl: VstNew) {$/;"	m
printNoUnboxReason	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def printNoUnboxReason(rc: RaClass, recursive: bool, closure: bool) -> bool {$/;"	m
printNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def printNorm(rc: RaClass, vn: VariantNorm) {$/;"	m
printOptMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def printOptMatcher = CLOptions.PRINT_OPT.get();$/;"	d
printPacking	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printPacking(p: VstPacking) {$/;"	m
printPackingExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printPackingExpr(p: VstPackingExpr) {$/;"	m
printPackingParam	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printPackingParam(param: PackingParamDecl) {$/;"	m
printPair	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def printPair(v: int) {$/;"	m
printParam	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printParam(vdecl: ParamDecl) {$/;"	m
printParams	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printParams(params: Array<SsaParam>) {$/;"	m
printPattern	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printPattern(c: MatchPattern, indent: int) {$/;"	m
printPct	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def printPct(v: int) {$/;"	m
printProgram	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printProgram(prog: Program) {$/;"	m
printProgramResult	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def printProgramResult() {$/;"	m
printRef	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printRef(i: SsaDfEdge) {$/;"	m
printRepHint	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printRepHint(repHint: VstRepHint) {$/;"	m
printSingleNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def printSingleNorm(rc: RaClass, vn: VariantNorm) {$/;"	m
printSsa	$VIRGIL/aeneas/src/ir/IrPrinter.v3	/^	var printSsa: bool;$/;"	d
printSsa	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def printSsa(phase: string) {$/;"	m
printSsaMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def printSsaMatcher = CLOptions.PRINT_SSA.get();$/;"	d
printStack	$VIRGIL/rt/x86-64-darwin/System.v3	/^	var printStack: (Pointer, Pointer) -> void;$/;"	d
printStats	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printStats(phase: string, render: StringBuilder -> StringBuilder, graph: SsaGraph) {$/;"	m
printStmt	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printStmt(stmt: Stmt, indent: int) {$/;"	m
printToken	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printToken(t: Token) {$/;"	m
printTotal	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def printTotal(meth: IrMethod, p: (int, int)) {$/;"	m
printType	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printType(t: Type) {$/;"	m
printTypeArray	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printTypeArray(a: Array<Type>) {$/;"	m
printTypeParam	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printTypeParam(tparam: TypeParamType) {$/;"	m
printTypeParams	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printTypeParams(list: List<TypeParamType>) {$/;"	m
printTypeRef	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printTypeRef(tref: TypeRef) {$/;"	m
printUs	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def printUs(v: int) {$/;"	m
printUsageAndSharedOptions	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def printUsageAndSharedOptions(buf: TerminalBuffer, usage: string) {$/;"	f
printValues	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def printValues(values: Array<SsaConst>) {$/;"	m
printVar	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printVar(vdecl: VarDecl, indent: int) {$/;"	m
printVersion	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def printVersion(long: bool, next: string) {$/;"	f
printVstCompound	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printVstCompound(kind: string, compound: VstCompound) {$/;"	m
printVstField	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printVstField(fdecl: VstField) {$/;"	m
printVstMethod	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def printVstMethod(mdecl: VstMethod) {$/;"	m
printer	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var printer: IcPrinter;$/;"	d
printer	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def printer = SsaPrinter.new();$/;"	d
printer	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var printer: SsaPrinter;$/;"	d
processBlock	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def processBlock(b: SsaBlockInfo, livein: BitMatrix, blindex: int) {$/;"	m
processCalls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def processCalls(sig: SpecSignature, poly: SpecSet, src: SpecMethod) {$/;"	m
processComponent	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def processComponent(ic: IrClass) {$/;"	m
processConstraint	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def processConstraint(vreg: VReg, constraint: int, weight: int) {$/;"	m
processDefs	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def processDefs(d: LsraDef) {$/;"	m
processInstr	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def processInstr(i: ArchInstr) {$/;"	m
processInstrs	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def processInstrs(start: int, end: int, livein: BitMatrix, blindex: int) {$/;"	m
processIrClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def processIrClass(ic: IrClass) {$/;"	m
processIrClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def processIrClass(ic: IrClass) {$/;"	m
processIrClass	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def processIrClass(ic: IrClass) {$/;"	m
processIrClass	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def processIrClass(ic: IrClass) {$/;"	m
processKeypress	$VIRGIL/lib/term/Animator.v3	/^	private def processKeypress(us: u32) {$/;"	m
processMoveStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def processMoveStack(next: ArchInstr) {$/;"	m
processSpill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def processSpill(vreg: VReg, constraint: int, block: SsaBlock) {$/;"	m
processSpillOnBlock	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def processSpillOnBlock(vreg: VReg, block: SsaBlock) {$/;"	m
processSpillOnInstr	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def processSpillOnInstr(vreg: VReg, constraint: int) -> VReg {$/;"	m
processType	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def processType(t: Type, tn: RaType) {$/;"	m
processUses	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def processUses(u: LsraUse) {$/;"	m
profMap	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def profMap = HashMap<IcMethod, IcMethodProf>.new(IcMethod.uid, IcMethod.==);$/;"	d
profSeq	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def profSeq = Vector<IcMethodProf>.new();$/;"	d
prog	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def prog: Program;$/;"	d
prog	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def prog: Program;$/;"	d
prog	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def prog = compilation.prog;$/;"	d
properties	$VIRGIL/aeneas/src/util/Char.v3	/^	var properties = Array<byte>.new(256);$/;"	d
pshufb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pshufb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pshufd_s_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pshufd_s_s_i(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
pshuflw_s_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pshuflw_s_s_i(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
psl_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def psl_i(a: X86_64Xmmr, imm: byte, c2: byte, eop: byte) {$/;"	m
pslld_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pslld_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
pslld_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pslld_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x72, a, 0x6, imm); }$/;"	m
pslld_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pslld_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psllq_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psllq_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
psllq_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def psllq_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x73, a, 0x6, imm); }$/;"	m
psllq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psllq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psllw_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psllw_i(a: X86_64Xmmr, imm: u5) -> this {$/;"	m
psllw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psllw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psrad_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrad_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
psrad_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrad_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psraw_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psraw_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
psraw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psraw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psrld_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrld_i(a: X86_64Xmmr, imm: u5) -> this {$/;"	m
psrld_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def psrld_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x72, a, 0x2, imm); }$/;"	m
psrld_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrld_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psrlq_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrlq_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
psrlq_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def psrlq_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x73, a, 0x2, imm); }$/;"	m
psrlq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrlq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psrlw_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrlw_i(a: X86_64Xmmr, imm: u6) -> this {$/;"	m
psrlw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psrlw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubsb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubsb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubsw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubsw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubusb_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubusb_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubusw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubusw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
psubw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def psubw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
ptest_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ptest_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
ptr	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def ptr = "Pointer";$/;"	d
ptrAdd	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrAdd(base: SsaInstr, offset: SsaInstr) -> SsaInstr {$/;"	m
ptrLoad	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrLoad(vt: Type, p: SsaInstr, offset: int) -> SsaInstr {$/;"	m
ptrLoadT	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrLoadT(source: Source, t: Type, p: SsaInstr, offset: int) -> SsaInstr {$/;"	m
ptrStore	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrStore(vt: Type, p: SsaInstr, offset: int, v: SsaInstr) -> SsaInstr {$/;"	m
ptrStoreCommon	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrStoreCommon(source: Source, vt: Type, p: SsaInstr, offset: int, v: SsaInstr) -> SsaInstr {$/;"	m
ptrStoreT	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def ptrStoreT(source: Source, vt: Type, p: SsaInstr, offset: int, v: SsaInstr) -> SsaInstr {$/;"	m
ptrType	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def ptrType: Type;$/;"	d
ptrType	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def ptrType: PointerType = PointerType.!(ptrTypeCon.create0());$/;"	d
ptrTypeCon	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def ptrTypeCon: TypeCon = Pointer_TypeCon.new(pname(addressWidth), addressWidth);$/;"	d
punpckhbw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpckhbw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
punpckhdq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpckhdq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
punpckhwd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpckhwd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
punpcklbw_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpcklbw_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
punpcklqdq_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpcklqdq_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
punpcklwd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def punpcklwd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
pure	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def pure(op: Operator, args: Array<SsaInstr>) -> SsaApplyOp {$/;"	m
pure	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var pure = SsaLoadedFields.new();$/;"	d
purple	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def purple() -> this {$/;"	m
push	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def push(sji: SsaJvmInstr) {$/;"	m
push	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	def push(block: SsaCfEdge) {$/;"	m
push	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def push(a: X86Rm) {$/;"	m
push	$VIRGIL/lib/util/Stack.v3	/^	def push(val: T);$/;"	m
push1	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def push1() {$/;"	m
pushFrame	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def pushFrame(retIp: int, retReg: int, memberRef: IrSpec, icm: IcMethod) {$/;"	m
pushFrame	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def pushFrame(spec: IrSpec, recvr: Val, args: Range<Val>) {$/;"	m
pushLoop	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def pushLoop() -> int {$/;"	m
pushN	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def pushN(size: int) {$/;"	m
pushOntoMoveStack	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def pushOntoMoveStack(vreg: VReg, next: ArchInstr) -> bool {$/;"	m
pushRestoreUp	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def pushRestoreUp(info: SsaBlockInfo) {$/;"	m
push_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def push_i(imm: int) {$/;"	m
pusha	$VIRGIL/lib/util/Stack.v3	/^	def pusha(v: Array<T>) {$/;"	m
pushfd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def pushfd() { emitb(0x9C); }$/;"	m
pushfq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pushfq() -> this { emitb(0x9C); }$/;"	m
pushn	$VIRGIL/lib/util/Stack.v3	/^	def pushn(v: T, n: int) -> this {$/;"	m
pushq_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pushq_i(imm: int) -> this {$/;"	m
pushq_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pushq_m(a: X86_64Addr) -> this {$/;"	m
pushq_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pushq_r(a: X86_64Gpr) -> this {$/;"	m
put	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def put(meth: SpecMethod) {$/;"	m
put	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def put(str: string) { System.puts(str); }$/;"	f
put	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def put(w: DataWriter) {$/;"	m
put	$VIRGIL/lib/util/Vector.v3	/^	def put(element: T) -> this {$/;"	m
put1	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def put1<A>(fmt: string, a: A) { buf.put1(fmt, a).outt(); }$/;"	f
put1	$VIRGIL/lib/util/StringBuilder.v3	/^	def put1<T1>(fmt: string, p1: T1) -> this {$/;"	m
put2	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def put2<A, B>(fmt: string, a: A, b: B) { buf.put2(fmt, a, b).outt(); }$/;"	f
put2	$VIRGIL/lib/util/StringBuilder.v3	/^	def put2<T1, T2>(fmt: string, p1: T1, p2: T2) -> this {$/;"	m
put3	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def put3<A, B, C>(fmt: string, a: A, b: B, c: C) { buf.put3(fmt, a, b, c).outt(); }$/;"	f
put3	$VIRGIL/lib/util/StringBuilder.v3	/^	def put3<T1, T2, T3>(fmt: string, p1: T1, p2: T2, p3: T3) -> this {$/;"	m
putArchInstr	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def putArchInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putArchInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putArchInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putArchInstr	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def putArchInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putArchInstr	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def putArchInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putArchWithI	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putArchWithI(name: string, x: Array<Operand>) -> this {$/;"	m
putArg	$VIRGIL/lib/util/StringBuilder.v3	/^	private def putArg<T>(fmt: string, offset: int, p: T) -> int {$/;"	m
putBacktrace	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putBacktrace(s: Source) {$/;"	m
putBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putBlock(indent: int, i: ArchInstr) -> int {$/;"	m
putBreakpoint	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putBreakpoint(args: string, idx: int, source: Source) {$/;"	m
putCallConv	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putCallConv(spec: SpecSignature, sig: Signature) {$/;"	m
putConstraint	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putConstraint(constraint: int) -> this {$/;"	m
putData	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putData(instr: SsaInstr, targetFrame: SsaIntFrame) {$/;"	m
putDigit	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def putDigit(v: int, mod: int, z: bool) {$/;"	m
putDirRef	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def putDirRef(info: DwarfDir) {$/;"	m
putEqVal	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def putEqVal(v: Val, t: Type) {$/;"	m
putField	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putField(apply: SsaApplyOp, field: IrField, sig: SpecSignature) {$/;"	m
putFileRef	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def putFileRef(filename: string, info: DwarfFile) {$/;"	m
putIndent	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putIndent(indent: int) {$/;"	m
putIndent	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putIndent() {$/;"	m
putInputs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def putInputs(inputs: Array<SsaDfEdge>) -> SsaPrinter {$/;"	m
putInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putInstrV	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putInstrV(i: ArchInstr) -> this {$/;"	m
putInt	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putInt(h: int) {$/;"	m
putInto	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def putInto(i: SsaInstr, vec: Vector<SsaInstr>) -> bool {$/;"	m
putJsValue	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def putJsValue(buf: StringBuilder, r: Result) -> StringBuilder {$/;"	m
putLineStrDir	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def putLineStrDir(info: DwarfDir) {$/;"	m
putLineStrFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def putLineStrFile(name: string, info: DwarfFile) {$/;"	m
putLiveness	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putLiveness(liveness: BitMatrix, index: int) {$/;"	m
putMemory	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putMemory(t: Type) {$/;"	m
putNamedInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putNamedInstr(indent: int, name: string, x: Array<Operand>) -> int {$/;"	m
putNewIndent	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putNewIndent(targetFrame: SsaIntFrame) {$/;"	m
putOperand	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putOperand(o: Operand) -> this {$/;"	m
putOperands	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putOperands(x: Array<Operand>) -> this {$/;"	m
putOperands2	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def putOperands2(a: Array<Operand>, start: int) {$/;"	m
putPad	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putPad() {$/;"	m
putSimpleInstr	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putSimpleInstr(indent: int, i: ArchInstr) -> int {$/;"	m
putSsa	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putSsa(i: SsaInstr) -> this {$/;"	m
putSsaBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putSsaBlock(block: SsaBlock) {$/;"	m
putType	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def putType(t: Type) {$/;"	m
putType	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putType(spec: Specializer, t: TypeNorm) {$/;"	m
putUnitLength	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^def putUnitLength(w: DataWriter, start: int) {$/;"	f
putUpToArg	$VIRGIL/lib/util/StringBuilder.v3	/^	private def putUpToArg(fmt: string, offset: int) -> (int, int) {$/;"	m
putV	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def putV<T>(vec: Vector<T>, val: T) {$/;"	m
putVReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def putVReg(mode: string, vreg: VReg) -> this {$/;"	m
putVal	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def putVal(spec: Specializer, v: Val) {$/;"	m
putVal	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def putVal(instr: SsaInstr) {$/;"	m
putWasmValue	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def putWasmValue(buf: StringBuilder, r: Result) -> StringBuilder {$/;"	m
put_b16	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b16(data: int) -> this {$/;"	m
put_b16be	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b16be(data: int) -> this {$/;"	m
put_b32	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b32(data: int) -> this {$/;"	m
put_b32be	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b32be(data: int) -> this {$/;"	m
put_b64	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b64(data: long) -> this {$/;"	m
put_b64be	$VIRGIL/lib/util/DataWriter.v3	/^	def put_b64be(data: long) -> this {$/;"	m
put_sleb32	$VIRGIL/lib/util/DataWriter.v3	/^	def put_sleb32(data: int) -> this {$/;"	m
put_sleb64	$VIRGIL/lib/util/DataWriter.v3	/^	def put_sleb64(data: long) -> this {$/;"	m
put_uleb32	$VIRGIL/lib/util/DataWriter.v3	/^	def put_uleb32(data: u32) -> this {$/;"	m
puta	$VIRGIL/lib/util/DataWriter.v3	/^	def puta(data: Array<byte>) -> this {$/;"	m
puta	$VIRGIL/lib/util/Vector.v3	/^	def puta(a: Array<T>) -> this {$/;"	m
putb	$VIRGIL/lib/util/DataWriter.v3	/^	def putb(data: int) -> this {$/;"	m
putbb	$VIRGIL/lib/util/DataWriter.v3	/^	def putbb(b0: int, b1: int) -> this {$/;"	m
putbbb	$VIRGIL/lib/util/DataWriter.v3	/^	def putbbb(b0: int, b1: int, b2: int) -> this {$/;"	m
putc	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putc(ch: byte) {$/;"	f
putc	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def putc(args: Arguments) -> Val {$/;"	m
putc	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def putc(ch: byte) {$/;"	m
putc	$VIRGIL/lib/term/Vt100.v3	/^	def putc = System.putc;$/;"	d
putc	$VIRGIL/lib/util/StringBuilder.v3	/^	def putc(c: byte) -> this {$/;"	m
putc	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def putc(ch: byte) {$/;"	f
putc_buffer	$VIRGIL/aeneas/src/util/Terminal.v3	/^	private var putc_buffer: Array<byte> = Array.new(1);$/;"	d
putcv	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putcv(v: Result, t: Type) -> this {$/;"	m
putd	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putd(val: int) { System.puti(val); }$/;"	f
putd	$VIRGIL/lib/util/StringBuilder.v3	/^	def putd<T>(i: T) -> this {$/;"	m
putd4	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def putd4(v: int) {$/;"	m
putd7	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def putd7(v: int) {$/;"	m
putd_i32	$VIRGIL/lib/util/StringBuilder.v3	/^	def putd_i32(i: i32) -> this {$/;"	m
putd_i64	$VIRGIL/lib/util/StringBuilder.v3	/^	def putd_i64(i: i64) -> this {$/;"	m
putd_u32	$VIRGIL/lib/util/StringBuilder.v3	/^	def putd_u32(i: u32) -> this {$/;"	m
putd_u64	$VIRGIL/lib/util/StringBuilder.v3	/^	def putd_u64(i: u64) -> this {$/;"	m
putdd	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def putdd(id: int) {$/;"	m
putfield	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def putfield(jclass: JvmClass, fname: string, jtype: JvmType) {$/;"	m
puthashv	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def puthashv(v: Result, t: Type) -> this {$/;"	m
puti	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def puti(args: Arguments) -> Val {$/;"	m
puti	$VIRGIL/lib/term/Vt100.v3	/^	def puti = System.puti;$/;"	d
puti	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def puti(i: int) {$/;"	f
putk	$VIRGIL/lib/util/DataReader.v3	/^	def putk(expecting: int, x: Array<byte>, xpos: int, xlength: int) -> this {$/;"	m
putk	$VIRGIL/lib/util/DataWriter.v3	/^	def putk(data: Array<byte>, start: int, end: int) -> this {$/;"	m
putk	$VIRGIL/lib/util/StringBuilder.v3	/^	def putk(s: string, start: int, end: int) -> this {$/;"	m
putk	$VIRGIL/lib/util/Vector.v3	/^	def putk(a: Array<T>, start: int, end: int) -> this {$/;"	m
putkv	$VIRGIL/lib/util/DataWriter.v3	/^	def putkv(data: Array<byte>, start: int, end: int) {$/;"	m
putln	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putln(str: string) {$/;"	f
putn	$VIRGIL/lib/util/Vector.v3	/^	def putn(v: T, n: int) -> this {$/;"	m
putnull	$VIRGIL/aeneas/src/ssa/SsaPrinter.v3	/^	def putnull() {$/;"	m
putr	$VIRGIL/lib/util/DataWriter.v3	/^	def putr(data: Range<byte>) -> this {$/;"	m
putr	$VIRGIL/lib/util/StringBuilder.v3	/^	def putr(r: Range<byte>) -> this {$/;"	m
putr	$VIRGIL/lib/util/Vector.v3	/^	def putr(r: Range<T>) -> this {$/;"	m
putref	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putref(i: SsaLink) -> this {$/;"	m
puts	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def puts(args: Arguments) -> Val {$/;"	m
puts	$VIRGIL/lib/term/Vt100.v3	/^	def puts = System.puts;$/;"	d
puts	$VIRGIL/lib/util/StringBuilder.v3	/^	def puts(s: string) -> this {$/;"	m
puts	$VIRGIL/lib/util/Strings.v3	/^	def puts(s: string) -> StringBuilder -> StringBuilder {$/;"	f
puts	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def puts(str: string) {$/;"	f
putsq	$VIRGIL/lib/util/StringBuilder.v3	/^	def putsq(s: string) -> this {$/;"	m
putstatic	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def putstatic(jclass: JvmClass, fname: string, jtype: JvmType) {$/;"	m
pututf8	$VIRGIL/lib/util/StringBuilder.v3	/^	def pututf8(codepoint: u32) -> this {$/;"	m
putv	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def putv(v: Result, t: Type) -> this {$/;"	m
putv	$VIRGIL/lib/util/Vector.v3	/^	def putv(v: Vector<T>) -> this {$/;"	m
putx	$VIRGIL/lib/util/StringBuilder.v3	/^	def putx<T>(i: T) -> this {$/;"	m
putx_16	$VIRGIL/lib/util/StringBuilder.v3	/^	def putx_16(i: u32) -> this {$/;"	m
putx_32	$VIRGIL/lib/util/StringBuilder.v3	/^	def putx_32(i: u32) -> this {$/;"	m
putx_64	$VIRGIL/lib/util/StringBuilder.v3	/^	def putx_64(i: u64) -> this {$/;"	m
putx_8	$VIRGIL/lib/util/StringBuilder.v3	/^	def putx_8(i: u32) -> this {$/;"	m
putxv_32	$VIRGIL/lib/util/StringBuilder.v3	/^	def putxv_32(i: u32) -> this {$/;"	m
putxv_64	$VIRGIL/lib/util/StringBuilder.v3	/^	def putxv_64(i: u64) -> this {$/;"	m
putz	$VIRGIL/lib/util/StringBuilder.v3	/^	def putz(b: bool) -> this {$/;"	m
pxor_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def pxor_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
queue	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def queue = WorkQueue.new();$/;"	d
queue	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def queue = WorkQueue.new();$/;"	d
queue	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def queue = Vector<SsaBlock>.new();$/;"	d
queueBlock	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def queueBlock(block: SsaBlock) {$/;"	m
queueMethod	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def queueMethod(poly: SpecSet) {$/;"	m
queued	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var queued: bool;			\/\/ currently on the queue$/;"	d
queued	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var queued: bool;$/;"	d
r_rm	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def r_rm(a: X86Reg, b: X86Rm) { \/\/ register, register\/memory$/;"	m
raFacts	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var raFacts: RaFact.set;$/;"	d
raFacts	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	var raFacts: RaFact.set;$/;"	d
raField	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var raField: RaField;   \/\/ information for reachability analysis$/;"	d
raMethod	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var raMethod: RaMethod;		\/\/ information for reachability analysis$/;"	d
raTarget	$VIRGIL/aeneas/src/ir/Reachability.v3	/^def raTarget = Aeneas.registerTarget(RaTarget.new());$/;"	d
random	$VIRGIL/lib/util/Random.v3	/^	def random(max: int) -> int {$/;"	f
random2	$VIRGIL/lib/util/Random.v3	/^	def random2(max: int, extra: int) -> int {$/;"	f
range	$VIRGIL/aeneas/src/core/Eval.v3	/^	def range(i: int) -> (Record, int, int) {$/;"	m
range	$VIRGIL/aeneas/src/main/Error.v3	/^	def range: FileRange;$/;"	d
range	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def range() -> FileRange {$/;"	m
range	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def range() -> FileRange;$/;"	m
range	$VIRGIL/lib/util/Arrays.v3	/^	def range<T>(array: Array<T>, start: int, end: int) -> Array<T> {$/;"	f
range	$VIRGIL/lib/util/BitMatrix.v3	/^	def range(minRow: int, maxRow: int) -> BitMatrix {$/;"	m
range	$VIRGIL/lib/util/TextReader.v3	/^	def range() -> FileRange {$/;"	m
range	$VIRGIL/lib/util/Token.v3	/^	def range() -> FileRange {$/;"	m
rangeByteNorm	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	var rangeByteNorm = RangeNorm.!(norm.norm(V3.rangeByteType));$/;"	d
rangeByteType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def rangeByteType   = V3Range.newType(Byte.TYPE);$/;"	d
rangeOf	$VIRGIL/lib/util/Token.v3	/^	def rangeOf(len: int) -> FileRange {$/;"	m
rangeStartAdd	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def rangeStartAdd(start: SsaInstr, index: SsaInstr) -> SsaInstr {$/;"	m
rangeStartType	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	var rangeStartType: Type;$/;"	d
rangeToInetAddress	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def rangeToInetAddress(r: Range<byte>) -> NetResult<InetAddress> {$/;"	f
rangeType	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	var rangeType = V3Range.newType(typeParam);$/;"	d
rank	$VIRGIL/aeneas/src/types/Int.v3	/^	def rank = Int.rankOf(width, signed);$/;"	d
rankOf	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def rankOf(it: IntType) -> byte {$/;"	m
rankOf	$VIRGIL/aeneas/src/types/Int.v3	/^	def rankOf(width: byte, signed: bool) -> IntRank {$/;"	f
rawMap	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	var rawMap: HashMap<(int, int), int>;$/;"	d
rclasses	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private var rclasses = mapRegClasses([$/;"	d
rdfsbase	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rdfsbase(a: X86_64Gpr) -> this { emitb(0xF3); emit_rex_bb_r(a, OP_REX, 0x0F, 0xAE, 0x0); }$/;"	m
rdgsbase	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rdgsbase(a: X86_64Gpr) -> this { emitb(0xF3); emit_rex_bb_r(a, OP_REX, 0x0F, 0xAE, 0x1); }$/;"	m
rdtsc	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rdtsc() -> this { emitbb(0x0F, 0x31); }$/;"	m
reachability	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def reachability() -> bool {$/;"	m
reachable	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def reachable() -> bool {$/;"	m
read	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def read(bigEndian: bool, offset: int, count: int) -> u64 {$/;"	m
read	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def read(args: Arguments) -> Result {$/;"	m
read	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var read: AppBinding;$/;"	d
read	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def read(fd: int, data: Range<byte>) -> int {$/;"	f
read1	$VIRGIL/lib/util/DataReader.v3	/^	def read1() -> byte {$/;"	m
readBit	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def readBit(b: int) -> u1 {$/;"	m
readN	$VIRGIL/lib/util/DataReader.v3	/^	def readN(length: int) -> Array<byte> {$/;"	m
readToken	$VIRGIL/lib/util/TextReader.v3	/^	def readToken(len: int) -> Token {$/;"	m
readTokenAt	$VIRGIL/lib/util/TextReader.v3	/^	def readTokenAt(start: int, end: int) -> Token {$/;"	m
read_range_double	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_double(r: Range<byte>)	-> double { return Ref<Layout_double>.of(r).val; }$/;"	f
read_range_float	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_float(r: Range<byte>)	-> float { return Ref<Layout_float>.of(r).val; }$/;"	f
read_range_i16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i16(r: Range<byte>)	-> i16 { return Ref<Layout_i16>.of(r).val; }$/;"	f
read_range_i32	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i32(r: Range<byte>)	-> i32 { return Ref<Layout_i32>.of(r).val; }$/;"	f
read_range_i32_i16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i32_i16(r: Range<byte>)	-> i32 { return i32.view(i16.view(Ref<Layout_u16>.of(r).val)); }$/;"	f
read_range_i32_i8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i32_i8(r: Range<byte>)	-> i32 { return i32.view(i8.view(r[0])); }$/;"	f
read_range_i64	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i64(r: Range<byte>)	-> i64 { return Ref<Layout_i64>.of(r).val; }$/;"	f
read_range_i64_i16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i64_i16(r: Range<byte>)	-> i64 { return i64.view(i16.view(Ref<Layout_u16>.of(r).val)); }$/;"	f
read_range_i64_i32	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i64_i32(r: Range<byte>)	-> i64 { return i64.view(i32.view(Ref<Layout_u32>.of(r).val)); }$/;"	f
read_range_i64_i8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i64_i8(r: Range<byte>)	-> i64 { return i64.view(i8.view(r[0])); }$/;"	f
read_range_i8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_i8(r: Range<byte>)	-> i8  { return i8.view(r[0]); }$/;"	f
read_range_u128	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u128(r: Range<byte>)	-> (u64, u64) {$/;"	f
read_range_u16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u16(r: Range<byte>)	-> u16 { return Ref<Layout_u16>.of(r).val; }$/;"	f
read_range_u32	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u32(r: Range<byte>)	-> u32 { return Ref<Layout_u32>.of(r).val; }$/;"	f
read_range_u32_i16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u32_i16(r: Range<byte>)	-> u32 { return u32.view(i16.view(Ref<Layout_u16>.of(r).val)); }$/;"	f
read_range_u32_i8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u32_i8(r: Range<byte>)	-> u32 { return u32.view(i8.view(r[0])); }$/;"	f
read_range_u32_u16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u32_u16(r: Range<byte>)	-> u32 { return Ref<Layout_u16>.of(r).val; }$/;"	f
read_range_u32_u8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u32_u8(r: Range<byte>)	-> u32 { return r[0]; }$/;"	f
read_range_u64	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64(r: Range<byte>)	-> u64 { return Ref<Layout_u64>.of(r).val; }$/;"	f
read_range_u64_i16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_i16(r: Range<byte>)	-> u64 { return u64.view(i16.view(Ref<Layout_u16>.of(r).val)); }$/;"	f
read_range_u64_i32	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_i32(r: Range<byte>)	-> u64 { return u64.view(i32.view(Ref<Layout_u32>.of(r).val)); }$/;"	f
read_range_u64_i8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_i8(r: Range<byte>)	-> u64 { return u64.view(i8.view(r[0])); }$/;"	f
read_range_u64_u16	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_u16(r: Range<byte>)	-> u64 { return Ref<Layout_u16>.of(r).val; }$/;"	f
read_range_u64_u32	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_u32(r: Range<byte>)	-> u64 { return Ref<Layout_u32>.of(r).val; }$/;"	f
read_range_u64_u8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u64_u8(r: Range<byte>)	-> u64 { return r[0]; }$/;"	f
read_range_u8	$VIRGIL/lib/util/DataReader.v3	/^	def read_range_u8(r: Range<byte>)	-> u8  { return r[0]; }$/;"	f
read_sleb32	$VIRGIL/lib/util/DataReader.v3	/^	def read_sleb32() -> i32 {$/;"	m
read_sleb64	$VIRGIL/lib/util/DataReader.v3	/^	def read_sleb64() -> i64 {$/;"	m
read_u32	$VIRGIL/lib/util/DataReader.v3	/^	def read_u32() -> u32 {$/;"	m
read_u64	$VIRGIL/lib/util/DataReader.v3	/^	def read_u64() -> u64 {$/;"	m
read_uleb32	$VIRGIL/lib/util/DataReader.v3	/^	def read_uleb32() -> u32 {$/;"	m
read_uleb64	$VIRGIL/lib/util/DataReader.v3	/^	def read_uleb64() -> u64 {$/;"	m
read_xleb32	$VIRGIL/lib/util/DataReader.v3	/^	private def read_xleb32(first: byte, signed: bool, msg: string) -> u32 {$/;"	m
read_xleb64	$VIRGIL/lib/util/DataReader.v3	/^	private def read_xleb64(first: byte, signed: bool, msg: string) -> u64 {$/;"	m
readonlyType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var readonlyType: Type;$/;"	d
reassignReg	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def reassignReg(vreg: VReg, reg: int) -> int {$/;"	m
reassignReg	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def reassignReg(vreg: VReg, reg: int) -> VReg {$/;"	m
rebalance	$VIRGIL/aeneas/src/types/Type.v3	/^	private def rebalance(buckets: Array<Type>) -> Array<Type> {$/;"	m
rec	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def rec: JvmHI_Record;$/;"	d
receiver	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var receiver: VstCompound;$/;"	d
record	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var record: Record;$/;"	d
record	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	private def record(mode: int, num: int, fixed: int) -> int {$/;"	m
recordAbs32	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def recordAbs32(pos: int, addr: X86_64Addr) {$/;"	m
recordAbs32	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def recordAbs32(pos: int, addr: X86_64Addr) {$/;"	m
recordAddr	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordAddr(c: CiRuntime_Address, addr: int) {$/;"	m
recordAddr	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def recordAddr(val: Val) {$/;"	m
recordBranch	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def recordBranch(branchLoc: int, target: int) {$/;"	m
recordBranch	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def recordBranch(pos: int, target: SsaBlock) {$/;"	m
recordCall	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def recordCall(callLoc: int, target: IrMethod) {$/;"	m
recordCodeEnd	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordCodeEnd(addr: int) {$/;"	m
recordCodeStart	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordCodeStart(addr: int) {$/;"	m
recordConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def recordConst(r: Record) -> SsaConst {$/;"	m
recordCount	$VIRGIL/aeneas/src/core/Program.v3	/^	var recordCount: int;$/;"	d
recordDataEnd	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordDataEnd(addr: int) {$/;"	m
recordDataRefs	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	private def recordDataRefs(a: Addr, off: int, size: int) {$/;"	m
recordDataSize	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordDataSize(size: int) {$/;"	m
recordDataStart	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordDataStart(addr: int) {$/;"	m
recordDirectCall	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def recordDirectCall(spec: IrSpec) {$/;"	m
recordDirectCall	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def recordDirectCall(spec: IrSpec) {$/;"	m
recordDirectCalls	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var recordDirectCalls: bool;$/;"	d
recordExSource	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def recordExSource(a: Array<Operand>) {$/;"	m
recordExtendedEntry	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	private def recordExtendedEntry(ex: string, source: Source) -> int {$/;"	m
recordExtendedSource	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordExtendedSource(exstrIndex: int, source: Source) {$/;"	m
recordFrameEnd	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordFrameEnd(off: int) {$/;"	m
recordFrameStart	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	private def recordFrameStart(source: VstMethod, off: int, nameOffset: int, classEntry: int, frame: MachFrame) {$/;"	m
recordIndex	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var recordIndex: int;$/;"	d
recordLive	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def recordLive(index: int) {$/;"	m
recordMap	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var recordMap = V3.newRecordMap<Record>(); \/\/ XXX: canonicalize equivalent variant records$/;"	d
recordMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def recordMap     = V3.newRecordMap<Address<Record>>();$/;"	d
recordMethodStart	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordMethodStart(off: int, source: VstMethod, frame: MachFrame) {$/;"	m
recordPatch	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def recordPatch(asm: ArmAssembler, addr: Addr) {$/;"	m
recordPatch	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def recordPatch(addr: Addr, pos: int) {$/;"	m
recordPatch	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def recordPatch(addr: Addr) {$/;"	m
recordPatch	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def recordPatch(start: int, addr: Addr) {$/;"	m
recordPatch	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def recordPatch(start: int, target: Addr) {$/;"	m
recordQueue	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def recordQueue   = Vector<Record>.new();$/;"	d
recordRel32	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def recordRel32(pos: int, delta: int, addr: X86_64Addr) {$/;"	m
recordRel32	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def recordRel32(pos: int, delta: int, addr: X86_64Addr) {$/;"	m
recordReturnSource	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordReturnSource(off: int, source: Source) {$/;"	m
recordReturnSource	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def recordReturnSource(a: Array<Operand>) {$/;"	m
recordRootObject	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordRootObject(off: int, r: Record) {$/;"	m
recordRootRef	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordRootRef(off: int) {$/;"	m
recordRootRefRange	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordRootRefRange(startOff: int, endOff: int) {$/;"	m
recordSource	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordSource(off: int, source: Source) {$/;"	m
recordStackEnd	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordStackEnd(addr: int) {$/;"	m
recordStackRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordStackRefMap(off: int, source: Source, stackMap: int) {$/;"	m
recordStackStart	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def recordStackStart(addr: int) {$/;"	m
recordStubStart	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def recordStubStart(off: int, name: string, frame: MachFrame) {$/;"	m
recordTypeRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def recordTypeRefMap(ic: IrClass) {$/;"	m
records	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def records = V3.newRecordMap<Record>();$/;"	d
recurse	$VIRGIL/aeneas/src/types/Type.v3	/^	private def recurse(typeSubst: TypeSubst) -> Type {$/;"	m
recursive	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var recursive: int;			\/\/ 0 if unknown, < 0 if on stack, 1 if not recursive, > 1 if recursive$/;"	d
recursivelyEmitMoves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def recursivelyEmitMoves(j: int, next: ArchInstr) {$/;"	m
recursivelyEmitMoves	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def recursivelyEmitMoves(j: int, next: ArchInstr) {$/;"	m
recursivelyEmitMoves	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def recursivelyEmitMoves(j: int, next: ArchInstr) {$/;"	m
recv	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def recv(buf: Array<byte>) -> NetResult<int> {$/;"	m
recvfrom	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def recvfrom(sockfd: int, buf: Array<byte>, sockAddr: Array<byte>) -> NetResult<(int, int)> {$/;"	f
red	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def red<T>(fmt: string, a: T) { color(CTRL_RED, fmt, a); }$/;"	f
redefFile	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var redefFile: VstFile;				\/\/ synthetic file for field redefinition string$/;"	d
redefineField	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def redefineField(r: VstRedefField, tc: TypeChecker) {$/;"	m
reduce	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def reduce(p: ParserState, exprStack: ListStack<Expr>, operStack: ListStack<InfixOp>, prec: int) {$/;"	f
reduce	$VIRGIL/lib/util/List.v3	/^	def reduce<A, B, C>(a: List<A>, b: List<B>, func: (A, B) -> C) -> List<C> {$/;"	f
reduceApply	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reduceApply(state: SsaBlockState, app: SsaApplyOp) -> SsaInstr {$/;"	m
reduceApplyOp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reduceApplyOp(i: SsaApplyOp) -> SsaInstr {$/;"	m
reduceBlock	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reduceBlock(block: SsaBlock) {$/;"	m
reduceIf	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reduceIf(state: SsaBlockState, i: SsaIf) {$/;"	m
reduceInstr	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reduceInstr(i: SsaInstr) -> SsaInstr {$/;"	m
reducePhi	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reducePhi(i: SsaPhi) -> bool {$/;"	m
reduceV	$VIRGIL/lib/util/List.v3	/^	def reduceV<A, B, R>(a: List<A>, b: List<B>, func: (A, B) -> R) {$/;"	f
redundantBranch	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def redundantBranch(bi: SsaBlockInfo, depth: int) -> bool {$/;"	m
ref	$VIRGIL/aeneas/src/core/Eval.v3	/^	def ref(i: int) -> ByteArrayOffset { return ByteArrayOffset.!(vals[i]); }$/;"	m
ref	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def ref(addr: Addr) -> X86_64AddrRef {$/;"	m
ref	$VIRGIL/aeneas/src/x86-64/X86_64MacroAssembler.v3	/^	def ref: Addr;$/;"	d
refLoad	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def refLoad(nullity: Fact.set, vt: Type, i_old: SsaApplyOp, oobj: SsaDfEdge, nobj: SsaInstr, offset: int) -> SsaInstr {$/;"	m
refMapBuilder	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var refMapBuilder = MachRefMapBuilder.new();$/;"	d
refPatterns	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var refPatterns: RefPatterns;$/;"	d
refSize	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def refSize = data.addressSize;$/;"	d
refill	$VIRGIL/lib/util/DataWriter.v3	/^	var refill = DataWriter.growI2X;	\/\/ refill behavior$/;"	d
refill	$VIRGIL/lib/util/IO.v3	/^	private def refill(writer: DataWriter, size: int) -> DataWriter {$/;"	m
refmap	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def refmap(conv: MachCallConv) {$/;"	m
refmap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var refmap: int;$/;"	d
refs	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var refs: List<int>;$/;"	d
refs	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	var refs: List<(Addr, \/*posAddr:*\/int, \/*pos:*\/int)>;$/;"	d
reg	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var reg: X86_64Reg;$/;"	d
reg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var reg: byte;			\/\/ assigned physical register$/;"	d
regClass	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var regClass: RegClass;		\/\/ required register type$/;"	d
regClasses	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private var regClasses = mapRegClasses([$/;"	d
regClasses	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def regClasses: Array<byte>;		\/\/ registers in each class$/;"	d
regNames	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def regNames = Array<string>.new(allCount);$/;"	d
regSet	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def regSet: MachRegSet;$/;"	d
regSet	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def regSet: MachRegSet;		\/\/ associated register set$/;"	d
regSets	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def regSets = Array<Array<byte>>.new(allCount);$/;"	d
regSets	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def regSets: Array<Array<byte>>;	\/\/ registers in each set$/;"	d
regState	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def regState = RegState.new(regSet, codegen);$/;"	d
regState	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def regState = Array<VReg>.new(regSet.physRegs + 1);$/;"	d
regState	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def regState = RegState.new(regSet, codegen);$/;"	d
regState	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def regState = Array<int>.new(regSet.physRegs);			\/\/ indices into {allocated}$/;"	d
regUsage	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def regUsage = Array<int>.new(regSet.physRegs);$/;"	d
regindex	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def regindex = Array<int>.new(regSet.physRegs); \/\/ where each register occurs, if all, in regmoves$/;"	d
regindex	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def regindex = Array<int>.new(regSet.physRegs);		\/\/ where each register occurs, if all, in regmoves$/;"	d
registerTarget	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def registerTarget(target: Target) {$/;"	f
regmoves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def regmoves = Vector<(i8, VReg, int, List<byte>)>.new();   \/\/ (state, VReg, src, reg)$/;"	d
regmoves	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def regmoves = Vector<(i8, VReg, int, byte)>.new();	\/\/ (state, VReg, src, reg)$/;"	d
regs	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	var regs: MachRegSet;$/;"	d
regs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var regs: Array<Val>;		\/\/ register stack$/;"	d
regs	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	var regs: MachRegSet;$/;"	d
regset	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def regset: int;$/;"	d
release	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def release() {$/;"	m
release	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def release() {$/;"	m
releaseFileID	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	private def releaseFileID(fd: int) {$/;"	m
reload	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var reload: int;$/;"	d
reloadFrom	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var reloadFrom: VReg;			\/\/ var that this var is spilled from$/;"	d
reloadStart	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var reloadStart: int;$/;"	d
reloads	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def reloads = Vector<(VReg, int)>.new();        \/\/ (VReg, dst)$/;"	d
reloads	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def reloads = Vector<(VReg, int)>.new();		\/\/ (VReg, dst)$/;"	d
reloff	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var reloff: int;$/;"	d
remove	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def remove(l: List<(IcInterpreter, int) -> void>, f: (IcInterpreter, int) -> void) -> List<(IcInterpreter, int) -> void> {$/;"	m
remove	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def remove() {$/;"	m
remove	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def remove() {$/;"	m
remove	$VIRGIL/lib/util/Edge.v3	/^	private def remove(dest: T) {$/;"	m
removeEdge	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def removeEdge(edge: SsaCfEdge) {$/;"	m
removeFromWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def removeFromWorklist(worklist: Vector<int>, x: int) -> bool {$/;"	m
removeIndex	$VIRGIL/lib/util/Arrays.v3	/^	def removeIndex<T>(array: Array<T>, index: int) {$/;"	f
removeMove	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def removeMove(src: int, dest: int) { \/\/ XXX: dead$/;"	m
removePoint	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def removePoint(x: LsraPoint) -> LsraPoint {$/;"	m
removeProbeAfter	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def removeProbeAfter(f: (IcInterpreter, int) -> void) {$/;"	m
removeProbeBefore	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def removeProbeBefore(ip: int, f: (IcInterpreter, int) -> void) {$/;"	m
removeSecondToLast	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def removeSecondToLast(i: int) -> int {$/;"	m
removed	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var removed: bool = false;$/;"	d
render	$VIRGIL/aeneas/src/core/Operator.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/core/Value.v3	/^	def render(buffer: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def render(b: StringBuilder, ip: int, i: IcInstr) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def render(buffer: StringBuilder) -> StringBuilder;$/;"	m
render	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def render(buf: StringBuilder) -> StringBuilder;$/;"	m
render	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	def render(b: StringBuilder, regSet: MachRegSet) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def render(out: StringBuilder) -> StringBuilder { $/;"	m
render	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/ssa/SsaTracer.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/types/Type.v3	/^	private def render(buffer: StringBuilder) -> StringBuilder{$/;"	m
render	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def render(buf: StringBuilder, c: CfgInstr) -> int {$/;"	m
render	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/lib/util/BitMatrix.v3	/^	def render(buf: StringBuilder) -> StringBuilder {$/;"	m
render	$VIRGIL/lib/util/DataWriter.v3	/^	def render(baseAddr: int, startPos: int, size: int, buf: StringBuilder) {$/;"	m
render	$VIRGIL/lib/util/List.v3	/^	def render<T>(buf: StringBuilder, append: (T, StringBuilder) -> StringBuilder,$/;"	f
render	$VIRGIL/lib/util/Strings.v3	/^	def render(render: StringBuilder -> StringBuilder) -> string {$/;"	f
render0	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def render0(buf: StringBuilder) {$/;"	m
renderAddr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^def renderAddr(buf: StringBuilder, base: X86Reg, index: X86Reg, scale: byte, disp: int) -> StringBuilder {$/;"	f
renderBottom	$VIRGIL/aeneas/src/v3/V3.v3	/^def renderBottom(vtype: Type, buf: StringBuilder) {$/;"	f
renderByte	$VIRGIL/aeneas/src/v3/V3.v3	/^def renderByte(ch: byte, buf: StringBuilder) -> bool {$/;"	f
renderDecimal	$VIRGIL/lib/util/Ints.v3	/^	def renderDecimal(val: int, a: Array<byte>, pos: int) -> int {$/;"	f
renderDecimal	$VIRGIL/lib/util/Longs.v3	/^	def renderDecimal(i: i64, a: Array<byte>, pos: int) -> int {$/;"	f
renderDecimal	$VIRGIL/lib/util/Strings.v3	/^	def renderDecimal(buf: Array<byte>, pos: int, val: int) -> int {$/;"	f
renderEscaped	$VIRGIL/aeneas/src/util/Char.v3	/^	def renderEscaped(ch: byte, buf: StringBuilder) -> StringBuilder {$/;"	f
renderFacts	$VIRGIL/aeneas/src/ir/Facts.v3	/^	def renderFacts(buf: StringBuilder, facts: Fact.set) -> StringBuilder {$/;"	f
renderHex8	$VIRGIL/lib/util/Strings.v3	/^	def renderHex8(buf: Array<byte>, pos: int, val: int) -> int {$/;"	f
renderInstr	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def renderInstr(i: MachInstr, buf: StringBuilder) -> StringBuilder {$/;"	m
renderList	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def renderList(b: StringBuilder, a: Array<int>) {$/;"	m
renderLong	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def renderLong(buffer: StringBuilder) -> StringBuilder {$/;"	m
renderLong	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def renderLong(buf: StringBuilder) -> StringBuilder {$/;"	m
renderMrrsd	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def renderMrrsd(a: Array<Operand>, start: int) -> int {$/;"	m
renderOp	$VIRGIL/aeneas/src/core/Operator.v3	/^def renderOp(op: Operator, buf: StringBuilder) -> StringBuilder {$/;"	f
renderPosDecimal	$VIRGIL/lib/util/Ints.v3	/^	def renderPosDecimal(val: u32, a: Array<byte>, pos: int) -> int {$/;"	f
renderPosDecimal	$VIRGIL/lib/util/Longs.v3	/^	def renderPosDecimal(i: u64, a: Array<byte>, pos: int) -> int {$/;"	f
renderReg	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	def renderReg(reg: int) -> string { \/\/ XXX: add TerminalBuffer as param$/;"	m
renderResult	$VIRGIL/aeneas/src/v3/V3.v3	/^	def renderResult(result: Result, vtype: Type, buf: StringBuilder) -> StringBuilder {$/;"	f
renderRow	$VIRGIL/lib/util/BitMatrix.v3	/^	def renderRow(row: int, buf: StringBuilder) -> StringBuilder {$/;"	m
renderType	$VIRGIL/aeneas/src/types/Function.v3	/^	def renderType(buffer: StringBuilder, list: List<Type>) -> StringBuilder {$/;"	m
renderType	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def renderType(buffer: StringBuilder, list: List<Type>) -> StringBuilder {$/;"	m
renderType	$VIRGIL/aeneas/src/types/Type.v3	/^	def renderType(buffer: StringBuilder, typeParams: List<Type>) -> StringBuilder {$/;"	m
renderType	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def renderType(buffer: StringBuilder, list: List<Type>) -> StringBuilder {$/;"	m
renderUse	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def renderUse(use: int, buf: StringBuilder) {$/;"	m
renderVal	$VIRGIL/aeneas/src/v3/V3.v3	/^	def renderVal(val: Val) -> string {$/;"	f
renderWithSize	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def renderWithSize(buf: StringBuilder, size: int) -> StringBuilder {$/;"	m
repHints	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var repHints: List<VstRepHint>;$/;"	d
repType	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	def repType: IntType;$/;"	d
repeatCount	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var repeatCount = -1;$/;"	d
replace	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def replace(replacement: SsaInstr) {$/;"	m
replace	$VIRGIL/lib/util/Arrays.v3	/^	def replace<T>(array: Array<T>, index: int, val: T) -> Array<T> {$/;"	f
replaceEdge	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def replaceEdge(abEdge: SsaCfEdge, xbEdge: SsaCfEdge) {$/;"	m
replaceOp	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def replaceOp(i: SsaApplyOp, op: Operator) -> SsaInstr {$/;"	m
replaceWithGoto	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def replaceWithGoto(block: SsaBlock, end: SsaEnd, target: SsaCfEdge) {$/;"	m
replacements	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def replacements = Vector<Array<SsaInstr>>.new();$/;"	d
repne	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def repne() -> this { emitb(0xF2); } \/\/ prefix$/;"	m
repne	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def repne() -> this { emitb(0xF2); }$/;"	m
report	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/main/Error.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/ssa/SsaCoverage.v3	/^	def report() {$/;"	m
report	$VIRGIL/aeneas/src/ssa/SsaProfiler.v3	/^	def report() {$/;"	m
reportClass	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def reportClass(ic: IrClass) {$/;"	m
reportErrors	$VIRGIL/aeneas/src/core/Program.v3	/^	def reportErrors() -> bool {$/;"	m
reportInstrCount	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	def reportInstrCount(pm: IcMethodProf) {$/;"	m
reportNode	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def reportNode<F>(n: CctNode<F>, depth: int) {$/;"	m
reportSum	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def reportSum() {$/;"	m
repz	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def repz() -> this { emitb(0xF3); } \/\/ prefix$/;"	m
repz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def repz() -> this { emitb(0xF3); }$/;"	m
req1	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def req1(ch: byte) -> int {$/;"	m
req1	$VIRGIL/lib/util/TextReader.v3	/^	def req1(ch: byte) -> int {$/;"	m
reqKeyword	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def reqKeyword(p: ParserState, kw: string) -> FilePoint {$/;"	f
reqN	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def reqN(s: string) -> int {$/;"	m
reqN	$VIRGIL/lib/util/TextReader.v3	/^	def reqN(s: string) -> int {$/;"	m
reserved1	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var reserved1: int;$/;"	d
reserved2	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var reserved2: int;$/;"	d
reset	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def reset() {$/;"	m
reset	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def reset(len: int) {$/;"	m
reset	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def reset(graph: SsaGraph, blocks: SsaBlockOrder, frame: MachFrame) {$/;"	m
reset	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def reset(graph: SsaGraph) {$/;"	m
reset	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def reset(next: ArchInstr) {$/;"	m
reset	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def reset(codegen: SsaMachGen, order: SsaBlockOrder) {$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def reset() {$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def reset() {$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def reset(graph: SsaGraph) -> this;$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def reset() {$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def reset(g: SsaGraph) {$/;"	m
reset	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def reset(graph: SsaGraph, block: SsaBlock, prev: SsaLink) {$/;"	m
reset	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def reset() -> this {$/;"	m
reset	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	def reset() {$/;"	m
reset	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def reset(m: IrMethod, params: Array<SsaParam>, getVReg: SsaInstr -> VReg) {$/;"	m
reset	$VIRGIL/lib/util/DataReader.v3	/^	def reset(ndata: Range<byte>, npos: int, nlimit: int) -> this {$/;"	m
reset	$VIRGIL/lib/util/DataWriter.v3	/^	def reset(ndata: Array<byte>, npos: int, nmax: int) -> this {$/;"	m
reset	$VIRGIL/lib/util/StringBuilder.v3	/^	def reset() -> this {$/;"	m
resize	$VIRGIL/lib/util/Stack.v3	/^	def resize(ntop: int) {$/;"	m
resize	$VIRGIL/lib/util/StringBuilder.v3	/^	def resize(nlength: int) -> this {$/;"	m
resize	$VIRGIL/lib/util/Vector.v3	/^	def resize(nlength: int) -> this {$/;"	m
resolveClassMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def resolveClassMember(expr: VarExpr, classType: ClassType, name: string) -> ResolvedMember {$/;"	m
resolveEnumMember	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def resolveEnumMember(expr: VarExpr, enumType: EnumType, name: string) -> ResolvedMember {$/;"	m
resolveMethodImpl	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def resolveMethodImpl(classType: Type, irSpec: IrSpec) -> IrSpec {$/;"	m
resolveMethodImpl	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def resolveMethodImpl(rc: RaClass, rm: RaMethod) -> RaMethod {$/;"	m
resolveOp1	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def resolveOp1(dest: int, a: int) -> X86Rm {$/;"	m
resolveRefType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def resolveRefType(typeCon: V3Ref_TypeCon, tref: NamedTypeRef) -> Type {$/;"	m
resolveSuperClass	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def resolveSuperClass(decl: VstClass) {$/;"	m
resolveType	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def resolveType(tref: TypeRef) -> Type {$/;"	m
resolveType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def resolveType(tref: TypeRef, typeEnv: TypeEnv) -> Type {$/;"	m
resolveVariantDefaultMethodImpl	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def resolveVariantDefaultMethodImpl(irSpec: IrSpec) -> IrSpec {$/;"	m
restore	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def restore() {$/;"	m
results	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def results: Array<WasmType>;$/;"	d
ret	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def ret(kind: JvmKind) {$/;"	m
ret	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ret() -> this { emitb(0xC3); }$/;"	m
ret	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ret() { emitb(0xC3); }$/;"	m
retIp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var retIp: int;$/;"	d
retLocs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def retLocs: Array<int>;	\/\/ locations of return value(s)$/;"	d
retReg	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var retReg: int;$/;"	d
retRegs	$VIRGIL/aeneas/src/arm/ArmRegSet.v3	/^	def retRegs: Array<int> = [S.R0, S.R1, S.R2, S.R3];$/;"	d
retRegs	$VIRGIL/aeneas/src/x86/X86RegSet.v3	/^	def retRegs = [R.EAX, R.EDX, R.ECX, R.ESI];$/;"	d
retRp	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var retRp: int;$/;"	d
retVal	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var retVal: SsaInstr;$/;"	d
retVal	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var retVal: Val;$/;"	d
rettype	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var rettype: Type;$/;"	d
rettype	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def rettype: ReturnType;$/;"	d
returnThis	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def returnThis = ReturnType.This.?(rettype);$/;"	d
returnType	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var returnType: Type;$/;"	d
returnType	$VIRGIL/aeneas/src/types/Function.v3	/^	def returnType() -> Type {$/;"	m
returnTypes	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def returnTypes: Array<Type>;	\/\/ return types$/;"	d
returnTypes	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def returnTypes: Array<Type>;$/;"	d
returnTypes	$VIRGIL/aeneas/src/types/Function.v3	/^	def returnTypes: Array<Type>;$/;"	d
returns	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	var returns: List<(SsaCfEdge, SsaInstr)>;$/;"	d
retvoid	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def retvoid() {$/;"	m
reuse	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def reuse(group: int) { this.group = group; index = 0; }$/;"	m
reverse	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def reverse(dir: UnificationDir) -> UnificationDir {$/;"	f
reverse	$VIRGIL/lib/util/List.v3	/^	def reverse<T>(rev: List<T>) -> List<T> {$/;"	f
reverse	$VIRGIL/lib/util/Ranges.v3	/^	def reverse<T>(r: Range<T>) {$/;"	f
reverse	$VIRGIL/lib/util/Vector.v3	/^	def reverse() -> this {$/;"	m
rex_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def rex_m(a: X86_64Addr, b: byte) -> byte {$/;"	m
rex_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def rex_r(a: X86_64Reg, b: byte) -> byte {$/;"	m
ri_exit	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var ri_exit = -1;$/;"	d
ri_gc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var ri_gc: IrMethod;$/;"	d
ri_gc	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var ri_gc = -1;$/;"	d
ri_init	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var ri_init = -1;$/;"	d
ri_signal	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var ri_signal: IrMethod;$/;"	d
ri_signal	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var ri_signal = -1;$/;"	d
rip	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	var rip: int;$/;"	d
rjustify	$VIRGIL/lib/util/StringBuilder.v3	/^	def rjustify(ch: byte, nchars: int, len: int) -> this {$/;"	m
rm_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def rm_i(a: X86Rm, i: int) { \/\/ register\/memory, immediate$/;"	m
rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def rm_r(a: X86Rm, b: X86Reg) { \/\/ register\/memory, register$/;"	m
rol_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rol_m_cl(a: X86_64Addr) -> this { shx_m_cl(a, OP_REX, 8); }$/;"	m
rol_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rol_r_cl(a: X86_64Gpr) -> this { shx_r_cl(a, OP_REX, 8); }$/;"	m
rol_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def rol_r_i(a: X86_64Gpr, imm: u6) -> this { shx_r_i(a, OP_REX, imm, 8); }$/;"	m
root	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def root(m: IrMethod) -> IrMethod {$/;"	m
root	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def root = SpecSigNode.new();$/;"	d
root	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var root: VstMethod;$/;"	d
rootFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	var rootFile: DwarfFile;$/;"	d
rootMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var rootMap: BitMatrix;$/;"	d
rootNode	$VIRGIL/aeneas/src/main/Profiler.v3	/^	def rootNode = CctNode<F>.new(null, null);	\/\/ calling context tree root$/;"	d
roots	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def roots = Vector<IrRoot>.new();$/;"	d
ror_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ror_m_cl(a: X86_64Addr) -> this { shx_m_cl(a, OP_REX, 9); }$/;"	m
ror_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ror_r_cl(a: X86_64Gpr) -> this { shx_r_cl(a, OP_REX, 9); }$/;"	m
ror_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ror_r_i(a: X86_64Gpr, imm: u6) -> this { shx_r_i(a, OP_REX, imm, 9); }$/;"	m
rori	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def rori(rd: ArmReg, rm: ArmReg, imm: u5) { mov(rd, ArmOperand.RegRorImm(rm, imm)); }$/;"	m
rorr	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def rorr(rd: ArmReg, rm: ArmReg, sh: ArmReg) { mov(rd, ArmOperand.RegRorReg(rm, sh)); }$/;"	m
round	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def round(width: int) -> this {$/;"	m
roundOff	$VIRGIL/aeneas/src/types/Float.v3	/^	def roundOff(val: u64, bits: int) -> u1 {$/;"	f
roundg	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def roundg(width: int, guard: bool) -> this {$/;"	m
roundpd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundpd_s_m(a: X86_64Xmmr, b: X86_64Addr, c: X86_64Rounding) -> this {$/;"	m
roundpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr, c: X86_64Rounding) -> this {$/;"	m
roundps_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundps_s_m(a: X86_64Xmmr, b: X86_64Addr, c: X86_64Rounding) -> this {$/;"	m
roundps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundps_s_s(a: X86_64Xmmr, b: X86_64Xmmr, c: X86_64Rounding) -> this {$/;"	m
roundsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def roundsd(a: SSEReg, b: SSERm, c: RoundingMode) {$/;"	m
roundsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundsd_s_m(a: X86_64Xmmr, b: X86_64Addr, c: X86_64Rounding) -> this {$/;"	m
roundsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr, c: X86_64Rounding) -> this {$/;"	m
roundss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def roundss(a: SSEReg, b: SSERm, c: RoundingMode) {$/;"	m
roundss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundss_s_m(a: X86_64Xmmr, b: X86_64Addr, c: X86_64Rounding) -> this {$/;"	m
roundss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def roundss_s_s(a: X86_64Xmmr, b: X86_64Xmmr, c: X86_64Rounding) -> this {$/;"	m
row	$VIRGIL/lib/util/BitMatrix.v3	/^	def row(index: int) -> BitMatrixRow {$/;"	m
rowInts	$VIRGIL/lib/util/BitMatrix.v3	/^	def rowInts(index: int) -> Range<int> {$/;"	m
rows	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def rows = Vector<(K, D)>.new();$/;"	d
rtOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def rtOpt = OptionGroup.new("RUNTIME", options);$/;"	d
rtgc	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def rtgc = rt.gc;$/;"	d
rtsrc	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var rtsrc = if(mach.runtime != null, mach.runtime.src);$/;"	d
rtsrc	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def rtsrc = rt.src;$/;"	d
run	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def run() {$/;"	m
run	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def run() {$/;"	m
run	$VIRGIL/lib/term/Animator.v3	/^	def run() {$/;"	m
runInitMethod	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def runInitMethod(meth: IrMethod, invoker: (Closure, Array<Val>) -> Result) -> bool {$/;"	m
runInsertion	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def runInsertion<T>(f: T -> void, arg: T, next: ArchInstr) {$/;"	m
runMain	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def runMain() -> Result {$/;"	m
runOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def runOpt = OptionGroup.new("RUN", options);$/;"	d
running	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var running: bool;$/;"	d
runtime	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var runtime: MachRuntime;$/;"	d
rval	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def rval: Record;$/;"	d
sameGlobal	$VIRGIL/aeneas/src/ssa/Gvn.v3	/^	def sameGlobal(a: SsaInstr, b: SsaInstr) -> bool {$/;"	m
sanityCheck	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def sanityCheck() {$/;"	m
sar_cl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sar_cl(a: X86Rm) { emitb_rm(0xD3, a, 7); } \/\/ arithmetic shift right by value in CL$/;"	m
sar_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sar_i(a: X86Rm, imm: int) { \/\/ arithmetic shift right by immediate$/;"	m
sar_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sar_m_cl(a: X86_64Addr) -> this { shx_m_cl(a, OP_REX, 7); }$/;"	m
sar_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sar_m_i(a: X86_64Addr, imm: u6) -> this { shx_m_i(a, OP_REX, imm, 7); }$/;"	m
sar_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sar_r_cl(a: X86_64Gpr) -> this { shx_r_cl(a, OP_REX, 7); }$/;"	m
sar_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sar_r_i(a: X86_64Gpr, imm: u6) -> this { shx_r_i(a, OP_REX, imm, 7); }$/;"	m
saveRestoreLps	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def saveRestoreLps() {$/;"	m
saveRow	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var saveRow: BitMatrixRow;$/;"	d
saves	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def saves = Vector<(VReg, int, int)>.new();     \/\/ (VReg, src, dst)$/;"	d
saves	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def saves = Vector<(VReg, int, int)>.new();		\/\/ (VReg, src, dst)$/;"	d
sbb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var sbb: X86Op2;$/;"	d
sbb_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sbb_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 3); }$/;"	m
sbb_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sbb_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 3); }$/;"	m
sbb_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sbb_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 3); }$/;"	m
sbb_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sbb_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 3); }$/;"	m
sbb_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sbb_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 3); }$/;"	m
scalar	$VIRGIL/aeneas/src/types/IntRepresented.v3	/^	def scalar: Scalar;$/;"	d
scale	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var scale = -1;$/;"	d
scasb	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def scasb() -> this { emitb(0xAE); }$/;"	m
scasb	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def scasb() { emitb(0xAE); }$/;"	m
scopeStart	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	var scopeStart: int;$/;"	d
score	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def score() -> int {$/;"	m
scorePosition	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	private def scorePosition(numUnassigned: int, numZeros: int, numOnes: int) -> int {$/;"	m
scratch	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def scratch: Array<byte>;		\/\/ scratch registers by register class$/;"	d
scratchReg	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def scratchReg = Regs.SCRATCH;$/;"	d
script	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^        def script: bool;$/;"	d
scrollDown	$VIRGIL/lib/term/Vt100.v3	/^	def scrollDown = esc("D");$/;"	d
scrollUp	$VIRGIL/lib/term/Vt100.v3	/^	def scrollUp = esc("M");$/;"	d
sdiv	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def sdiv(rd: ArmReg, rs: ArmReg, rm: ArmReg) { emit_rrr(0x0710f010, rd, rm, rs); }$/;"	m
sdivd_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def sdivd_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
sdivq_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def sdivq_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
sectList	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var sectList: List<MachO_Section>;$/;"	d
sections	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def sections: ElfSections;$/;"	d
seed	$VIRGIL/lib/util/Random.v3	/^	var seed = 121013;$/;"	d
seen	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def seen = newMap<bool>();$/;"	d
selectInstructions	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def selectInstructions(block: SsaBlock, i: SsaLink) {$/;"	m
selectInstructionsForBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def selectInstructionsForBlock(block: SsaBlock) {$/;"	m
selectInstructionsForCfgInstr	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def selectInstructionsForCfgInstr(c: CfgInstr) {$/;"	m
selectInstructionsForGraph	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def selectInstructionsForGraph() {$/;"	m
selectLineDraw	$VIRGIL/lib/term/Vt100.v3	/^	def selectLineDraw = lit("\x1b)0");$/;"	d
selectSpill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def selectSpill() {$/;"	m
selectStack	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def selectStack = Vector<int>.new();$/;"	d
selectWidth	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def selectWidth(i: SsaApplyOp, op: int) -> int {$/;"	m
send	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def send(msg: Array<byte>) -> NetResult<void> {$/;"	m
send	$VIRGIL/lib/util/DataWriter.v3	/^	def send<R>(f: Range<byte> -> R) -> R {$/;"	m
send	$VIRGIL/lib/util/StringBuilder.v3	/^	def send<R>(f: Range<byte> -> R) -> R {$/;"	m
send	$VIRGIL/lib/util/Vector.v3	/^	def send<R>(f: Range<T> -> R) -> R {$/;"	m
sendto	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def sendto(sockfd: int, msg: Array<byte>, sockAddr: Array<byte>) -> NetResult<void> {$/;"	f
sendtoAddr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	private def sendtoAddr(msg: Array<byte>) -> NetResult<void> {$/;"	m
set	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def set(name: string, a: Array<byte>) -> byte {$/;"	f
set	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var set: SpecSet;$/;"	d
set	$VIRGIL/aeneas/src/main/Error.v3	/^	def set(error: string, description: string) {$/;"	m
set	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def set(on: bool) {$/;"	m
set	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def set(binop: Operator) -> this {$/;"	m
set	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def set(name: string, a: Array<byte>) -> byte {$/;"	f
set	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	private def set(a: X86Rm, sop: int) { emitbb_rm(0x0f, sop, a, 0); }$/;"	m
set	$VIRGIL/lib/util/BitMatrix.v3	/^	def set(row: int, col: int) -> bool {$/;"	m
set	$VIRGIL/lib/util/Vector.v3	/^	def set(index: int, element: T) -> this {$/;"	m
set0	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def set0(i: SsaInstr) {$/;"	m
set1	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def set1(i: SsaInstr, j: SsaInstr) {$/;"	m
setAbs	$VIRGIL/aeneas/src/mach/CiRuntime.v3	/^	def setAbs(rt: MachRuntime, addr: int) {$/;"	m
setAbsolute	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def setAbsolute(a: int) -> this {$/;"	m
setAddr	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def setAddr(ptr: CiRuntime_Address, addr: int) {$/;"	m
setArgs	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def setArgs(prog: Program, args: Array<string>) {$/;"	f
setArgs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def setArgs(params: Range<SsaParam>, args: Range<Val>) {$/;"	m
setArgs0	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def setArgs0(params: Range<SsaParam>, args: Range<Val>) {$/;"	m
setAssigned	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def setAssigned(ssa: VstSsaVar) {$/;"	m
setAssignment	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def setAssignment(usepos: int, loc: int) {$/;"	m
setBackground	$VIRGIL/lib/term/Vt100.v3	/^	def setBackground(color: int) {$/;"	f
setBound	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def setBound(bound: bool) {$/;"	m
setComponentRecord	$VIRGIL/aeneas/src/core/Program.v3	/^	def setComponentRecord(comp: VstComponent, record: Record) {$/;"	m
setConnected	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def setConnected(connected: bool) {$/;"	m
setDefStackLength	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def setDefStackLength(v: int) {$/;"	m
setDirty	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def setDirty(length: int) {$/;"	m
setEOFError	$VIRGIL/lib/util/DataReader.v3	/^	def setEOFError(abspos: int, size: int, msg: string) {$/;"	m
setEnv	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def setEnv(env: VstSsaEnv) {$/;"	m
setFPS	$VIRGIL/lib/term/Animator.v3	/^	def setFPS(f: u32) {$/;"	m
setFact	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def setFact(set: Fact.set) { facts = facts | set; }$/;"	m
setFact	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def setFact(fact: RaFact.set) -> bool {$/;"	m
setFact	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def setFact(set: Fact.set) -> this { facts |= set; }$/;"	m
setFactIf	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def setFactIf(cond: Fact.set, set: Fact.set) -> this {$/;"	m
setField	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def setField(op: SsaApplyOp, rf: RaField) {$/;"	m
setFirstError	$VIRGIL/lib/util/DataReader.v3	/^	def setFirstError(abspos: int, msg: string) {$/;"	m
setFirstError	$VIRGIL/lib/util/TextReader.v3	/^	def setFirstError(eline: int, ecol: int, msg: string) {$/;"	m
setFlag	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	def setFlag(val: bool, flag: int) {$/;"	m
setFlag	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def setFlag(t: Token, val: bool) {$/;"	m
setForeground	$VIRGIL/lib/term/Vt100.v3	/^	def setForeground(color: int) {$/;"	f
setId	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def setId(i: SsaInstr) {$/;"	m
setIndex	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def setIndex(index: int, m: IrMember) {$/;"	m
setInitialParam	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def setInitialParam(p: ParamDecl, env: VstSsaEnv) {$/;"	m
setInput	$VIRGIL/aeneas/src/core/Program.v3	/^	def setInput(fname: string, input: Array<byte>) {$/;"	m
setInputs	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def setInputs(a: Array<SsaInstr>) {$/;"	m
setIntVal	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def setIntVal(ival: int) -> Val {$/;"	m
setIrClass	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def setIrClass(ctype: Type, ic: IrClass) {$/;"	m
setIrMethod	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	private def setIrMethod(ic: IrClass, i: int, m: IrMethod) -> IrMethod {$/;"	m
setIrMethod	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def setIrMethod(index: int, m: IrMethod) {$/;"	m
setListHead	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def setListHead(dest: SpecMethod, e: Edge<SpecMethod>) { dest.useList = SpecEdge.!(e); }$/;"	m
setListHead	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def setListHead(dest: SsaInstr, e: Edge<SsaInstr>) { dest.useList = SsaDfEdge.!(e); }$/;"	m
setListHead	$VIRGIL/lib/util/Edge.v3	/^	def setListHead(dest: T, e: Edge<T>);$/;"	m
setListening	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def setListening(listening: bool) {$/;"	m
setLocList	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def setLocList(index: int) {$/;"	m
setLocalPort	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def setLocalPort(local: int) {$/;"	m
setLongVal	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	def setLongVal(lval: long) -> Val {$/;"	m
setLoop	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def setLoop(a: SsaBlock, loop: SsaLoopInfo) {$/;"	m
setMark	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	def setMark(a: SsaBlock) -> bool {$/;"	m
setMark	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def setMark(i: SsaLink, mark: u31);$/;"	m
setMtable	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def setMtable(rc: RaClass, rv: RaVirtual) {$/;"	m
setN	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	def setN(i: SsaInstr, r: Range<SsaInstr>) {$/;"	m
setNormIndex	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def setNormIndex(i: int) {$/;"	m
setNormalBackground	$VIRGIL/lib/term/Vt100.v3	/^	def setNormalBackground = esc("[0m");$/;"	d
setNormalForeground	$VIRGIL/lib/term/Vt100.v3	/^	def setNormalForeground = esc("[1m");$/;"	d
setOpen	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def setOpen(open: bool) {$/;"	m
setOption	$VIRGIL/lib/util/Option.v3	/^	def setOption(name: string, val: string) {$/;"	m
setPos	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def setPos(newPos: int, newLine: int, newCol: int) -> int {$/;"	m
setPtr	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	def setPtr(w: MachDataWriter, ptr: CiRuntime_Address, addr: int) {$/;"	m
setRange	$VIRGIL/aeneas/src/util/Char.v3	/^	def setRange(p: byte, low: int, high: int) {$/;"	f
setRefMap	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	def setRefMap(index: int) {$/;"	m
setRefMap	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def setRefMap(vnum: int, builder: MachRefMapBuilder) {$/;"	m
setRefMapSlot	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def setRefMapSlot(vnum: int, builder: MachRefMapBuilder) {$/;"	m
setReg	$VIRGIL/aeneas/src/ssa/SsaDeconstructor.v3	/^	def setReg(i: SsaInstr, reg: u31) {$/;"	m
setRow	$VIRGIL/lib/util/BitMatrix.v3	/^	def setRow(row: int) {$/;"	m
setSectionInfo	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def setSectionInfo(tag: int, start: int, w: DataWriter) {$/;"	m
setSignatureLimits	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def setSignatureLimits(maxp: int, maxr: int) {$/;"	m
setSingleLoc	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def setSingleLoc(reg: X86_64Reg, location: int) {$/;"	m
setStartAddr	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def setStartAddr(startAddr: int) -> int {$/;"	m
setTrace	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def setTrace(on: bool) {$/;"	m
setType	$VIRGIL/aeneas/src/types/Type.v3	/^	def setType(t: Type) {$/;"	m
setType	$VIRGIL/aeneas/src/v3/V3Enum.v3	/^	var setType: EnumSetType;$/;"	d
setUnmatched	$VIRGIL/lib/util/Option.v3	/^	var setUnmatched: (string, string) -> void;$/;"	d
setUnmatchedOption	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def setUnmatchedOption(str: string, val: string) {$/;"	f
setVal	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	private def setVal(i: SsaInstr, v: Val) {$/;"	m
setVarRefSlot	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def setVarRefSlot(vreg: VReg, t: Type) {$/;"	m
setVariantFields	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def setVariantFields(rc: RaClass, caseIdx: int, soln: VariantSolution) {$/;"	m
setWrittenInLoop	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def setWrittenInLoop(loopIndex: int) {$/;"	m
set_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def set_m(cond: X86_64Cond, a: X86_64Addr) -> this {$/;"	m
set_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def set_r(cond: X86_64Cond, a: X86_64Gpr) -> this {$/;"	m
seta	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def seta (a: X86Rm) { set(a, 0x97); }$/;"	m
setc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setc (a: X86Rm) { set(a, 0x92); }$/;"	m
setdq	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def setdq(d: X86_64Assembler, q: X86_64Assembler) {$/;"	m
setg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setg (a: X86Rm) { set(a, 0x9F); }$/;"	m
setge	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setge(a: X86Rm) { set(a, 0x9D); }$/;"	m
setl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setl (a: X86Rm) { set(a, 0x9C); }$/;"	m
setle	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setle(a: X86Rm) { set(a, 0x9E); }$/;"	m
setna	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setna(a: X86Rm) { set(a, 0x96); }$/;"	m
setnc	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setnc(a: X86Rm) { set(a, 0x93); }$/;"	m
setno	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setno(a: X86Rm) { set(a, 0x91); }$/;"	m
setnp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setnp(a: X86Rm) { set(a, 0x9B); }$/;"	m
setns	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setns(a: X86Rm) { set(a, 0x99); }$/;"	m
setnz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setnz(a: X86Rm) { set(a, 0x95); }$/;"	m
seto	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def seto (a: X86Rm) { set(a, 0x90); }$/;"	m
setp	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setp (a: X86Rm) { set(a, 0x9A); }$/;"	m
sets	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sets (a: X86Rm) { set(a, 0x98); }$/;"	m
setx	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setx(cond: X86Cond, a: X86Rm) { set(a, 0x90 + cond.index); }$/;"	m
setz	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def setz (a: X86Rm) { set(a, 0x94); }$/;"	m
sfrCount	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def sfrCount = 0; \/\/ TODO SIMD and floating point registers$/;"	d
sfrs	$VIRGIL/aeneas/src/arm64/Arm64RegSet.v3	/^	private def sfrs = Array<byte>.new(sfrCount); \/\/ TODO SIMD + floating point registers$/;"	d
sh_addr	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_addr: long;$/;"	d
sh_addralign	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_addralign: long;$/;"	d
sh_cl	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def sh_cl(asm: X86MacroAssembler, dest: X86Rm) {$/;"	m
sh_entsize	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_entsize: long;$/;"	d
sh_flags	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_flags: int;$/;"	d
sh_i	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def sh_i(asm: X86MacroAssembler, dest: X86Rm, imm: int) {$/;"	m
sh_info	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_info: int;$/;"	d
sh_link	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_link: int;$/;"	d
sh_name	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_name: int;$/;"	d
sh_offset	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_offset: long;$/;"	d
sh_size	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_size: long;$/;"	d
sh_type	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var sh_type: int;$/;"	d
shadowStackAllocNext	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var shadowStackAllocNext: ArchInstr;$/;"	d
shadowStackSize	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var shadowStackSize: u32;$/;"	d
shadowVarMap	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	def shadowVarMap = Vector<int>.new();$/;"	d
shadow_sp	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var shadow_sp: VReg;$/;"	d
sharedOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def sharedOpt = OptionGroup.new("SHARED", options);$/;"	d
sheaders	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def sheaders = Vector<ElfSectionHeader>.new();$/;"	d
shift	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def shift<T>(left: bool, inputs: Array<T>, n: int, extend: T) {$/;"	m
shift	$VIRGIL/aeneas/src/types/Int.v3	/^	def shift(infix: V3Infix, opcode: Opcode) -> Operator {$/;"	m
shift	$VIRGIL/aeneas/src/util/Alignment.v3	/^	def shift = u5.view(Ints.log(u32.view(size)));$/;"	d
shiftLeft	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def shiftLeft<T>(inputs: Array<T>, n: int, extend: T) {$/;"	m
shiftRight	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def shiftRight<T>(inputs: Array<T>, n: int, extend: T) {$/;"	m
shiftcheck	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def shiftcheck(i: SsaApplyOp, y: SsaInstr) -> SsaInstr {$/;"	m
shifter	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def shifter(op: ArmOperand) -> u32 {$/;"	m
shl_cl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shl_cl(a: X86Rm) { emitb_rm(0xD3, a, 4); } \/\/ shift left by value in CL$/;"	m
shl_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shl_i(a: X86Rm, imm: int) { \/\/ shift left by immediate$/;"	m
shl_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shl_m_cl(a: X86_64Addr) -> this { shx_m_cl(a, OP_REX, 4); }$/;"	m
shl_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shl_m_i(a: X86_64Addr, imm: u6) -> this { shx_m_i(a, OP_REX, imm, 4); }$/;"	m
shl_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shl_r_cl(a: X86_64Gpr) -> this { shx_r_cl(a, OP_REX, 4); }$/;"	m
shl_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shl_r_i(a: X86_64Gpr, imm: u6) -> this { shx_r_i(a, OP_REX, imm, 4); }$/;"	m
shld_cl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shld_cl(a: X86Rm, b: X86Reg) { emitbb_rm(0x0F, 0xA5, a, b.index); } \/\/ shift left by value in CL and shift in bits from b$/;"	m
shorten	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	var shorten = true;$/;"	d
shouldInline	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def shouldInline(inlinee: IrSpec) -> bool {$/;"	m
shouldPrintMach	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def shouldPrintMach() -> bool {$/;"	m
shouldPrintOpt	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def shouldPrintOpt() -> bool {$/;"	m
shouldPrintSsa	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def shouldPrintSsa() -> bool {$/;"	m
shouldPrintSsaStats	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def shouldPrintSsaStats() -> bool {$/;"	m
shouldUseGlobalRegAlloc	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def shouldUseGlobalRegAlloc() -> bool {$/;"	m
showCursor	$VIRGIL/lib/term/Vt100.v3	/^	def showCursor = esc("[?25h");$/;"	d
shrOp	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def shrOp = word.opShr();$/;"	d
shr_cl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shr_cl(a: X86Rm) { \/\/ shift right by value in CL$/;"	m
shr_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shr_i(a: X86Rm, imm: int) { \/\/ shift right by immediate$/;"	m
shr_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shr_m_cl(a: X86_64Addr) -> this { shx_m_cl(a, OP_REX, 5); }$/;"	m
shr_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shr_m_i(a: X86_64Addr, imm: u6) -> this { shx_m_i(a, OP_REX, imm, 5); }$/;"	m
shr_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shr_r_cl(a: X86_64Gpr) -> this { shx_r_cl(a, OP_REX, 5); }$/;"	m
shr_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shr_r_i(a: X86_64Gpr, imm: u6) -> this { shx_r_i(a, OP_REX, imm, 5); }$/;"	m
shrd_cl	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shrd_cl(a: X86Rm, b: X86Reg) { \/\/ shift right by value in CL and shift in bits from b$/;"	m
shrd_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def shrd_i(a: X86Rm, b: X86Reg, imm: byte) { \/\/ shift right by immediate$/;"	m
shufps_s_s_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def shufps_s_s_i(a: X86_64Xmmr, b: X86_64Xmmr, imm: u8) -> this {$/;"	m
shx_m_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def shx_m_cl(a: X86_64Addr, rex: byte, op: byte) -> this {$/;"	m
shx_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def shx_m_i(a: X86_64Addr, rex: byte, imm: u6, op: byte) -> this {$/;"	m
shx_r_cl	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def shx_r_cl(a: X86_64Gpr, rex: byte, op: byte) -> this {$/;"	m
shx_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	private def shx_r_i(a: X86_64Gpr, rex: byte, imm: u6, op: byte) -> this {$/;"	m
sig	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def sig: Signature;		\/\/ parameter and return type of method$/;"	d
sig	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def sig() -> Signature {$/;"	m
sig	$VIRGIL/aeneas/src/types/Function.v3	/^	def sig(paramType: Type, returnType: Type) -> Signature {$/;"	f
sigIndex_entryStub	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var sigIndex_entryStub = -1;$/;"	d
sigIndex_i_i	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var sigIndex_i_i = -1;$/;"	d
sig_z_z	$VIRGIL/aeneas/src/core/Operator.v3	/^	def sig_z_z = Signature.new(null, arr_z, arr_z);$/;"	d
sig_zz_z	$VIRGIL/aeneas/src/core/Operator.v3	/^	def sig_zz_z = Signature.new(null, arr_zz, arr_z);$/;"	d
siga	$VIRGIL/aeneas/src/types/Function.v3	/^	def siga(paramTypes: Array<Type>, returnType: Type) -> Signature {$/;"	f
sigcache	$VIRGIL/aeneas/src/types/Function.v3	/^	private var sigcache: Signature;$/;"	d
signalStub	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var signalStub: Addr;$/;"	d
signed	$VIRGIL/aeneas/src/types/Int.v3	/^	def signed: bool; \/\/ true if signed, false if unsigned$/;"	d
signedCmp	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def signedCmp(i: SsaInstr, signed: X86Cond, unsigned: X86Cond) -> X86Cond {$/;"	m
simple	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def simple(name: string, indent: int) {$/;"	m
simplify	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def simplify() {$/;"	m
simplifyPhis	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def simplifyPhis(block: SsaBlock) {$/;"	m
simplifyWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def simplifyWorklist = Vector<int>.new();$/;"	d
singleBuckets	$VIRGIL/aeneas/src/types/Type.v3	/^	var singleBuckets = Array<Type>.new(11);$/;"	d
singleMark	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	var singleMark: int;$/;"	d
singleType	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def singleType<T>(name: string, kind: Kind, alloc: TypeCon -> T) -> T {$/;"	f
singleton	$VIRGIL/aeneas/src/types/Type.v3	/^	var singleton: Type;		\/\/ type with 0 nested types$/;"	d
size	$VIRGIL/aeneas/src/exe/ELF.v3	/^	def size() -> long {$/;"	m
size	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var size: int;$/;"	d
size	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def size() -> byte { return end - start; }$/;"	m
size	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def size = if(sub == null, 1, sub.length);$/;"	d
size	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var size: int;$/;"	d
size	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def size() -> int {$/;"	m
size	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var size: int;$/;"	d
size	$VIRGIL/aeneas/src/mach/Memory.v3	/^	var size: int;$/;"	d
size	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var size: int;$/;"	d
size	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def size = byte.view((width + 7u) >>> 3);$/;"	d
size	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def size() -> int { return succs.length; }$/;"	m
size	$VIRGIL/aeneas/src/types/Int.v3	/^	def size = byte.view((7 + width) >> 3);$/;"	d
size	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def size: Literal;$/;"	d
size	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def size(is64: bool) -> int {$/;"	m
size	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def size(is64: bool) -> int {$/;"	m
sizeLoc	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	var sizeLoc: int;$/;"	d
sizeLoc	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	var sizeLoc: int;$/;"	d
sizeOf	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def sizeOf(t: Type) -> int {$/;"	m
sizeOfRegClass	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def sizeOfRegClass(rcl: RegClass) -> int {$/;"	m
sizeReg	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var sizeReg: Arm64Gpr;$/;"	d
sizeReg	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var sizeReg: X86_64Gpr;$/;"	d
sizepos	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var sizepos = -1;$/;"	d
skip	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def skip(p: ParserState) {$/;"	m
skipFunc	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def skipFunc: ParserState -> void;	\/\/ function to skip whitespace$/;"	d
skipN	$VIRGIL/lib/util/DataReader.v3	/^	def skipN(length: int) {$/;"	m
skipN	$VIRGIL/lib/util/DataWriter.v3	/^	def skipN(length: int) -> this {$/;"	m
skipNone	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def skipNone(p: ParserState) {$/;"	f
skipPage	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	def skipPage() {$/;"	m
skipSpacesAndTabs	$VIRGIL/lib/util/TextReader.v3	/^	def skipSpacesAndTabs() {$/;"	m
skipToEndOfLine	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def skipToEndOfLine(p: ParserState) {$/;"	f
skipToNextLine	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def skipToNextLine(p: ParserState) {$/;"	f
skipToNextToken	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def skipToNextToken(p: ParserState) {$/;"	f
skipWhitespace	$VIRGIL/lib/util/TextReader.v3	/^	def skipWhitespace() {$/;"	m
skipWs	$VIRGIL/lib/util/TextReader.v3	/^	var skipWs  = TextReader.skipWhitespace;\/\/ whitespace callback$/;"	d
skip_leb	$VIRGIL/lib/util/DataReader.v3	/^	def skip_leb() {$/;"	m
skip_leb32	$VIRGIL/lib/util/DataWriter.v3	/^	def skip_leb32() -> int {$/;"	m
skip_underscore	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var skip_underscore: bool = true;$/;"	d
sleb32_len	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def sleb32_len(data: int) -> u32 {$/;"	m
sll	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sll(rd: MipsReg, rs: MipsReg, imm: u5)      { w.put_b32be(0x0 | int.view(rs.tag) << 16 | int.view(rd.tag) << 11 | imm << 6); }$/;"	m
sllv	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sllv(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x00000004, rd, rs, rt); }$/;"	m
slotOf	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def slotOf(v: VReg) -> int {$/;"	m
slots	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def slots() -> int {$/;"	m
slt	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def slt(rd: MipsReg, rs: MipsReg, rt: MipsReg)  { emit_r3(0x0000002a, rd, rs, rt); }$/;"	m
slti	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def slti(rd: MipsReg, rs: MipsReg, imm: i16)    { emit_r2i(0x28000000, rd, rs, u16.!(imm)); }$/;"	m
sltiu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sltiu(rd: MipsReg, rs: MipsReg, imm: u16)   { emit_r2i(0x2c000000, rd, rs, u16.!(imm)); }$/;"	m
sltu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sltu(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x0000002b, rd, rs, rt); }$/;"	m
sockAddr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	private var sockAddr: Array<byte>;$/;"	d
socket	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def socket(family: int, socketType: int, protocol: int) -> NetResult<int> {$/;"	f
socketType	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def socketType: SocketType;$/;"	d
soleEdge	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def soleEdge(e: SsaDfEdge) -> bool {$/;"	m
solution	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	var solution: PackingSolution;$/;"	d
solve	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def solve(idx: int, state: Array<ScalarPattern>) -> bool {$/;"	m
solve	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def solve(cases: Array<Array<Type>>) -> VariantSolution {$/;"	m
solveField	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def solveField(idx: int) -> bool {$/;"	m
solvePacking	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def solvePacking() -> bool {$/;"	m
solveScalar	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def solveScalar(problem: PackingProblem) -> PackingSolution {$/;"	m
sort	$VIRGIL/lib/util/Arrays.v3	/^	def sort<T>(array: Array<T>, start: int, end: int, cmp: (T, T) -> bool) -> Array<T> {$/;"	f
source	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var source: Source;$/;"	d
source	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var source: VstMethod;		\/\/ declaration that produced the method, if any$/;"	d
source	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def source: Source;$/;"	d
source	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	var source: Source;$/;"	d
sourceLine	$VIRGIL/aeneas/src/main/Error.v3	/^	def sourceLine: string;$/;"	d
sourceMethodIndex	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def sourceMethodIndex = TableIndex<VstMethod, void>.new(hashVstMethod);$/;"	d
sourceMethods	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def sourceMethods = MachRtPageTable.new($/;"	d
sourcePoints	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def sourcePoints  = MachRtPageTable.new($/;"	d
spReg	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	var spReg: Arm64Gpr;$/;"	d
spReg	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	var spReg: X86_64Gpr;$/;"	d
space	$VIRGIL/aeneas/src/os/Linux.v3	/^	def space: AddressSpace;$/;"	d
space	$VIRGIL/aeneas/src/util/Progress.v3	/^	def space() {$/;"	m
space	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def space(str: string) {$/;"	m
spec	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	var spec: IrSpec;$/;"	d
spec	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var spec: IrSpec;$/;"	d
specMap	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def specMap = IrUtil.newIrSpecMap<SpecMethod>();$/;"	d
specOf	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def specOf(ir: IrModule, receiver: Type, member: VstMember, typeArgs: TypeArgs) -> IrSpec {$/;"	f
specOf	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def specOf(receiver: Type, member: VstMember, typeArgs: TypeArgs) -> IrSpec {$/;"	m
specSet	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def specSet = IrUtil.newIrItemMap<SpecSet>();$/;"	d
specSet	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	var specSet: SpecSet;$/;"	d
specialize	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def specialize() {$/;"	m
specializer	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var specializer: Specializer;$/;"	d
spill	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var spill: bool = false;$/;"	d
spill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var spill: int;			\/\/ assigned spill slot (< 0 indicates a constant)$/;"	d
spillArgs	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var spillArgs: int;		\/\/ space for outgoing spilled arguments$/;"	d
spillCost	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var spillCost = 0;$/;"	d
spillReg	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^	def spillReg(reg: byte, next: ArchInstr) {$/;"	m
spillStart	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def spillStart: int = regSets.length;$/;"	d
spillTempReg	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def spillTempReg(mm: MachMoves, reg: int) -> int {$/;"	m
spillVar	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def spillVar(vreg: VReg) -> int {$/;"	m
spillVar	$VIRGIL/aeneas/src/mach/SimpleRegAlloc.v3	/^	def spillVar(vreg: VReg) {$/;"	m
spillVars	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var spillVars: int;		\/\/ spilled variables$/;"	d
spillWorklist	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def spillWorklist = Vector<int>.new();$/;"	d
spiller	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def spiller = ShadowStackSpiller.new();$/;"	d
spills	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var spills: Vector<(int, int)>;$/;"	d
split	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var split: bool;			\/\/ this set has been split$/;"	d
split	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	private def split(block: SsaBlock, done: int) {$/;"	f
split	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def split() -> VstSsaEnv {$/;"	m
split	$VIRGIL/aeneas/src/types/Int.v3	/^	def split(val: long) -> (int, int) {$/;"	f
splitBasedOnCalls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def splitBasedOnCalls(poly: SpecSet) {$/;"	m
splitCriticalEdges	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def splitCriticalEdges(graph: SsaGraph) {$/;"	f
splitCurBlock	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def splitCurBlock() -> (SsaBuilder, SsaBuilder, SsaBuilder) {$/;"	m
splitSpecSet	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def splitSpecSet(orig: SpecSet, dirty: bool, list: List<SpecMethod>) {$/;"	m
splits	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var splits: Vector<List<SpecSigNode>>;$/;"	d
sqrtpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
sqrtps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
sqrtsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sqrtsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x51, a, b); }$/;"	m
sqrtsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
sqrtsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
sqrtss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sqrtss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x51, a, b); }$/;"	m
sqrtss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
sqrtss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sqrtss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
sra	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sra(rd: MipsReg, rs: MipsReg, imm: u5)      { w.put_b32be(0x3 | int.view(rs.tag) << 16 | int.view(rd.tag) << 11 | imm << 6); }$/;"	m
srav	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def srav(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x00000007, rd, rs, rt); }$/;"	m
src	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var src: MachRtSrcTables;$/;"	d
src	$VIRGIL/aeneas/src/mach/MoveResolver.v3	/^	var src: MoveNode;		\/\/ source of the value for this node$/;"	d
src	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def src: SsaEnd;$/;"	d
src	$VIRGIL/lib/util/Edge.v3	/^	def src: T;		\/\/ the source of this edge$/;"	d
srcPrinter	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def srcPrinter = SrcPrinter.new(prog.vst.files, interp);$/;"	d
srl	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def srl(rd: MipsReg, rs: MipsReg, imm: u5)      { w.put_b32be(0x2 | int.view(rs.tag) << 16 | int.view(rd.tag) << 11 | imm << 6); }$/;"	m
srlv	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def srlv(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x00000006, rd, rs, rt); }$/;"	m
ssa	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var ssa: SsaGraph;		\/\/ SSA code for method$/;"	d
ssa	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def ssa: SsaInstr;		\/\/ corresponding ssa instruction (if any)$/;"	d
ssa	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def ssa: SsaCheckpoint;$/;"	d
ssa	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var ssa: SsaGraph;$/;"	d
ssa	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var ssa: VstSsaVar;$/;"	d
ssaDecon	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var ssaDecon: SsaDeconstructor;$/;"	d
ssaDecon	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var ssaDecon: SsaDeconstructor;$/;"	d
ssaMon	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var ssaMon: IrSpec -> void;$/;"	d
ssaTarget	$VIRGIL/aeneas/src/ssa/SsaTarget.v3	/^var ssaTarget = Aeneas.registerTarget(SsaTarget.new());$/;"	d
sse	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def sse(a: SsaInstr) -> int {$/;"	m
st_index	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_index: i16;$/;"	d
st_info	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_info: byte;$/;"	d
st_name	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_name: int;$/;"	d
st_other	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_other: byte;$/;"	d
st_size	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_size: long;$/;"	d
st_value	$VIRGIL/aeneas/src/exe/ELF.v3	/^	var st_value: long;$/;"	d
stable64_grow	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable64_grow(new_pages: i64) -> i64;						\/\/ *$/;"	f
stable64_read	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable64_read(dst: i64, offset: i64, size: i64);					\/\/ *$/;"	f
stable64_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable64_size() -> i64;				 				\/\/ *$/;"	f
stable64_write	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable64_write(offset: i64, src: i64, size: i64);					\/\/ *$/;"	f
stable_grow	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable_grow(new_pages: i32) -> i32;		    					\/\/ *$/;"	f
stable_read	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable_read(dst: i32, offset: i32, size: i32);					\/\/ *$/;"	f
stable_size	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable_size() -> i32;								\/\/ *$/;"	f
stable_write	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def stable_write(offset: i32, src: i32, size: i32);					\/\/ *$/;"	f
stack	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var stack: Array<SsaJvmInstr>;	\/\/ abstract stack contents$/;"	d
stack	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var stack = ListStack<SsaIcBlock>.new();$/;"	d
stack	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def stack = Vector<SsaBlockInfo>.new();$/;"	d
stackAlign	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var stackAlign: int;$/;"	d
stackBlocks	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def stackBlocks = Vector<(int, ArchInstr, ArchInstr)>.new();$/;"	d
stackDelta	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def stackDelta(instance: bool) -> int {$/;"	m
stackIndex	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var stackIndex = -2;$/;"	d
stackRefMaps	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var stackRefMaps = MachRtPageTable.new(CiRuntimeModule.GC_STACKMAP_PAGES, CiRuntimeModule.GC_STACKMAP_TABLE, null, false).grow(mach.numMethods * 2);$/;"	d
stackgen	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def stackgen = WasmStackInstrGen.new(wasm);$/;"	d
stackifier	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	var stackifier: MachStackifier;$/;"	d
stackify	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def stackify(uid: int, pre: ArchInstr, end: ArchInstr) {$/;"	m
star	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def star(i: int, f: byte -> bool) -> int {$/;"	m
star_rel	$VIRGIL/lib/util/TextReader.v3	/^	def star_rel(offset: int, f: byte -> bool) -> int {$/;"	m
start	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var start: int = -1;		\/\/ start position of code that defines this var$/;"	d
start	$VIRGIL/aeneas/src/ssa/SsaBlockOrder.v3	/^	var start: int;  \/\/ start of block interval containing loop blocks$/;"	d
start	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def start(stopOnEntry: bool) {$/;"	m
start	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var start = -1;$/;"	d
start	$VIRGIL/lib/term/Vt100.v3	/^	private def start = esc("[");$/;"	d
startAddr	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	var startAddr: int;$/;"	d
startArgs	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var startArgs: Array<Val>;$/;"	d
startBlock	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def startBlock = SsaBlock.new();$/;"	d
startDel	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var startDel: Closure;$/;"	d
startIndex	$VIRGIL/aeneas/src/ir/TypeNorm.v3	/^	def startIndex() -> int { return size - 2; }$/;"	m
startLoop	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def startLoop(env: VstSsaEnv, loopNum: int) -> VstSsaEnv {$/;"	m
startMark	$VIRGIL/aeneas/src/ssa/SsaMap.v3	/^	private var startMark: int;$/;"	d
startPos	$VIRGIL/aeneas/src/mach/MachDataWriter.v3	/^	var startPos: int; \/\/ start position from which offset() is calculated$/;"	d
startSection	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def startSection(code: byte) {$/;"	m
startStringSection	$VIRGIL/aeneas/src/os/Linux.v3	/^	def startStringSection(w: DataWriter) {$/;"	m
startsWith	$VIRGIL/lib/util/Strings.v3	/^	def startsWith(str: string, start: string) -> bool {$/;"	f
startup	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	var startup: void -> void;$/;"	d
statbuf	$VIRGIL/rt/x86-64-darwin/System.v3	/^	var statbuf = Array<long>.new(18);$/;"	d
state	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var state: Array<VariantPattern>;$/;"	d
state	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var state = Array<byte>.new(1 + gen.vars.length);$/;"	d
state	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var state = SsaBlockState.new();	\/\/ flow sensitive state$/;"	d
statistic	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def statistic = RegAllocStatistic.new();$/;"	d
statsMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def statsMatcher = CLOptions.PRINT_SSA_STATS.get();$/;"	d
step	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def step() {$/;"	m
step	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def step(targetFrame: SsaIntFrame) {$/;"	m
step	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def step(i: SsaInstr) -> SsaInstr {$/;"	m
step	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def step: int;		\/\/ N$/;"	d
stmxcsr_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def stmxcsr_m(a: X86_64Addr) -> this {$/;"	m
stop	$VIRGIL/lib/term/Animator.v3	/^	def stop() {$/;"	m
stopExecute	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def stopExecute(instr: SsaInstr, opt: DbgExecuteOpt, targetFrame: SsaIntFrame) -> bool {$/;"	m
stopExecuteNext	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteNext(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopExecuteNexti	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteNexti(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopExecuteStep	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteStep(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopExecuteStepi	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteStepi(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopExecuteUntilBreak	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteUntilBreak(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopExecuteUntilFin	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def stopExecuteUntilFin(instr: SsaInstr, interpFrame: SsaIntFrame, targetFrame: SsaIntFrame) -> bool {$/;"	f
stopReason	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var stopReason: DbgStopReason;$/;"	d
store	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def store(kind: JvmKind, index: int) {$/;"	m
store	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var store: bool;$/;"	d
store	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var store: int;$/;"	d
store	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def store(obj: SsaInstr, field: IrField, apply: SsaApplyOp, val: SsaInstr) -> SsaInstr {$/;"	m
storeLimit	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def storeLimit = 50;$/;"	d
storeObjectTag	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def storeObjectTag(nobj: SsaInstr, t: Type) {$/;"	m
storeRemove	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^def storeRemove = 10;$/;"	d
str	$VIRGIL/aeneas/src/os/Linux.v3	/^	def str = ElfSectionHeader.new();$/;"	d
str	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def str(str: string) -> this {$/;"	m
strRecords	$VIRGIL/aeneas/src/core/Program.v3	/^	var strRecords: Array<Record>;$/;"	d
str_start	$VIRGIL/aeneas/src/os/Linux.v3	/^	var str_start: int;$/;"	d
strb	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def strb(rd: ArmReg, rn: ArmReg, off: ArmOffset) { emitls(0x05400000, rd, rn, off); }$/;"	m
strd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strd_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strd_r_r_r_ex_i(rt: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: MemRegExtend, imm: u1) -> this {$/;"	m
stream	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var stream: FileStream;$/;"	d
strh	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def strh(rd: ArmReg, rn: ArmReg, off: ArmSmallOffset) { emitlss(0x010000B0, rd, rn, off); }$/;"	m
stringArrayType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def stringArrayType = V3Array.newType(stringType);$/;"	d
stringCpe	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var stringCpe: JvmCpe_String;  \/\/ for performance, the string that uses this UTF8$/;"	d
stringData	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def stringData = StringBuilder.new();$/;"	d
stringMap	$VIRGIL/aeneas/src/mach/MachRtSrcTables.v3	/^	def stringMap  = Strings.newMap<int>();$/;"	d
stringType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def stringType      = V3Array.newType(Byte.TYPE);$/;"	d
stringTypeCon	$VIRGIL/aeneas/src/v3/V3.v3	/^	def stringTypeCon   = TypeUtil.aliasTypeCon("string", stringType);$/;"	d
strip	$VIRGIL/lib/util/Strings.v3	/^	def strip(str: string) -> string {$/;"	f
strpostd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strpostd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strpostq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strpostq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strpred_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strpred_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strpreq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strpreq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: i9) -> this {$/;"	m
strq_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strq_r_r_r_ex_i(rt: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: MemRegExtend, imm: u1) -> this {$/;"	m
structMap	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def structMap = TypeUtil.newTypeMap<WasmStruct>();$/;"	d
strunsignedd_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strunsignedd_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: u12) -> this {$/;"	m
strunsignedq_r_r_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def strunsignedq_r_r_i(rt: Arm64Reg, rn: Arm64Reg, imm: u12) -> this {$/;"	m
strw	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def strw(rd: ArmReg, rn: ArmReg, off: ArmOffset) { emitls(0x05000000, rd, rn, off); }$/;"	m
stub	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def stub: bool;$/;"	d
stubMap	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def stubMap       = Strings.newMap<(Addr, (Addr, MachDataWriter) -> void)>();$/;"	d
sub	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def sub(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(4, rd, rn, op); }$/;"	m
sub	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def sub(rd: MipsReg, rs: MipsReg, rt: MipsReg)  { emit_r3(0x00000022, rd, rs, rt); }$/;"	m
sub	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var sub: X86Op2;$/;"	d
subRange	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	def subRange(num: FpSketch, pos: int, maxPos: int) -> u32 {$/;"	m
sub_bytes	$VIRGIL/lib/util/DataReader.v3	/^	def sub_bytes(d: DataReader, length: int) {$/;"	m
sub_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sub_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 5); }$/;"	m
sub_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sub_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 5); }$/;"	m
sub_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sub_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 5); }$/;"	m
sub_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sub_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 5); }$/;"	m
sub_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sub_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 5); }$/;"	m
subd_r_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subd_r_r_i_i(rd: Arm64Reg, rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
subd_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subd_r_r_r_ex_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: DataRegExtend, imm: u3) -> this {$/;"	m
subd_r_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subd_r_r_r_sh_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u5) -> this {$/;"	m
subpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
subprogram	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def subprogram: Array<int> = [-1, -1, -1, -1]; \/\/ four types of subprogram$/;"	d
subprogram	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var subprogram: DwarfSubprogram;		\/\/ dwarf subprogram of method$/;"	d
subprograms	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def subprograms = Vector<DwarfSubprogram>.new();$/;"	d
subps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
subq_r_r_i_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subq_r_r_i_i(rd: Arm64Reg, rn: Arm64Reg, imm: u12, lsl12: u1) -> this {$/;"	m
subq_r_r_r_ex_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subq_r_r_r_ex_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, ex: DataRegExtend, imm: u3) -> this {$/;"	m
subq_r_r_r_sh_i	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def subq_r_r_r_sh_i(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, sh: RegShift, imm: u6) -> this {$/;"	m
subs	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def subs(rd: ArmReg, rn: ArmReg, op: ArmOperand) { data2_1(5, rd, rn, op); }$/;"	m
subsd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def subsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5C, a, b); }$/;"	m
subsd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subsd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
subsd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subsd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
subss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def subss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5C, a, b); }$/;"	m
subss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
subss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def subss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
subst	$VIRGIL/aeneas/src/core/Operator.v3	/^	def subst(f: Type -> Type) -> Operator {$/;"	m
subst	$VIRGIL/aeneas/src/types/Function.v3	/^	def subst(f: Type -> Type) -> Signature {$/;"	m
substitute	$VIRGIL/aeneas/src/types/Type.v3	/^	def substitute(typeSubst: TypeSubst) -> Type {$/;"	m
substituteTypeParam	$VIRGIL/aeneas/src/ir/IrOpMethodBuilder.v3	/^	def substituteTypeParam(typeParam: TypeParamType) -> Type {$/;"	m
substituteTypeParam	$VIRGIL/aeneas/src/types/Type.v3	/^	def substituteTypeParam(typeParam: TypeParamType) -> Type {$/;"	m
substituteTypeVar	$VIRGIL/aeneas/src/types/Type.v3	/^	def substituteTypeVar(typeVar: TypeVarType) -> Type {$/;"	m
subtypes	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var subtypes: List<RaClass>;		\/\/ list of live subtypes$/;"	d
subu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def subu(rd: MipsReg, rs: MipsReg, rt: MipsReg) { emit_r3(0x00000023, rd, rs, rt); }$/;"	m
succ	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def succ(index: int) -> SsaCfEdge {$/;"	m
successors	$VIRGIL/aeneas/src/ic/IcPrinter.v3	/^	var successors: bool = true;$/;"	d
succs	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var succs: Array<SsaCfEdge>;$/;"	d
superInitOrder	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var superInitOrder: int;$/;"	d
superName	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def superName: string;$/;"	d
superType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var superType: Type;$/;"	d
superType	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	var superType: ClassType;$/;"	d
superType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var superType: ClassType;$/;"	d
super_class	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var super_class: int;$/;"	d
superclass	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def superclass: TypeRef;$/;"	d
superclause	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var superclause: SuperClause;$/;"	d
svc	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def svc() -> this { emit(0xD4000001); }$/;"	m
swap	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def swap() {$/;"	m
switches	$VIRGIL/aeneas/src/ssa/SsaIcGen.v3	/^	var switches: List<(Array<SsaCfEdge>, IcInstr.Switch)>;$/;"	d
sym	$VIRGIL/aeneas/src/os/Linux.v3	/^	def sym = ElfSectionHeader.new();$/;"	d
symbols	$VIRGIL/aeneas/src/os/Linux.v3	/^	def symbols = Vector<ElfSymbol>.new();$/;"	d
synthesizeMembers	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def synthesizeMembers(fileName: string, line: int, col: int) -> List<VstMember> {$/;"	m
synthesizeTopLevelClass	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def synthesizeTopLevelClass(members: List<VstMember>) -> VstClass {$/;"	m
synthesizeVariantCaseMember	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def synthesizeVariantCaseMember(id: VstIdent<void>, params: VstList<ParamDecl>, members: List<VstMember>) -> VstCaseMember {$/;"	m
synthetic	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var synthetic: bool;$/;"	d
syscall	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def syscall(code: u20) { w.put_b32be(0x00000004 | int.view(code) << 6); }$/;"	m
syscall	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def syscall() -> this { emitbb(0x0f, 0x05); }$/;"	m
sysenter	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sysenter() -> this { emitbb(0x0f, 0x34); }$/;"	m
sysenter	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sysenter() { emitbb(0x0f, 0x34); }$/;"	m
sysexit	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def sysexit() -> this { emitbb(0x0f, 0x35); }$/;"	m
sysexit	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def sysexit() { emitbb(0x0f, 0x35); }$/;"	m
system	$VIRGIL/aeneas/src/core/Program.v3	/^	var system: SystemCallState;$/;"	d
systemClassName	$VIRGIL/aeneas/src/jvm/JvmType.v3	/^	def systemClassName = "V3S_System";$/;"	d
tab	$VIRGIL/lib/util/StringBuilder.v3	/^	def tab() -> this {$/;"	m
tabColumn	$VIRGIL/lib/util/TextReader.v3	/^	private def tabColumn() {$/;"	m
table	$VIRGIL/aeneas/src/core/Opcode.v3	/^	def table = Array<Fact.set>.new(Opcode.CallKernel.tag + 1);$/;"	d
table	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def table = [$/;"	d
table	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var table = Array<int>.new(INITIAL);$/;"	d
table	$VIRGIL/lib/util/Map.v3	/^	private var table: Array<Bucket<K, V>>;	\/\/ lazily allocated hashtable$/;"	d
tableSwList	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var tableSwList: List<(int, Array<SsaCfEdge>)>;$/;"	d
tableswitch	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def tableswitch(min: int, max: int) -> int {$/;"	m
tag	$VIRGIL/aeneas/src/core/Opcode.v3	/^type Opcode {$/;"	d
tag	$VIRGIL/aeneas/src/ic/Ic.v3	/^type IntUnop {$/;"	d
tag	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^type PackingField #unboxed {$/;"	d
tag	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def tag: VariantField;$/;"	d
tag	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^type Operand {$/;"	d
tag	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^type BoundOp {$/;"	d
tag	$VIRGIL/aeneas/src/vst/Vst.v3	/^type VstRepHint {$/;"	d
tag	$VIRGIL/aeneas/src/vst/VstMatcher.v3	/^type VstMatcher {$/;"	d
tag	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^type CfgInstr {$/;"	d
tag	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^type WasmType {$/;"	d
tag	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^type ArmSmallOffset {$/;"	d
tag	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^type MipsReg {$/;"	d
tag	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^type NetResult<T> {$/;"	d
tag	$VIRGIL/lib/packing/CiRuntime.v3	/^type CiSourceEntry #unboxed {$/;"	d
tagIndex	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	def tagIndex() -> int { return tag.indexes[0]; }$/;"	m
tagLength	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	var tagLength: byte = 0;$/;"	d
tagType	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var tagType: IntType;$/;"	d
tagType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def tagType = Int.TYPE;$/;"	d
tagType	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var tagType: IntType;$/;"	d
tagValue	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var tagValue: int = -1;$/;"	d
tags	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def tags = Array<u32>.new(8); \/\/ size of DwarfAbbrevTag$/;"	d
tailCall	$VIRGIL/aeneas/src/core/Eval.v3	/^	def tailCall(spec: IrSpec, recvr: Val, startArg: int, endArg: int) -> Result;$/;"	m
tailCall	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def tailCall(memberRef: IrSpec, rcvr: Val, startArg: int, endArg: int) -> Result {$/;"	m
tailCall	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def tailCall(spec: IrSpec, recvr: Val, startArg: int, endArg: int) -> Result {$/;"	m
tailCalled	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var tailCalled: bool;$/;"	d
target	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def target() -> SsaBlock { return block().succ(0).dest; }$/;"	m
target	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var target = func;$/;"	d
targetfps	$VIRGIL/lib/term/Animator.v3	/^	private var targetfps = 30u;  \/\/ target frames per second$/;"	d
targets	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	var targets: List<Target>;$/;"	d
teq	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def teq(rs: MipsReg, rt: MipsReg, code: u10)  { emit_r2i(0x00000034, rs, rt, u16.!(code) << 6); }$/;"	m
term1	$VIRGIL/aeneas/src/vst/Parser.v3	/^	def term1(p: ParserState, start: FilePoint, ch: byte) -> FileRange {$/;"	f
test	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/arm/ArmRuntime.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/arm64/Arm64Backend.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var test: bool;$/;"	d
test	$VIRGIL/aeneas/src/jvm/JvmTarget.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/x86-64/X86_64Backend.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/x86-64/X86_64Darwin.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/x86/X86Backend.v3	/^	def test: bool;$/;"	d
test	$VIRGIL/aeneas/src/x86/X86Darwin.v3	/^	def test: bool;$/;"	d
testOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def testOpt = OptionGroup.new("TEST", options);$/;"	d
testPrefix	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var testPrefix: string;$/;"	d
test_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def test_m_i(a: X86_64Addr, i: int) -> this {$/;"	m
test_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def test_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
test_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def test_r_i(a: X86_64Gpr, i: int) -> this {$/;"	m
test_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def test_r_m(a: X86_64Gpr, b: X86_64Addr) -> this {$/;"	m
test_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def test_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
test_rm_i	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def test_rm_i(a: X86Rm, i: int) {$/;"	m
test_rm_r	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def test_rm_r(a: X86Rm, b: X86Reg) { emitb_rm(0x85, a, b.index); }$/;"	m
text	$VIRGIL/aeneas/src/os/Linux.v3	/^	def text = ElfSectionHeader.new();$/;"	d
tge	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tge(rs: MipsReg, rt: MipsReg, code: u10)  { emit_r2i(0x00000030, rs, rt, u16.!(code) << 6); }$/;"	m
tgeu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tgeu(rs: MipsReg, rt: MipsReg, code: u10) { emit_r2i(0x00000031, rs, rt, u16.!(code) << 6); }$/;"	m
tgt	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tgt(rs: MipsReg, rt: MipsReg, code: u10)  { emit_r2i(0x00000034, rs, rt, u16.!(code) << 6); }$/;"	m
thisParam	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def thisParam: ParamDecl;$/;"	d
thisParam	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var thisParam: ParamDecl;$/;"	d
thisParam	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var thisParam: ParamDecl;$/;"	d
thisType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def thisType: Type;$/;"	d
this_class	$VIRGIL/aeneas/src/jvm/JvmClassfile.v3	/^	var this_class: int;$/;"	d
throw	$VIRGIL/aeneas/src/core/Eval.v3	/^	def throw(ex: string, msg: string) -> Exception;$/;"	m
throw	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def throw(ex: string, msg: string) -> Exception {$/;"	m
throw	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def throw(ex: string, msg: string) -> Exception {$/;"	m
throwTypeCheckException	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def throwTypeCheckException() {$/;"	m
ticksMs	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def ticksMs(args: Arguments) -> Val {$/;"	m
ticksMs	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def ticksMs() -> int {$/;"	f
ticksNs	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def ticksNs(args: Arguments) -> Val {$/;"	m
ticksNs	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def ticksNs() -> int {$/;"	f
ticksUs	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def ticksUs(args: Arguments) -> Val {$/;"	m
ticksUs	$VIRGIL/lib/term/Animator.v3	/^	private def ticksUs() -> u32 {$/;"	m
ticksUs	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def ticksUs() -> int {$/;"	f
time	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def time() -> i64;									\/\/ *$/;"	f
timeval	$VIRGIL/rt/x86-64-darwin/System.v3	/^	var timeval = Array<long>.new(2);$/;"	d
tlt	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tlt(rs: MipsReg, rt: MipsReg, code: u10)  { emit_r2i(0x00000032, rs, rt, u16.!(code) << 6); }$/;"	m
tltu	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tltu(rs: MipsReg, rt: MipsReg, code: u10) { emit_r2i(0x00000033, rs, rt, u16.!(code) << 6); }$/;"	m
tmpBuf	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def tmpBuf = TerminalBuffer.new(); \/\/ current line$/;"	d
tmpRow	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var tmpRow: BitMatrixRow;$/;"	d
tmpSpill	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var tmpSpill: int = -1;		\/\/ temporary spill slot$/;"	d
tmps	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private var tmps = mapRegClasses([$/;"	d
tne	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def tne(rs: MipsReg, rt: MipsReg, code: u10)  { emit_r2i(0x00000036, rs, rt, u16.!(code) << 6); }$/;"	m
toArray	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def toArray() -> Array<byte> {$/;"	m
toArray	$VIRGIL/lib/util/List.v3	/^	def toArray<T>(list: List<T>) -> Array<T> {$/;"	f
toB32	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toB32(val: Val) -> int {$/;"	m
toBlock	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toBlock(o: Operand) -> SsaBlock {$/;"	m
toDwarfFile	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def toDwarfFile(filepath: string) -> DwarfFile {$/;"	m
toEnv	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def toEnv(parent: VstSsaEnv) -> VstSsaEnv {$/;"	m
toExSource	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toExSource(o: Operand) -> (string, Source) {$/;"	m
toGpr	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toGpr(o: Operand) -> X86_64Gpr {$/;"	m
toGpr	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def toGpr(loc: int) -> X86_64Gpr {$/;"	f
toImm	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toImm(o: Operand) -> Val {$/;"	m
toInfix	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def toInfix(name: string) -> InfixOp {$/;"	m
toInt	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toInt(o: Operand) -> int {$/;"	m
toInt	$VIRGIL/aeneas/src/types/Bool.v3	/^	def toInt(b: bool) -> int {$/;"	f
toInt	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def toInt() -> int {$/;"	m
toLabel	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toLabel(o: Operand) -> Label {$/;"	m
toLoc	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toLoc(o: Operand) -> int {$/;"	m
toLongAddr	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toLongAddr(bits: u64) -> X86_64Addr {$/;"	m
toMrrsd	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toMrrsd(a: Array<Operand>, start: int) -> X86_64Addr {$/;"	m
toNewVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toNewVar(o: Operand) -> (string, Type) {$/;"	m
toReg	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def toReg(o: Operand) -> ArmReg {$/;"	m
toRegClass	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def toRegClass(t: Type) -> RegClass {$/;"	m
toSSEAddr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def toSSEAddr() -> SSEAddr { return SSEAddr.new(base, index, scale, disp); }$/;"	m
toSlot	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toSlot(loc: int) -> int {$/;"	m
toSockAddr	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^def toSockAddr(addr: InetAddress, port: int) -> Array<byte> {$/;"	f
toString	$VIRGIL/aeneas/src/main/Error.v3	/^	def toString() -> string {$/;"	m
toString	$VIRGIL/lib/util/StringBuilder.v3	/^	def toString() -> string {$/;"	m
toTypeArray	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def toTypeArray(paramType: Type) -> Array<Type> {$/;"	f
toTypeArray	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def toTypeArray(list: List<TypeParamType>) -> Array<Type> {$/;"	f
toTypeList	$VIRGIL/aeneas/src/types/Tuple.v3	/^	def toTypeList(paramType: Type) -> List<Type> {$/;"	f
toVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def toVar(o: Operand) -> VReg {$/;"	m
toX86Addr	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def toX86Addr() -> X86Addr { return X86Addr.new(base, index, scale, disp); }$/;"	m
toXmmr	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def toXmmr(o: Operand) -> X86_64Xmmr {$/;"	m
toXmmr	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	def toXmmr(loc: int) -> X86_64Xmmr {$/;"	f
token	$VIRGIL/aeneas/src/types/Type.v3	/^	def token: Token;$/;"	d
token	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def token(len: int) -> Token {$/;"	m
token	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def token: Token;$/;"	d
tokenAt	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def tokenAt(start: int, end: int) -> Token {$/;"	m
tokenFor	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	private def tokenFor(start: int, end: int, l: int, c: int) -> Token {$/;"	m
tokenFor	$VIRGIL/lib/util/TextReader.v3	/^	private def tokenFor(start: int, end: int, l: int, c: int) -> Token {$/;"	m
tokenSource	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def tokenSource(point: FilePoint) -> Source {$/;"	m
top	$VIRGIL/lib/util/Stack.v3	/^	var top = 0; \/\/ TODO: stack top should not be directly mutable$/;"	d
topFrame	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var topFrame: IcFrame;		\/\/ currently executing frame$/;"	d
total	$VIRGIL/aeneas/src/ic/IcProfiler.v3	/^	var total: int;			\/\/ total instruction count$/;"	d
total	$VIRGIL/aeneas/src/main/Profiler.v3	/^	var total: int;$/;"	d
total	$VIRGIL/lib/util/IO.v3	/^	private var total: int;$/;"	d
total_width	$VIRGIL/aeneas/src/types/Float.v3	/^	def total_width = byte.!(1 + exp_width + fraction_width);$/;"	d
totalsize	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var totalsize: int = if (is64, 32, 28);$/;"	d
tprog	$VIRGIL/aeneas/src/core/Program.v3	/^	var tprog: TargetProgram;$/;"	d
trace	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^def trace = false; \/\/ XXX remove tracing altogether$/;"	d
traceCallee	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	var traceCallee: bool;$/;"	d
traceInstr	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def traceInstr(i: SsaInstr) {$/;"	m
transform	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def transform(config: NormalizerConfig) {$/;"	m
trap	$VIRGIL/lib/ic/ic0_untyped.v3	/^	def trap(src: i32, size: i32);								\/\/ * s$/;"	f
tref	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def tref: TypeRef;$/;"	d
trueBlock	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def trueBlock() -> SsaBlock { return block().succ(0).dest; }$/;"	m
trueConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def trueConst() -> SsaConst {$/;"	m
tryAddConsts	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def tryAddConsts(k1: Val, k2: Val) -> Val {$/;"	m
tryAssignInterval	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def tryAssignInterval(i: Interval) -> bool {$/;"	m
tryAssignmentHeuristic	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	private def tryAssignmentHeuristic(state: Array<ScalarPattern>) -> bool {$/;"	m
tryBoundingIv	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def tryBoundingIv(iv: SsaLinearIv, cond: SsaInstr, condTrue: bool) {$/;"	m
tryBuildingSwitch	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def tryBuildingSwitch(block: SsaBlock, sw: SsaIf, t: Type, cmp: SsaInstr) {$/;"	m
tryCoalesce	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def tryCoalesce(x_: int, y_: int) -> bool {$/;"	m
tryDevirtualize	$VIRGIL/aeneas/src/ir/SsaNormalizer.v3	/^	def tryDevirtualize(rm: RaMethod, ta: Array<Type>) -> (IrSpec, bool) {$/;"	m
tryElimBoundsCheck	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	private def tryElimBoundsCheck(x: SsaInstr, y: SsaInstr) -> Fact.set {$/;"	m
tryExplicitTaggingHeuristic	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	private def tryExplicitTaggingHeuristic(state: Array<ScalarPattern>) -> bool {$/;"	m
tryExplicitTaggingHeuristic	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def tryExplicitTaggingHeuristic() -> bool {$/;"	m
tryInlining	$VIRGIL/aeneas/src/ssa/SsaInliner.v3	/^	def tryInlining(block: SsaBlock) {$/;"	m
tryPromoteS	$VIRGIL/aeneas/src/types/Float.v3	/^	def tryPromoteS(v: long) -> Val {$/;"	m
tryPromoteU	$VIRGIL/aeneas/src/types/Float.v3	/^	def tryPromoteU(sign: u1, v: u64) -> Val {$/;"	m
tryPropagatingCmpNonZero	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def tryPropagatingCmpNonZero(cmp: SsaApplyOp, eqEdge: SsaCfEdge, neEdge: SsaCfEdge) {$/;"	m
tryRepresentationForField	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def tryRepresentationForField(curCase: int, curField: int) -> bool {$/;"	m
tryUnboxPositiveInt	$VIRGIL/aeneas/src/vst/Verifier.v3	/^def tryUnboxPositiveInt(lit: Literal, nullVal: int) -> int {$/;"	f
tryUnboxing	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def tryUnboxing(rc: RaClass) -> bool {$/;"	m
tryUseImm32	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def tryUseImm32(i: SsaInstr) -> bool {$/;"	m
tupleNormMap	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def tupleNormMap = Vector<TupleNorm>.new();$/;"	d
tupleType	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def tupleType: Type;$/;"	d
tupleType	$VIRGIL/aeneas/src/types/Float.v3	/^	def tupleType = Tuple.newType(Lists.cons2(ft, ft));$/;"	d
tupleType	$VIRGIL/aeneas/src/types/Int.v3	/^	def tupleType = Tuple.newType(Lists.cons2(it, it));$/;"	d
two54	$VIRGIL/lib/math/Math.v3	/^def two54 = 1.80143985094819840000e+16;		\/* 43500000 00000000 *\/$/;"	d
twoConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def twoConst() -> SsaConst {$/;"	m
twom1000	$VIRGIL/lib/math/Math.v3	/^def twom1000	= 9.33263618503218878990e-302;		\/* 01700000 00000000 *\/ \/* == 2**-1000*\/$/;"	d
typeArgs	$VIRGIL/aeneas/src/ic/Ic.v3	/^	private var typeArgs: Array<Type>;$/;"	d
typeArgs	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def typeArgs: TypeArgs;		\/\/ type arguments to this method (bound or unbound)$/;"	d
typeArgs	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var typeArgs: Array<Type>;$/;"	d
typeArgs	$VIRGIL/aeneas/src/types/Float.v3	/^	def typeArgs = arr_t;$/;"	d
typeArgs	$VIRGIL/aeneas/src/types/Int.v3	/^	def typeArgs: Array<Type> = [it];$/;"	d
typeArgs	$VIRGIL/aeneas/src/v3/V3Class.v3	/^	var typeArgs: TypeArgs;$/;"	d
typeCache	$VIRGIL/aeneas/src/core/Program.v3	/^	def typeCache = TypeCache.new();$/;"	d
typeCache	$VIRGIL/aeneas/src/main/Error.v3	/^	var typeCache: TypeCache;$/;"	d
typeCache	$VIRGIL/aeneas/src/types/Type.v3	/^	def typeCache: TypeCache;	\/\/ per-language or per-program type cache$/;"	d
typeCache	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def typeCache: TypeCache;		\/\/ typeCache; TODO: V3-specific$/;"	d
typeCache	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var typeCache: TypeCache;$/;"	d
typeCheckArgs	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckArgs(op: string, args: VstList<Expr>, funcType: Type, outer: Type) -> List<Type> {$/;"	m
typeCheckBody	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckBody(stmt: Stmt) {$/;"	m
typeCheckEnumCase	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckEnumCase(decl: VstEnum, c: VstEnumCase, tc: TypeChecker) {$/;"	m
typeCheckExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckExpr(expr: Expr, outerType: Type, op: string) {$/;"	m
typeCheckExprs	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckExprs(args: TupleExpr, types: List<Type>, op: string) {$/;"	m
typeCheckFuncExprBody	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckFuncExprBody(stmt: Stmt, expected: Type) -> Type { \/\/ TODO$/;"	m
typeCheckNew	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckNew(decl: VstCompound, cdecl: VstNew, tc: TypeChecker) {$/;"	m
typeCheckStmt	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckStmt(stmt: Stmt) -> int {$/;"	m
typeCheckStmtWithNewScope	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckStmtWithNewScope(stmt: Stmt) -> int {$/;"	m
typeCheckTupleElem	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckTupleElem(e: Expr, t: Type) -> Type {$/;"	m
typeCheckVstCompound	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def typeCheckVstCompound(decl: VstCompound) {$/;"	m
typeColor	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def typeColor() -> this {$/;"	m
typeCon	$VIRGIL/aeneas/src/mach/MachRuntime.v3	/^	var typeCon: CiRuntime_TypeCon;$/;"	d
typeCon	$VIRGIL/aeneas/src/types/Type.v3	/^	def typeCon: TypeCon;	\/\/ type constructor$/;"	d
typeCon	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var typeCon: TypeCon;$/;"	d
typeEnv	$VIRGIL/aeneas/src/core/Program.v3	/^	def typeEnv = TypeEnv.new(null, null, V3.lookupToplevelType);$/;"	d
typeEnv	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	var typeEnv: TypeEnv;$/;"	d
typeEnv	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var typeEnv: TypeEnv;$/;"	d
typeEnv	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var typeEnv: TypeEnv;$/;"	d
typeMap	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def typeMap = TypeUtil.newTypeMap<TypeNorm>();$/;"	d
typeMap	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def typeMap = LazyMap.new(Type.hash, Type.==, uniquify<Type>);$/;"	d
typeMap	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	def typeMap = TypeUtil.newTypeMap<RaType>();$/;"	d
typeMap	$VIRGIL/aeneas/src/wasm/WasmType.v3	/^	def typeMap = HashMap<Signature, int>.new(Signature.hash, Signature.equals);$/;"	d
typeNorm	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var typeNorm: TypeNorm;$/;"	d
typePairEqual	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def typePairEqual(a: (Type, Type), b: (Type, Type)) -> bool {$/;"	f
typePairHash	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def typePairHash(a: Type, b: Type) -> int {$/;"	f
typeParam	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	private def typeParam = typeParamList.head;$/;"	d
typeParam	$VIRGIL/aeneas/src/types/Type.v3	/^	def typeParam: TypeParamType;$/;"	d
typeParamList	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def typeParamList = TypeUtil.ONE_TYPE_PARAM;$/;"	d
typeParams	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def typeParams: List<TypeParamType>;$/;"	d
typeParams	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def typeParams: List<TypeParamType>;$/;"	d
typeRef	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def typeRef = TypeUtil.newTypeMap<int>();$/;"	d
typeRefMaps	$VIRGIL/aeneas/src/mach/MachRtGcTables.v3	/^	var typeRefMaps = Vector<int>.new();$/;"	d
typeRefOf	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def typeRefOf(actualType: Type) -> TypeRef {$/;"	f
typeRefOfParam	$VIRGIL/aeneas/src/types/TypeUtil.v3	/^	def typeRefOfParam(t: TypeParamType) -> TypeRef {$/;"	f
typeReps	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def typeReps = TypeUtil.newTypeMap<MachRep>();$/;"	d
typeTable	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	var typeTable: WasmTypeTable;$/;"	d
typeTag	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	var typeTag: Box<int>;$/;"	d
typeVar	$VIRGIL/aeneas/src/types/Type.v3	/^	var typeVar: TypeVarType;$/;"	d
typeVarElim	$VIRGIL/aeneas/src/ir/VstIr.v3	/^	def typeVarElim = TypeVarEliminator.new(null, Void.TYPE);$/;"	d
type_d	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_d: Type = Float.FLOAT64;$/;"	d
type_f	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_f: Type = Float.FLOAT32;$/;"	d
type_i	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_i = Int.TYPE;$/;"	d
type_rs	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_rs = V3Range.START_TYPE;$/;"	d
type_u	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_u = Int.getType(false, 32);$/;"	d
type_v	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_v = Void.TYPE;$/;"	d
type_z	$VIRGIL/aeneas/src/core/Operator.v3	/^	def type_z = Bool.TYPE;$/;"	d
typecons	$VIRGIL/aeneas/src/types/TypeEnv.v3	/^	def typecons = Strings.newMap<TypeCon>();$/;"	d
typedMain	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var typedMain: bool;$/;"	d
types	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var types: IrSpecTypes;$/;"	d
types	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var types: Array<Type>;$/;"	d
u64_divmod_big_divisor	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def u64_divmod_big_divisor(op: WideDivision, source: Source) {$/;"	m
u64_divmod_small_divisor	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def u64_divmod_small_divisor(op: WideDivision, source: Source, stub: bool) {$/;"	m
u64at	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	private def u64at(pos: int) -> u64 {$/;"	m
u_const	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def u_const(v: u32) -> SsaInstr {$/;"	m
u_suffix	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var u_suffix: bool;$/;"	d
u_threshold	$VIRGIL/lib/math/Math.v3	/^def u_threshold	= -7.45133219101941108420e+2;		\/* c0874910 D52D3051 *\/$/;"	d
ucomisd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ucomisd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x2E, a, b); }$/;"	m
ucomisd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ucomisd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
ucomisd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ucomisd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
ucomiss	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def ucomiss(a: SSEReg, b: SSERm) {$/;"	m
ucomiss_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ucomiss_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
ucomiss_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def ucomiss_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
udiv	$VIRGIL/lib/asm/arm/ArmAssembler.v3	/^	def udiv(rd: ArmReg, rs: ArmReg, rm: ArmReg) { emit_rrr(0x0730f010, rd, rm, rs); }$/;"	m
udivd_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def udivd_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
udivmod_checked	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def udivmod_checked(source: Source, zeroCheck: bool, a: X86Rm) {$/;"	m
udivq_r_r_r	$VIRGIL/lib/asm/arm64/Arm64Assembler.v3	/^	def udivq_r_r_r(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) -> this {$/;"	m
ui2d_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def ui2d_fixup() {$/;"	m
ui2f_fixup	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def ui2f_fixup() {$/;"	m
uid	$VIRGIL/aeneas/src/ic/Ic.v3	/^	def uid: int = UID.next++;$/;"	d
uid	$VIRGIL/aeneas/src/ir/Ir.v3	/^	def uid: int = UID.next++;$/;"	d
uid	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var uid = 1;$/;"	d
uid	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def uid: int = UID.next++;	\/\/ unique identification number$/;"	d
uid	$VIRGIL/aeneas/src/types/Type.v3	/^	def uid = UID.next++;$/;"	d
uint_truncd	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def uint_truncd(dest: X86Reg, a: SSERm) {$/;"	m
uint_truncf	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def uint_truncf(dest: X86Reg, a: SSERm) {$/;"	m
ulong_truncfp	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def ulong_truncfp(il: X86Rm, ih: X86Rm, a: SSERm, isDouble: bool) {$/;"	m
un64	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def un64(loc: int) -> int {$/;"	m
unalloc	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def unalloc(name: string) -> byte {$/;"	f
unassignInterval	$VIRGIL/aeneas/src/ir/PackingSolver.v3	/^	def unassignInterval(i: Interval) -> this {$/;"	m
unboundType	$VIRGIL/aeneas/src/ir/Ir.v3	/^	var unboundType: Type;$/;"	d
unbox	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def unbox<T>() -> T {$/;"	m
unbox	$VIRGIL/aeneas/src/types/Bool.v3	/^	def unbox(val: Result) -> bool {$/;"	f
unbox	$VIRGIL/aeneas/src/types/Byte.v3	/^	def unbox(val: Val) -> byte {$/;"	f
unbox	$VIRGIL/aeneas/src/types/Int.v3	/^	def unbox(val: Val) -> int {$/;"	f
unboxI32	$VIRGIL/aeneas/src/v3/V3.v3	/^	def unboxI32(v: Val) -> int {$/;"	f
unboxSU	$VIRGIL/aeneas/src/types/Int.v3	/^	def unboxSU(val: Val, signed: bool) -> long {$/;"	f
unboxString	$VIRGIL/aeneas/src/types/Byte.v3	/^	def unboxString(val: Val) -> Array<byte> {$/;"	f
unboxUsingEnumVariantNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def unboxUsingEnumVariantNorm(rc: RaClass, tagType: IntType, tagField: VariantField) {$/;"	m
unboxUsingTaggedVariantNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def unboxUsingTaggedVariantNorm(rc: RaClass) -> bool {$/;"	m
unboxUsingTaglessVariantNorm	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	private def unboxUsingTaglessVariantNorm(rc: RaClass) {$/;"	m
unboxVariantEarly	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def unboxVariantEarly(decl: VstClass) -> bool {$/;"	m
unboxVariantsOpt	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def unboxVariantsOpt = CLOptions.UNBOX_VARIANTS.get();$/;"	d
unexpected	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def unexpected(i_old: SsaApplyOp) {$/;"	m
unexpectedInstr	$VIRGIL/aeneas/src/ssa/SsaRebuilder.v3	/^	def unexpectedInstr(i_old: SsaInstr) -> SsaInstr {$/;"	m
unexpectedPass	$VIRGIL/aeneas/src/util/Progress.v3	/^	def unexpectedPass() {$/;"	m
unexpectedType	$VIRGIL/aeneas/src/mach/MachProgram.v3	/^	def unexpectedType<T>(t: Type, v: T) -> T {$/;"	m
unexpectedType	$VIRGIL/aeneas/src/main/Error.v3	/^	def unexpectedType<T>(t: Type, v: T) -> T {$/;"	m
unify0	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def unify0(dir: UnificationDir, t1: Type, t2: Type) -> Type {$/;"	f
unifyInvariant	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	private def unifyInvariant = unify0(UnificationDir.NONE, _, _); \/\/ cache$/;"	d
unifyPromotable	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def unifyPromotable(dir: UnificationDir, sub: Type, sup: Type) -> Type {$/;"	f
unifySubtype	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^def unifySubtype(dir: UnificationDir, sub: Type, sup: Type) -> Type {$/;"	f
unifyWiden	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def unifyWiden = unify0(UnificationDir.WIDER, _, _);$/;"	d
unimplemented	$VIRGIL/aeneas/src/main/Error.v3	/^	def unimplemented() {$/;"	m
unimplemented	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def unimplemented() {$/;"	m
unimplemented	$VIRGIL/aeneas/src/v3/V3.v3	/^	def unimplemented<T>() -> T {$/;"	f
uniquify	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^def uniquify<T>(v: T) -> int {$/;"	f
unknownValue	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	private def unknownValue(etype: Type, val: Val) {$/;"	m
unop	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def unop(i: SsaApplyOp) -> Val {$/;"	m
unopSig	$VIRGIL/aeneas/src/types/Float.v3	/^	def unopSig = Function.sig(ft, ft);$/;"	d
unpcklps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def unpcklps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
unreachable	$VIRGIL/aeneas/src/ssa/SsaBuilder.v3	/^	def unreachable(t: Type) -> SsaInstr {$/;"	m
unresolvedTypeCache	$VIRGIL/aeneas/src/main/Error.v3	/^	var unresolvedTypeCache = Strings.newMap<TypeCon>();$/;"	d
unsafe	$VIRGIL/aeneas/src/main/Compiler.v3	/^	var unsafe: bool;$/;"	d
unsigned	$VIRGIL/aeneas/src/types/Int.v3	/^	def unsigned() -> IntType {$/;"	m
unwind	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	def unwind() {$/;"	m
unwrap	$VIRGIL/lib/net/x86-64-linux/Net.v3	/^	def unwrap() -> T {$/;"	m
update	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def update(crc: int, data: byte) -> int {$/;"	f
update	$VIRGIL/lib/util/Edge.v3	/^	def update(newDest: T) {$/;"	m
updateK	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	def updateK(crc: int, data: Array<byte>, start: int, len: int) -> int {$/;"	f
updateLiveness	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def updateLiveness(i: ArchInstr) {$/;"	m
updateLocals	$VIRGIL/aeneas/src/ssa/SsaDebugger.v3	/^	def updateLocals() {$/;"	m
updateRegState	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def updateRegState(vreg: VReg) {$/;"	m
updateState	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def updateState(pos: int, points: LsraPoint) -> LsraPoint {$/;"	m
updateUsePos	$VIRGIL/aeneas/src/mach/RegState.v3	/^	def updateUsePos(reg: byte) {$/;"	m
updateVarLoc	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def updateVarLoc(index: int, locs: Array<(X86_64Reg, int)>, pos: int) {$/;"	m
update_hiword	$VIRGIL/lib/math/Math.v3	/^def update_hiword(x: double, hw: int) -> double {$/;"	f
upper	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def upper = unify0(UnificationDir.UPPER, _, _);$/;"	d
upperLeftChar	$VIRGIL/lib/term/Vt100.v3	/^def upperLeftChar  = '\x6c';$/;"	d
upperRightChar	$VIRGIL/lib/term/Vt100.v3	/^def upperRightChar = '\x6b'; \/\/ 191$/;"	d
upref	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	private def upref(vreg: VReg) -> VReg {$/;"	m
usage	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var usage = Usage.NONE;$/;"	d
use	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var use: bool = false;$/;"	d
use	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def use(i: SsaInstr) {$/;"	m
use	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def use(a: SsaInstr) -> int {$/;"	m
useAddrConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useAddrConst(addr: Addr) {$/;"	m
useAll	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useAll(array: Array<SsaDfEdge>, start: int) {$/;"	m
useAt	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def useAt(v: VReg, fixed: int) -> int {$/;"	m
useCompression	$VIRGIL/aeneas/src/jvm/JARFile.v3	/^	var useCompression: bool;$/;"	d
useCount	$VIRGIL/aeneas/src/mach/MachStackifier.v3	/^	def useCount(d: Operand.Def) -> int {$/;"	m
useEnd	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var useEnd: int;$/;"	d
useEnd	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var useEnd: int;	\/\/ end index into code describing use\/def info$/;"	d
useExSource	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useExSource(ex: string, source: Source) {$/;"	m
useFixed	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useFixed(i: SsaInstr, constraint: int) {$/;"	m
useFixed	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def useFixed(a: SsaInstr, fixed: int) -> int {$/;"	m
useGlobalRegAllocMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def useGlobalRegAllocMatcher = if(CLOptions.DWARF.get(), VstMatcher.None, if(level >= 2, VstMatcher.All, CLOptions.USE_GLOBALREGALLOC.get()));$/;"	d
useImm	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useImm(val: Val) {$/;"	m
useInt	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useInt(val: int) {$/;"	m
useIntConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useIntConst(val: int) {$/;"	m
useLabel	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useLabel(block: SsaBlock) {$/;"	m
useList	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var useList: SpecEdge;$/;"	d
useList	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var useList: SsaDfEdge;		\/\/ list of uses of this instruction$/;"	d
useLongConst	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useLongConst(val: int) {$/;"	m
useMrrsd	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def useMrrsd(x: SsaInstr, y: SsaInstr, scale: byte, disp: Val) {$/;"	m
useMrrsdConstrained	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def useMrrsdConstrained(t: (SsaInstr, SsaInstr, byte, Val), constraint: int) {$/;"	m
useReg	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useReg(i: SsaInstr) {$/;"	m
useScratch	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def useScratch(regClass: RegClass) {$/;"	m
useShadowStack	$VIRGIL/aeneas/src/mach/ShadowStackSpiller.v3	/^	var useShadowStack: bool;$/;"	d
useShadowStack	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def useShadowStack = !CLOptions.WASM_GC.val && rt.shadowStackSize > 0;$/;"	d
useStart	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def useStart: int;$/;"	d
useStart	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var useStart: int;	\/\/ index into code describing use\/def info$/;"	d
useType	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def useType(u: int) -> string {$/;"	m
used	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	var used: bool;$/;"	d
used	$VIRGIL/aeneas/src/util/Label.v3	/^	def used() -> bool { return near_uses != null; }$/;"	m
uses	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def uses = gen.uses.array; \/\/ XXX dirty: internal array access$/;"	d
uses	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def uses  = Vector<int>.new();$/;"	d
usev	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def usev(vreg: VReg, constraint: int) {$/;"	m
usev0	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def usev0(vreg: VReg) {$/;"	m
usingSystem	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	var usingSystem: bool;$/;"	d
usuffix	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def usuffix: bool;$/;"	d
utf8Map	$VIRGIL/aeneas/src/jvm/JvmBuilder.v3	/^	def utf8Map: PartialMap<string, JvmCpe_Utf8> = Strings.newMap<JvmCpe_Utf8>();$/;"	d
val	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var val: Val;$/;"	d
val	$VIRGIL/aeneas/src/mach/Memory.v3	/^	def val: T;$/;"	d
val	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def val(i: SsaInstr) -> Val {$/;"	m
val	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var val: Val;$/;"	d
val	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var val: Val;$/;"	d
val	$VIRGIL/aeneas/src/x86/X86CodeGen.v3	/^	def val: Val;$/;"	d
val	$VIRGIL/lib/util/Map.v3	/^	var val: V;$/;"	d
val	$VIRGIL/lib/util/Option.v3	/^	var val: T;$/;"	d
valColor	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def valColor() -> this {$/;"	m
valConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def valConst(t: Type, v: Val) -> SsaConst {$/;"	m
valMap	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def valMap = LazyMap.new(Values.hash, Values.equal, uniquify<Val>);$/;"	d
valMoves	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var valMoves: List<(Val, int)>; \/\/ value -> usepos moves, before$/;"	d
validate	$VIRGIL/lib/util/Utf8.v3	/^	def validate(str: string) -> bool {$/;"	f
vals	$VIRGIL/aeneas/src/core/Eval.v3	/^	var vals: Range<Val>;$/;"	d
vals	$VIRGIL/lib/util/Option.v3	/^	var vals  = Vector<string>.new();$/;"	d
vals_storage	$VIRGIL/aeneas/src/core/Eval.v3	/^	var vals_storage = Array<Val>.new(16);$/;"	d
valueList	$VIRGIL/lib/util/Map.v3	/^	def valueList<K, V>(map: PartialMap<K, V>) -> List<V> {$/;"	f
valueMap	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var valueMap: HashMap<(Type, Val), int>; \/\/ XXX: make a custom hashmap for Ssa constants$/;"	d
valueMap	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var valueMap: PartialMap<Val, MatchPattern>;$/;"	d
valueNum	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	var valueNum: int = -1;		\/\/ used by SsaInterpreter$/;"	d
values	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var values: Array<SsaConst>;$/;"	d
values	$VIRGIL/aeneas/src/ssa/SsaInterpreter.v3	/^	var values = Array<Val>.new(INITIAL_VALUES);$/;"	d
valuesPos	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	var valuesPos = CACHE_SIZE;$/;"	d
varMap	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var varMap: Array<SsaInstr>;$/;"	d
varMoves	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	var varMoves: List<(int, int)>; \/\/ usepos -> defpos moves, before$/;"	d
varNum	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def varNum: int;		\/\/ virtual register number$/;"	d
varOfUse	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def varOfUse(use: int) -> VReg {$/;"	m
varRefSlotIndex	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	var varRefSlotIndex: Array<int>; \/\/ XXX: move to VReg directly?$/;"	d
varSize	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def varSize: int;		\/\/ number of virtual registers this var represents$/;"	d
varbind	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var varbind: VarBinding;$/;"	d
variantCase	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var variantCase: VstCaseMember;  \/\/ if this is a match on a variant case$/;"	d
variantDefaultCaseClass	$VIRGIL/aeneas/src/jvm/JvmGen.v3	/^	def variantDefaultCaseClass = TypeUtil.newTypeMap<IrClass>();$/;"	d
variantFields	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var variantFields: Array<VariantField>;$/;"	d
variantInterp	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var variantInterp = SsaInterpreter.new(ra.prog, null); \/\/ interpreter to normalize records$/;"	d
variantNorm	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var variantNorm: VariantNorm;		\/\/ non-null for flattened variants$/;"	d
variantTag	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var variantTag = NON_VARIANT;$/;"	d
variantType	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var variantType: ClassType;$/;"	d
variantUnboxMatcher	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def variantUnboxMatcher = if(unboxVariantsOpt != null, GlobMatcher.new(unboxVariantsOpt));$/;"	d
vars	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	def vars = codegen.vars;$/;"	d
vars	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def vars = gen.vars.array; \/\/ XXX dirty: internal array access$/;"	d
vars	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def vars = Vector<VReg>.new();$/;"	d
vars	$VIRGIL/aeneas/src/mach/OldCodeGen.v3	/^	def vars = Vector<VReg>.new();$/;"	d
vars	$VIRGIL/aeneas/src/vst/VarEnvironment.v3	/^	private var vars = Array<VarDecl>.new(INITIAL);$/;"	d
varslen	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^	var varslen: int;$/;"	d
vdecl	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var vdecl: VarDecl; \/\/ if this is a type case$/;"	d
vec	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def vec = Vector<IrSpec>.new();$/;"	d
vecO	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var vecO: Array<Type>;$/;"	d
vecO	$VIRGIL/aeneas/src/ir/VariantSolver.v3	/^	var vecO: Array<Type>;$/;"	d
verbose	$VIRGIL/aeneas/src/mach/GlobalRegAlloc.v3	/^def verbose = false;$/;"	d
verbose	$VIRGIL/aeneas/src/mach/LocalRegAlloc.v3	/^def verbose = false;$/;"	d
verified	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	var verified: bool;$/;"	d
verifier	$VIRGIL/aeneas/src/vst/MethodEnv.v3	/^	def verifier: VstCompoundVerifier;$/;"	d
verifier	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifier: Verifier;$/;"	d
verifier	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var verifier: VstCompoundVerifier;$/;"	d
verify	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def verify() -> bool {$/;"	m
verify	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def verify() {$/;"	m
verify	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def verify() {$/;"	m
verify	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verify() {$/;"	m
verify	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def verify() {$/;"	m
verifyBlock	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def verifyBlock(block: SsaBlock) {$/;"	m
verifyClass	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyClass(decl: VstClass) {$/;"	m
verifyComponent	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyComponent(decl: VstComponent) {$/;"	m
verifyEnd	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def verifyEnd(end: SsaEnd) {$/;"	m
verifyEnum	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyEnum(decl: VstEnum) {$/;"	m
verifyExport	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyExport(decl: ExportDecl) {$/;"	m
verifyFieldOverlapping	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyFieldOverlapping(decl: VstLayout) {$/;"	m
verifyInstr	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def verifyInstr(instr: SsaInstr) {$/;"	m
verifyLayout	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyLayout(decl: VstLayout) {$/;"	m
verifyLineEnds	$VIRGIL/aeneas/src/vst/ParserState.v3	/^	def verifyLineEnds() -> bool {$/;"	m
verifyLineEnds	$VIRGIL/lib/util/TextReader.v3	/^	def verifyLineEnds() -> bool {$/;"	m
verifyMain	$VIRGIL/aeneas/src/main/Compiler.v3	/^	def verifyMain(main: VstMethod, error: (FileRange, string) -> void) {$/;"	m
verifyPacking	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyPacking(decl: VstPacking) {$/;"	m
verifyPackingSize	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def verifyPackingSize(cv: VstCompoundVerifier, lit: Literal) -> byte {$/;"	m
verifyPhi	$VIRGIL/aeneas/src/ssa/SsaVerifier.v3	/^	def verifyPhi(block: SsaBlock, phi: SsaPhi) {$/;"	m
verifySwitchCmpBlock	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def verifySwitchCmpBlock(cmp: SwitchCmp, block: SsaBlock) -> bool {$/;"	m
version	$VIRGIL/aeneas/src/main/Version.v3	/^	def version: string = "III-7.1716";$/;"	d
verticalChar	$VIRGIL/lib/term/Vt100.v3	/^def verticalChar   = '\x78'; \/\/ 179$/;"	d
viewi	$VIRGIL/aeneas/src/types/Int.v3	/^	def viewi(i: int) -> int {$/;"	m
viewl	$VIRGIL/aeneas/src/types/Int.v3	/^	def viewl(l: long) -> long {$/;"	m
viewq	$VIRGIL/aeneas/src/types/Int.v3	/^	def viewq(l: u64) -> u64 {$/;"	m
viewu	$VIRGIL/aeneas/src/types/Int.v3	/^	def viewu(i: u32) -> u32 {$/;"	m
virtList	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	var virtList: List<(RaClass, List<RaMethod>)>;$/;"	d
virtMap	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def virtMap = IrUtil.newIrSpecMap<SpecMethod>();$/;"	d
virtual	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var virtual: RaVirtual;$/;"	d
virtualCalls	$VIRGIL/aeneas/src/ir/PartialSpecialization.v3	/^	def virtualCalls = Vector<IrSpec>.new();$/;"	d
virtuals	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	var virtuals: List<RaVirtual>;$/;"	d
visit	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visit(bi: SsaBlockInfo, context: CfgContext) {$/;"	m
visitApp	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitApp(expr: AppExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitApp	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitApp(expr: AppExpr, outer: Type) -> Type {$/;"	m
visitApp	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitApp(expr: AppExpr, env: E) -> R;$/;"	m
visitApp	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitApp(expr: AppExpr, indent: int) {$/;"	m
visitApply	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitApply(block: SsaBlock, i: SsaApplyOp) {$/;"	m
visitApply	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def visitApply(block: SsaBlock, i: SsaApplyOp) {$/;"	m
visitApply	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitApply(block: SsaBlock, i: SsaApplyOp);$/;"	m
visitApply	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitApply(block: SsaBlock, i: SsaApplyOp) {$/;"	m
visitApply	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def visitApply(block: SsaBlock, i: SsaApplyOp) {$/;"	m
visitArray	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitArray(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {$/;"	m
visitArray	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitArray(expr: ArrayExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitArray	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitArray(expr: ArrayExpr, outer: Type) -> Type {$/;"	m
visitArray	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitArray(expr: ArrayExpr, env: E) -> R;$/;"	m
visitArray	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitArray(expr: ArrayExpr, indent: int) {$/;"	m
visitArrayIndex	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitArrayIndex(expr: IndexExpr, arrayType: Type) -> Type {$/;"	m
visitArrayType	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def visitArrayType(rt: RaArray) {$/;"	m
visitAssign	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitAssign(expr: AssignExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitAssign	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitAssign(expr: AssignExpr, outer: Type) -> Type {$/;"	m
visitAssign	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitAssign(expr: AssignExpr, env: E) -> R;$/;"	m
visitAssign	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitAssign(expr: AssignExpr, indent: int) {$/;"	m
visitAutoExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitAutoExpr(expr: AutoExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitAutoExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitAutoExpr(expr: AutoExpr, outer: Type) -> Type {$/;"	m
visitAutoExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitAutoExpr(expr: AutoExpr, env: E) -> R;$/;"	m
visitAutoExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitAutoExpr(expr: AutoExpr, indent: int) {$/;"	m
visitBinOp	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitBinOp(expr: BinOpExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitBinOp	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitBinOp(expr: BinOpExpr, outer: Type) -> Type {$/;"	m
visitBinOp	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitBinOp(expr: BinOpExpr, env: E) -> R;$/;"	m
visitBinOp	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitBinOp(expr: BinOpExpr, indent: int) {$/;"	m
visitBitwiseNeg	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitBitwiseNeg(expr: BitwiseNegExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitBitwiseNeg	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitBitwiseNeg(expr: BitwiseNegExpr, outer: Type) -> Type {$/;"	m
visitBitwiseNeg	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitBitwiseNeg(expr: BitwiseNegExpr, env: E) -> R;$/;"	m
visitBitwiseNeg	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitBitwiseNeg(expr: BitwiseNegExpr, indent: int) {$/;"	m
visitBlock	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitBlock(stmt: BlockStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitBlock	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitBlock(stmt: BlockStmt, outer: Type) -> Type {$/;"	m
visitBlock	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitBlock(stmt: BlockStmt, env: E) -> R;$/;"	m
visitBlock	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitBlock(stmt: BlockStmt, indent: int) {$/;"	m
visitBreak	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitBreak(stmt: BreakStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitBreak	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitBreak(stmt: BreakStmt, outer: Type) -> Type {$/;"	m
visitBreak	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitBreak(stmt: BreakStmt, env: E) -> R;$/;"	m
visitBreak	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitBreak(stmt: BreakStmt, indent: int) {$/;"	m
visitCheckpoint	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitCheckpoint(x: SsaCheckpoint) {$/;"	m
visitClassType	$VIRGIL/aeneas/src/ir/Normalization.v3	/^	def visitClassType(rc: RaClass) {$/;"	m
visitCond	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitCond(apply: SsaApplyOp) -> ArmCond {$/;"	m
visitContinue	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitContinue(stmt: ContinueStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitContinue	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitContinue(stmt: ContinueStmt, outer: Type) -> Type {$/;"	m
visitContinue	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitContinue(stmt: ContinueStmt, env: E) -> R;$/;"	m
visitContinue	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitContinue(stmt: ContinueStmt, indent: int) {$/;"	m
visitDeleteVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitDeleteVar(x: SsaDeleteVar) {$/;"	m
visitEmpty	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitEmpty(stmt: EmptyStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitEmpty	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitEmpty(stmt: EmptyStmt, outer: Type) -> Type {$/;"	m
visitEmpty	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitEmpty(stmt: EmptyStmt, env: E) -> R;$/;"	m
visitEmpty	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitEmpty(stmt: EmptyStmt, indent: int) {$/;"	m
visitEntry	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitEntry(params: Array<SsaParam>) {$/;"	m
visitExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitExpr(stmt: ExprStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitExpr(stmt: ExprStmt, outer: Type) -> Type {$/;"	m
visitExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitExpr(stmt: ExprStmt, env: E) -> R;$/;"	m
visitExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitExpr(stmt: ExprStmt, indent: int) {$/;"	m
visitFor	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitFor(stmt: ForStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitFor	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitFor(stmt: ForStmt, outer: Type) -> Type {$/;"	m
visitFor	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitFor(stmt: ForStmt, env: E) -> R;$/;"	m
visitFor	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitFor(stmt: ForStmt, indent: int) {$/;"	m
visitForLess	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitForLess(stmt: ForLessStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitForLess	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitForLess(stmt: ForLessStmt, outer: Type) -> Type {$/;"	m
visitForLess	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitForLess(stmt: ForLessStmt, env: E) -> R;$/;"	m
visitForLess	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitForLess(stmt: ForLessStmt, indent: int) {$/;"	m
visitForeach	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitForeach(stmt: ForeachStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitForeach	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitForeach(stmt: ForeachStmt, outer: Type) -> Type {$/;"	m
visitForeach	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitForeach(stmt: ForeachStmt, env: E) -> R;$/;"	m
visitForeach	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitForeach(stmt: ForeachStmt, indent: int) {$/;"	m
visitFuncExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitFuncExpr(expr: FuncExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitFuncExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitFuncExpr(expr: FuncExpr, outer: Type) -> Type {$/;"	m
visitFuncExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitFuncExpr(expr: FuncExpr, env: E) -> R;$/;"	m
visitFuncExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitFuncExpr(expr: FuncExpr, indent: int) {$/;"	m
visitGoto	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitGoto(block: SsaBlock, i: SsaGoto) {$/;"	m
visitGoto	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def visitGoto(block: SsaBlock, target: SsaGoto) { context.unimplemented(); }$/;"	m
visitGoto	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitGoto(block: SsaBlock, target: SsaGoto);$/;"	m
visitGoto	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visitGoto(bi: SsaBlockInfo, end: SsaGoto, context: CfgContext) {$/;"	m
visitGoto	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitGoto(block: SsaBlock, target: SsaGoto) {$/;"	m
visitGoto	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def visitGoto(block: SsaBlock, i: SsaGoto) {$/;"	m
visitIf	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitIf(block: SsaBlock, i: SsaIf) {$/;"	m
visitIf	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def visitIf(block: SsaBlock, i: SsaIf) { context.unimplemented(); }$/;"	m
visitIf	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitIf(block: SsaBlock, i: SsaIf);$/;"	m
visitIf	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitIf(stmt: IfStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitIf	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitIf(stmt: IfStmt, outer: Type) -> Type {$/;"	m
visitIf	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitIf(stmt: IfStmt, env: E) -> R;$/;"	m
visitIf	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitIf(stmt: IfStmt, indent: int) {$/;"	m
visitIf	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visitIf(bi: SsaBlockInfo, end: SsaIf, context: CfgContext) {$/;"	m
visitIf	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitIf(block: SsaBlock, i: SsaIf) {$/;"	m
visitIf	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def visitIf(block: SsaBlock, i: SsaIf) {$/;"	m
visitIfExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitIfExpr(expr: IfExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitIfExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitIfExpr(expr: IfExpr, outer: Type) -> Type {$/;"	m
visitIfExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitIfExpr(expr: IfExpr, env: E) -> R;$/;"	m
visitIfExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitIfExpr(expr: IfExpr, indent: int) {$/;"	m
visitIndex	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitIndex(expr: IndexExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitIndex	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitIndex(expr: IndexExpr, outer: Type) -> Type {$/;"	m
visitIndex	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitIndex(expr: IndexExpr, env: E) -> R;$/;"	m
visitIndex	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitIndex(expr: IndexExpr, indent: int) {$/;"	m
visitLiteral	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitLiteral(expr: Literal, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitLiteral	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitLiteral(expr: Literal, outer: Type) -> Type {$/;"	m
visitLiteral	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitLiteral(expr: Literal, env: E) -> R;$/;"	m
visitLiteral	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitLiteral(expr: Literal, indent: int) {$/;"	m
visitLocal	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitLocal(stmt: LocalStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitLocal	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitLocal(stmt: LocalStmt, outer: Type) -> Type {$/;"	m
visitLocal	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitLocal(stmt: LocalStmt, env: E) -> R;$/;"	m
visitLocal	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitLocal(stmt: LocalStmt, indent: int) {$/;"	m
visitMatch	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitMatch(stmt: MatchStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitMatch	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitMatch(stmt: MatchStmt, outer: Type) -> Type {$/;"	m
visitMatch	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitMatch(stmt: MatchStmt, env: E) -> R;$/;"	m
visitMatch	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitMatch(stmt: MatchStmt, indent: int) {$/;"	m
visitMatchPattern	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitMatchPattern(mv: MatchStmtVerifier, pat: MatchPattern) {$/;"	m
visitNeg	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitNeg(expr: NegExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitNeg	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitNeg(expr: NegExpr, outer: Type) -> Type {$/;"	m
visitNeg	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitNeg(expr: NegExpr, env: E) -> R;$/;"	m
visitNeg	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitNeg(expr: NegExpr, indent: int) {$/;"	m
visitNewVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitNewVar(x: SsaNewVar) {$/;"	m
visitNot	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitNot(expr: NotExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitNot	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitNot(expr: NotExpr, outer: Type) -> Type {$/;"	m
visitNot	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitNot(expr: NotExpr, env: E) -> R;$/;"	m
visitNot	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitNot(expr: NotExpr, indent: int) {$/;"	m
visitObject	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitObject(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {$/;"	m
visitParamExpr	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitParamExpr(expr: ParamExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitParamExpr	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitParamExpr(expr: ParamExpr, outer: Type) -> Type {$/;"	m
visitParamExpr	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitParamExpr(expr: ParamExpr, env: E) -> R;$/;"	m
visitParamExpr	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitParamExpr(expr: ParamExpr, indent: int) {$/;"	m
visitPtrAtField	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitPtrAtField(expr: AppExpr, ptrType: Type, outer: Type) -> Type {$/;"	m
visitRRR	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitRRR(opcode: int, block: SsaBlock, i: SsaApplyOp) {$/;"	m
visitRange	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitRange(expr: RangeExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitRange	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitRange(expr: RangeExpr, outer: Type) -> Type {$/;"	m
visitRange	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitRange(expr: RangeExpr, env: E) -> R;$/;"	m
visitRange	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitRange(expr: RangeExpr, indent: int) {$/;"	m
visitRecord	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitRecord(rval: Record, etype: Type, ref: JvmHI_Ref, index: int) -> JvmHI_Record {$/;"	m
visitRepeatedIndex	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitRepeatedIndex(exprs: VstList<Expr>) {$/;"	m
visitReturn	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitReturn(block: SsaBlock, i: SsaReturn) {$/;"	m
visitReturn	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitReturn(stmt: ReturnStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitReturn	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitReturn(stmt: ReturnStmt, outer: Type) -> Type {$/;"	m
visitReturn	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitReturn(stmt: ReturnStmt, env: E) -> R;$/;"	m
visitReturn	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitReturn(stmt: ReturnStmt, indent: int) {$/;"	m
visitReturn	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visitReturn(bi: SsaBlockInfo, end: SsaReturn, context: CfgContext) {$/;"	m
visitReturn	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitReturn(block: SsaBlock, i: SsaReturn) {$/;"	m
visitShift	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitShift(regmode: int, immmode: int, i: SsaApplyOp) {$/;"	m
visitString	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitString(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {$/;"	m
visitString	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitString(expr: StringExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitString	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitString(expr: StringExpr, outer: Type) -> Type {$/;"	m
visitString	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitString(expr: StringExpr, env: E) -> R;$/;"	m
visitString	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitString(expr: StringExpr, indent: int) {$/;"	m
visitSwitch	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitSwitch(block: SsaBlock, i: SsaSwitch) {$/;"	m
visitSwitch	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def visitSwitch(block: SsaBlock, i: SsaSwitch) { context.unimplemented(); }$/;"	m
visitSwitch	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitSwitch(block: SsaBlock, i: SsaSwitch);$/;"	m
visitSwitch	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visitSwitch(bi: SsaBlockInfo, end: SsaSwitch, context: CfgContext) {$/;"	m
visitSwitch	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitSwitch(block: SsaBlock, i: SsaSwitch) {$/;"	m
visitSwitch	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def visitSwitch(block: SsaBlock, i: SsaSwitch) {$/;"	m
visitThrow	$VIRGIL/aeneas/src/arm/ArmBackend.v3	/^	def visitThrow(block: SsaBlock, i: SsaThrow) {$/;"	m
visitThrow	$VIRGIL/aeneas/src/arm64/SsaArm64Gen.v3	/^	def visitThrow(block: SsaBlock, i: SsaThrow) { context.unimplemented(); }$/;"	m
visitThrow	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitThrow(block: SsaBlock, i: SsaThrow);$/;"	m
visitThrow	$VIRGIL/aeneas/src/wasm/CfgRestructurer.v3	/^	def visitThrow(bi: SsaBlockInfo, end: SsaThrow, context: CfgContext) {$/;"	m
visitThrow	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def visitThrow(block: SsaBlock, i: SsaThrow) {$/;"	m
visitThrow	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def visitThrow(block: SsaBlock, i: SsaThrow) {$/;"	m
visitTuple	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitTuple(expr: TupleExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitTuple	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitTuple(expr: TupleExpr, outer: Type) -> Type {$/;"	m
visitTuple	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitTuple(expr: TupleExpr, env: E) -> R;$/;"	m
visitTuple	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitTuple(expr: TupleExpr, indent: int) {$/;"	m
visitUpdateVar	$VIRGIL/aeneas/src/mach/MachBackend.v3	/^	def visitUpdateVar(x: SsaUpdateVar) {$/;"	m
visitUselessArray	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitUselessArray(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {$/;"	m
visitValue	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def visitValue(val: Val, etype: Type, ref: JvmHI_Ref, index: int) {$/;"	m
visitVar	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitVar(expr: VarExpr, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitVar	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitVar(expr: VarExpr, outer: Type) -> Type {$/;"	m
visitVar	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitVar(expr: VarExpr, env: E) -> R;$/;"	m
visitVar	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitVar(expr: VarExpr, indent: int) {$/;"	m
visitWhile	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	def visitWhile(stmt: WhileStmt, env: VstSsaEnv) -> SsaInstr {$/;"	m
visitWhile	$VIRGIL/aeneas/src/vst/Verifier.v3	/^	def visitWhile(stmt: WhileStmt, outer: Type) -> Type {$/;"	m
visitWhile	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def visitWhile(stmt: WhileStmt, env: E) -> R;$/;"	m
visitWhile	$VIRGIL/aeneas/src/vst/VstPrinter.v3	/^	def visitWhile(stmt: WhileStmt, indent: int) {$/;"	m
vmaddr	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var vmaddr: int;$/;"	d
vmsize	$VIRGIL/aeneas/src/exe/MachO.v3	/^	var vmsize: int;$/;"	d
vnum	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	var vnum: int;$/;"	d
voidArrayType	$VIRGIL/aeneas/src/v3/V3.v3	/^	def voidArrayType   = V3Array.newType(Void.TYPE);$/;"	d
voidReg	$VIRGIL/aeneas/src/ic/Ic.v3	/^	var voidReg: u31;$/;"	d
vreg	$VIRGIL/aeneas/src/mach/LinearScanRegAlloc.v3	/^	def vreg: VReg;$/;"	d
vst	$VIRGIL/aeneas/src/core/Program.v3	/^	var vst: VstModule;$/;"	d
vtype	$VIRGIL/aeneas/src/debug/Dwarf.v3	/^	def vtype: Type;$/;"	d
vtype	$VIRGIL/aeneas/src/ssa/Ssa.v3	/^	def vtype: Type;$/;"	d
vtype	$VIRGIL/aeneas/src/types/Type.v3	/^	var vtype: Type;$/;"	d
vtype	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var vtype: Type;$/;"	d
vtype	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var vtype: Type;$/;"	d
wasExecuted	$VIRGIL/aeneas/src/ic/IcCoverage.v3	/^	def wasExecuted(icm: IcMethod, ip: int) -> bool {$/;"	m
wasm	$VIRGIL/aeneas/src/wasm/WasmCodeGen.v3	/^	def wasm: WasmProgram;$/;"	d
wasmOpt	$VIRGIL/aeneas/src/main/CLOptions.v3	/^	def wasmOpt = OptionGroup.new("WASM TARGET", options);$/;"	d
wasmType	$VIRGIL/aeneas/src/wasm/WasmTarget.v3	/^	def wasmType(t: Type) -> WasmType {$/;"	m
wdiv	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def wdiv(op: WideDivision, source: Source) {$/;"	m
wdiv_full	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def wdiv_full(op: WideDivision, source: Source, stub: bool) {$/;"	m
where	$VIRGIL/aeneas/src/ssa/SsaContext.v3	/^	def where() -> StringBuilder {$/;"	m
wide	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var wide: bool;		\/\/ true if this is a long int operation$/;"	d
wideConsts	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def wideConsts(tn: TypeNorm, v: SsaConst) -> Array<SsaInstr> {$/;"	m
wideInputs	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def wideInputs(op: Operator, tn: TypeNorm, inputs: Array<SsaInstr>, facts: Fact.set) -> SsaInstr {$/;"	m
wideOutputs	$VIRGIL/aeneas/src/mach/MachLowering.v3	/^	def wideOutputs(op: Operator, tn: TypeNorm, inputs: Array<SsaInstr>, facts: Fact.set) -> Array<SsaInstr> {$/;"	m
widen	$VIRGIL/aeneas/src/v3/TypeSystem.v3	/^	def widen = unify0(UnificationDir.WIDER, _, _);$/;"	d
widen	$VIRGIL/lib/util/BitMatrix.v3	/^	def widen(ncols: int) -> this {$/;"	m
wider	$VIRGIL/aeneas/src/types/Int.v3	/^	def wider(rtype: Type) -> IntType {$/;"	m
widerUnsigned	$VIRGIL/aeneas/src/types/Int.v3	/^	def widerUnsigned(rtype: Type) -> IntType {$/;"	m
width	$VIRGIL/aeneas/src/mach/Pointer.v3	/^	def width: byte;$/;"	d
width	$VIRGIL/aeneas/src/types/Int.v3	/^	def width: byte;  \/\/ width in bits (1-64)$/;"	d
width	$VIRGIL/aeneas/src/vst/NumberParser.v3	/^	var width: byte;$/;"	d
width	$VIRGIL/lib/util/BitMatrix.v3	/^	private var width: int = (numcols + 31) >>> 5;      \/\/ width (in integers) of each row$/;"	d
word	$VIRGIL/aeneas/src/ir/IntNormalizer.v3	/^	def word = Int.getType(false, width);$/;"	d
words	$VIRGIL/aeneas/src/vst/FpSketch.v3	/^	var words = Array<u32>.new(1); \/\/ base 2^32 digits.$/;"	d
wrfsbase	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def wrfsbase(a: X86_64Gpr) -> this { emitb(0xF3); emit_rex_bb_r(a, OP_REX, 0x0F, 0xAE, 0b010); }$/;"	m
wrgsbase	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def wrgsbase(a: X86_64Gpr) -> this { emitb(0xF3); emit_rex_bb_r(a, OP_REX, 0x0F, 0xAE, 0b011); }$/;"	m
writability	$VIRGIL/aeneas/src/vst/Vst.v3	/^	def writability: Writability;$/;"	d
write	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def write(bigEndian: bool, offset: int, count: int, val: u64) {$/;"	m
write	$VIRGIL/aeneas/src/v3/SystemModule.v3	/^	def write(args: Arguments) -> Result {$/;"	m
write	$VIRGIL/aeneas/src/vst/Vst.v3	/^	var write: AppBinding;$/;"	d
write	$VIRGIL/rt/x86-64-darwin/System.v3	/^	def write(fd: int, data: Range<byte>) -> int {$/;"	f
writeFacts	$VIRGIL/aeneas/src/ir/Reachability.v3	/^	var writeFacts = Facts.V_FACTS;$/;"	d
writeField	$VIRGIL/aeneas/src/jvm/JvmHeap.v3	/^	def writeField(heap: JvmHeap, code: JvmCodeBuilder, jtype: JvmType) {$/;"	m
writeFlags	$VIRGIL/aeneas/src/ssa/VstSsaGen.v3	/^	var writeFlags: int;$/;"	d
write_range_double	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_double(r: Range<byte>, val: double)	{ Ref<Layout_double>.of(r).val = val; }$/;"	f
write_range_float	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_float(r: Range<byte>, val: float)	{ Ref<Layout_float>.of(r).val = val; }$/;"	f
write_range_i16	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_i16(r: Range<byte>, val: i16)		{ Ref<Layout_i16>.of(r).val = val; }$/;"	f
write_range_i32	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_i32(r: Range<byte>, val: i32)		{ Ref<Layout_i32>.of(r).val = val; }$/;"	f
write_range_i64	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_i64(r: Range<byte>, val: i64)		{ Ref<Layout_i64>.of(r).val = val; }$/;"	f
write_range_i8	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_i8(r: Range<byte>, val: i8)		{ Ref<Layout_i8>.of(r).val = val; }$/;"	f
write_range_u128	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_u128(r: Range<byte>, val: (u64, u64)) {$/;"	f
write_range_u16	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_u16(r: Range<byte>, val: u16)		{ Ref<Layout_u16>.of(r).val = val; }$/;"	f
write_range_u32	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_u32(r: Range<byte>, val: u32)		{ Ref<Layout_u32>.of(r).val = val; }$/;"	f
write_range_u64	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_u64(r: Range<byte>, val: u64)		{ Ref<Layout_u64>.of(r).val = val; }$/;"	f
write_range_u8	$VIRGIL/lib/util/DataWriter.v3	/^	def write_range_u8(r: Range<byte>, val: u8)		{ Ref<Layout_u8>.of(r).val = val; }$/;"	f
writeable	$VIRGIL/aeneas/src/v3/Ref.v3	/^	def writeable: bool;$/;"	d
writeable	$VIRGIL/aeneas/src/v3/V3Array.v3	/^	def writeable: bool;$/;"	d
writeable	$VIRGIL/aeneas/src/v3/V3Range.v3	/^	def writeable: bool;$/;"	d
writer	$VIRGIL/lib/util/IO.v3	/^	private var writer: DataWriter;$/;"	d
wsh	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def wsh(asm: X86MacroAssembler, rdl: X86Reg, rdh: X86Reg, sh: X86Rm) {$/;"	m
wsh_adjust	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	private def wsh_adjust(asm: X86MacroAssembler, rdl: X86Reg, rdh: X86Reg) {$/;"	m
wsh_cl	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^	def wsh_cl(asm: X86MacroAssembler, rdl: X86Reg, rdh: X86Reg) {$/;"	m
x86codegen	$VIRGIL/aeneas/src/x86-64/SsaX86_64Gen.v3	/^	def x86codegen: SsaX86_64Gen;$/;"	d
xadd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def xadd(a: X86Rm, b: X86Reg) {$/;"	m
xadd_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xadd_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
xadd_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xadd_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
xchg	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def xchg(a: X86Rm, b: X86Reg) {$/;"	m
xchg_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xchg_m_r(a: X86_64Addr, b: X86_64Gpr) -> this {$/;"	m
xchg_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xchg_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this {$/;"	m
xconst	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var xconst: bool;	\/\/ true if {x} is a constant$/;"	d
xf2i	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def xf2i(isDouble: bool) {$/;"	m
xf2l	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def xf2l(isDouble: bool) {$/;"	m
xfzero	$VIRGIL/aeneas/src/jvm/SsaJvmGen.v3	/^	def xfzero(isDouble: bool) {$/;"	m
xint	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var xint: int;		\/\/ if {x} is an int constant, then its value$/;"	d
xlong	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var xlong: long;	\/\/ if {x} is a long constant, then its value$/;"	d
xmm	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private def xmm(name: string, r: X86_64Xmmr, allocatable: bool) -> byte {$/;"	f
xmm0	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm0 = X86Regs.XMM0;$/;"	d
xmm1	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm1 = X86Regs.XMM1;$/;"	d
xmm2	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm2 = X86Regs.XMM2;$/;"	d
xmm3	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm3 = X86Regs.XMM3;$/;"	d
xmm4	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm4 = X86Regs.XMM4;$/;"	d
xmm5	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm5 = X86Regs.XMM5;$/;"	d
xmm6	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm6 = X86Regs.XMM6;$/;"	d
xmm7	$VIRGIL/aeneas/src/x86/X86MacroAssembler.v3	/^def xmm7 = X86Regs.XMM7;$/;"	d
xmm_start	$VIRGIL/aeneas/src/x86-64/X86_64RegSet.v3	/^	private var xmm_start = cursor;$/;"	d
xor	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def xor(rd: MipsReg, rs: MipsReg, rt: MipsReg)  { emit_r3(0x00000026, rd, rs, rt); }$/;"	m
xor	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	var xor: X86Op2;$/;"	d
xor_m_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xor_m_i(a: X86_64Addr, i: int) -> this    { emitop2_m_i(a, i, OP_REX, 6); }$/;"	m
xor_m_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xor_m_r(a: X86_64Addr, b: X86_64Gpr) -> this { emitop2_m_r(a, b, OP_REX, 6); }$/;"	m
xor_r_i	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xor_r_i(a: X86_64Gpr, i: int) -> this     { emitop2_r_i(a, i, OP_REX, 6); }$/;"	m
xor_r_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xor_r_m(a: X86_64Gpr, b: X86_64Addr) -> this { emitop2_r_m(a, b, OP_REX, 6); }$/;"	m
xor_r_r	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xor_r_r(a: X86_64Gpr, b: X86_64Gpr) -> this  { emitop2_r_r(a, b, OP_REX, 6); }$/;"	m
xori	$VIRGIL/lib/asm/mips/MipsAssembler.v3	/^	def xori(rd: MipsReg, rs: MipsReg, imm: u16)    { emit_r2i(0x38000000, rd, rs, imm); }$/;"	m
xorpd	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def xorpd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x57, a, b); }$/;"	m
xorpd_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xorpd_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
xorpd_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xorpd_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
xorps	$VIRGIL/lib/asm/x86/X86Assembler.v3	/^	def xorps(a: SSEReg, b: SSERm) { emitbb_s_sm(0x0F, 0x57, a, b); }$/;"	m
xorps_s_m	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xorps_s_m(a: X86_64Xmmr, b: X86_64Addr) -> this {$/;"	m
xorps_s_s	$VIRGIL/lib/asm/x86-64/X86_64Assembler.v3	/^	def xorps_s_s(a: X86_64Xmmr, b: X86_64Xmmr) -> this {$/;"	m
xval	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var xval: Val;		\/\/ if {x} is a constant, then its value$/;"	d
yconst	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var yconst: bool;	\/\/ true if {y} is a constant$/;"	d
yellow	$VIRGIL/aeneas/src/util/Terminal.v3	/^	def yellow<T>(fmt: string, a: T) { color(CTRL_YELLOW, fmt, a); }$/;"	f
yint	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var yint: int;		\/\/ if {y} is an int constant, then its value$/;"	d
yis	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def yis(val: int) -> bool {$/;"	m
yisPowerOf2	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def yisPowerOf2() -> bool {$/;"	m
ylog2	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def ylog2() -> int {$/;"	m
ylong	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var ylong: long;	\/\/ if {y} is a long constant, then its value$/;"	d
yrange	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	def yrange(min: int, max: int) -> bool {$/;"	m
yval	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var yval: Val;		\/\/ if {y} is a constant, then its value$/;"	d
yzero	$VIRGIL/aeneas/src/ssa/SsaOptimizer.v3	/^	var yzero: bool;        \/\/ true if {y} is zero$/;"	d
zero	$VIRGIL/aeneas/src/main/Aeneas.v3	/^	def zero<T>(v: T) -> int {$/;"	f
zeroConst	$VIRGIL/aeneas/src/ssa/SsaGraph.v3	/^	def zeroConst() -> SsaConst {$/;"	m
zeroExtendSignedByte	$VIRGIL/aeneas/src/jvm/JvmRep.v3	/^	def zeroExtendSignedByte(t: Type, code: JvmCodeBuilder) {$/;"	m
zeroN	$VIRGIL/lib/util/DataWriter.v3	/^	def zeroN(length: int) -> this {$/;"	m
