EOF	$HARELIB/debug/dwarf/info.ha	/^export fn debug_info_next(di: *debug_info_reader) (entry | io::EOF) = {$/;"	f
EOF	$HARELIB/encoding/asn1/decoder.ha	/^export fn trypeek(d: *decoder) (head | error | io::EOF) = {$/;"	f
EOF	$HARELIB/format/ini/scan.ha	/^export fn next(sc: *scanner) (entry | io::EOF | error) = {$/;"	f
EOF	$HARELIB/format/tar/reader.ha	/^export fn next(rd: *reader) (entry | error | io::EOF) = {$/;"	f
EOF	$HARELIB/io/types.ha	/^export type EOF = void;$/;"	t
EOF	$HARELIB/memio/stream.ha	/^export fn borrowedread(st: *stream, amt: size) ([]u8 | io::EOF) = {$/;"	f
_enum	$HARELIB/hare/types/types.ha	/^export type _enum = struct {$/;"	t
_io_uring_cqe	$HARELIB/rt/+linux/types.ha	/^export type _io_uring_cqe = struct {$/;"	t
_main	$HARELIB/rt/+openbsd/start+test.ha	/^export @symbol("main") fn _main() void = {$/;"	f
_main	$HARELIB/rt/+openbsd/start.ha	/^export @symbol("main") fn _main() void = {$/;"	f
_null	$HARELIB/hare/ast/expr.ha	/^export type _null = void;$/;"	t
_return	$HARELIB/hare/unit/expr.ha	/^export type _return = nullable *expr;$/;"	t
_struct	$HARELIB/hare/types/types.ha	/^export type _struct = struct {$/;"	t
_type	$HARELIB/hare/ast/type.ha	/^export type _type = struct {$/;"	t
_type	$HARELIB/hare/parse/type.ha	/^export fn _type(lexer: *lex::lexer) (ast::_type | error) = {$/;"	f
_type	$HARELIB/hare/types/types.ha	/^export type _type = struct {$/;"	t
_type	$HARELIB/hare/unparse/type.ha	/^export fn _type($/;"	f
aaaa	$HARELIB/net/dns/types.ha	/^export type aaaa = ip::addr6;$/;"	t
abbrev	$HARELIB/debug/dwarf/abbrev.ha	/^export type abbrev = struct {$/;"	t
abbrev_table	$HARELIB/debug/dwarf/abbrev.ha	/^export type abbrev_table = struct {$/;"	t
abbrev_table_finish	$HARELIB/debug/dwarf/abbrev.ha	/^export fn abbrev_table_finish(table: *abbrev_table) void = {$/;"	f
abort_fixed	$HARELIB/rt/abort+test.ha	/^export fn abort_fixed(path: *str, line: u64, col: u64, i: u64) void = {$/;"	f
abort_fixed	$HARELIB/rt/abort.ha	/^export fn abort_fixed(path: *str, line: u64, col: u64, i: u64) void = {$/;"	f
abort_handler	$HARELIB/rt/abort+test.ha	/^export type abort_handler = fn($/;"	t
abort_handler	$HARELIB/rt/abort.ha	/^export type abort_handler = fn($/;"	t
abort_reason	$HARELIB/rt/abort+test.ha	/^export type abort_reason = struct {$/;"	t
abs	$HARELIB/path/buffer.ha	/^export fn abs(path: (*buffer | str)) bool = match (path) {$/;"	f
abs	$HARELIB/time/date/period.ha	/^export fn abs(p: period) period = period {$/;"	f
absc128	$HARELIB/math/complex/complex.ha	/^export fn absc128(z: c128) f64 = math::hypotf64(z.0, z.1);$/;"	f
absf	$HARELIB/math/floats.ha	/^export fn absf(n: types::floating) f64 = {$/;"	f
absf32	$HARELIB/math/floats.ha	/^export fn absf32(n: f32) f32 = {$/;"	f
absf64	$HARELIB/math/floats.ha	/^export fn absf64(n: f64) f64 = {$/;"	f
absi	$HARELIB/math/ints.ha	/^export fn absi(n: types::signed) u64 = {$/;"	f
absi16	$HARELIB/math/ints.ha	/^export fn absi16(n: i16) u16 = {$/;"	f
absi32	$HARELIB/math/ints.ha	/^export fn absi32(n: i32) u32 = {$/;"	f
absi64	$HARELIB/math/ints.ha	/^export fn absi64(n: i64) u64 = {$/;"	f
absi8	$HARELIB/math/ints.ha	/^export fn absi8(n: i8) u8 = {$/;"	f
accept	$HARELIB/net/+darwin.ha	/^export fn accept(sock: socket, flags: sockflag...) (socket | error) = {$/;"	f
accept	$HARELIB/net/+freebsd.ha	/^export fn accept(sock: socket, flags: sockflag...) (socket | error) = {$/;"	f
accept	$HARELIB/net/+linux.ha	/^export fn accept(sock: socket, flags: sockflag...) (socket | error) = {$/;"	f
accept	$HARELIB/net/+openbsd.ha	/^export fn accept(sock: socket, flags: sockflag...) (socket | error) = {$/;"	f
accept	$HARELIB/net/tcp/listener.ha	/^export fn accept($/;"	f
accept	$HARELIB/net/unix/listener.ha	/^export fn accept($/;"	f
accept	$HARELIB/rt/+darwin/syscalls.ha	/^export fn accept(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errno) = /;"	f
accept	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn accept(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errno) = /;"	f
accept	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn accept(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errno) = /;"	f
accept	$HARELIB/rt/+linux/syscalls.ha	/^export fn accept(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errno) = /;"	f
accept4	$HARELIB/rt/+darwin/syscalls.ha	/^export fn accept4(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32, flags: int) (in/;"	f
accept4	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn accept4(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32, flags: int) (in/;"	f
accept4	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn accept4(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32, flags: int) (in/;"	f
accept4	$HARELIB/rt/+linux/syscalls.ha	/^export fn accept4(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32, flags: int) (in/;"	f
accept4	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn accept4($/;"	f
access	$HARELIB/hare/unit/expr.ha	/^export type access = (access_object | access_field | access_index | access_tuple);$/;"	t
access	$HARELIB/os/+darwin/fs.ha	/^export fn access(path: str, mode: amode) (bool | fs::error) = {$/;"	f
access	$HARELIB/os/+freebsd/fs.ha	/^export fn access(path: str, mode: amode) (bool | fs::error) = {$/;"	f
access	$HARELIB/os/+linux/fs.ha	/^export fn access(path: str, mode: amode) (bool | fs::error) = {$/;"	f
access	$HARELIB/os/+openbsd/fs.ha	/^export fn access(path: str, mode: amode) (bool | fs::error) = {$/;"	f
access	$HARELIB/rt/+darwin/syscalls.ha	/^export fn access(path: path, mode: int) (bool | errno) =$/;"	f
access	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn access(path: path, mode: int) (bool | errno) =$/;"	f
access	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn access(path: path, mode: int) (bool | errno) =$/;"	f
access	$HARELIB/rt/+linux/syscalls.ha	/^export fn access(path: path, mode: int) (bool | errno) =$/;"	f
access	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn access(path: path, amode: int) (bool | errno) = {$/;"	f
access_expr	$HARELIB/hare/ast/expr.ha	/^export type access_expr = (access_identifier | access_index | access_field$/;"	t
access_field	$HARELIB/hare/ast/expr.ha	/^export type access_field = struct {$/;"	t
access_field	$HARELIB/hare/unit/expr.ha	/^export type access_field = struct {$/;"	t
access_identifier	$HARELIB/hare/ast/expr.ha	/^export type access_identifier = ident;$/;"	t
access_index	$HARELIB/hare/ast/expr.ha	/^export type access_index = struct {$/;"	t
access_index	$HARELIB/hare/unit/expr.ha	/^export type access_index = struct {$/;"	t
access_object	$HARELIB/hare/unit/expr.ha	/^export type access_object = *object;$/;"	t
access_tuple	$HARELIB/hare/ast/expr.ha	/^export type access_tuple = struct {$/;"	t
access_tuple	$HARELIB/hare/unit/expr.ha	/^export type access_tuple = struct {$/;"	t
acosc128	$HARELIB/math/complex/complex.ha	/^export fn acosc128(z: c128) c128 = {$/;"	f
acosf64	$HARELIB/math/trig.ha	/^export fn acosf64(x: f64) f64 = {$/;"	f
acoshc128	$HARELIB/math/complex/complex.ha	/^export fn acoshc128(z: c128) c128 = {$/;"	f
acoshf64	$HARELIB/math/trig.ha	/^export fn acoshf64(x: f64) f64 = {$/;"	f
add	$HARELIB/crypto/bigint/arithm.ha	/^export fn add(a: []word, b: const []word, ctl: u32) u32 = {$/;"	f
add	$HARELIB/time/arithm.ha	/^export fn add(i: instant, x: duration) instant = {$/;"	f
add	$HARELIB/time/chrono/arithmetic.ha	/^export fn add(m: *moment, x: time::duration) moment = {$/;"	f
add	$HARELIB/time/date/tarithm.ha	/^export fn add(d: date, x: time::duration) date = {$/;"	f
add_key	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn add_key($/;"	f
add_key	$HARELIB/rt/+linux/syscalls.ha	/^export fn add_key($/;"	f
addc128	$HARELIB/math/complex/complex.ha	/^export fn addc128(a: c128, b: c128) c128 = (a.0 + b.0, a.1 + b.1);$/;"	f
addc64	$HARELIB/math/complex/complex.ha	/^export fn addc64(a: c64, b: c64) c64 = (a.0 + b.0, a.1 + b.1);$/;"	f
addcontrol	$HARELIB/net/msg.ha	/^export fn addcontrol($/;"	f
addfile	$HARELIB/os/exec/cmd.ha	/^export fn addfile($/;"	f
addfiles	$HARELIB/net/unix/cmsg.ha	/^export fn addfiles(buf: *net::msghdr, files: io::file...) void = {$/;"	f
addi16	$HARELIB/math/checked/checked.ha	/^export fn addi16(a: i16, b: i16) (i16, bool) = {$/;"	f
addi32	$HARELIB/math/checked/checked.ha	/^export fn addi32(a: i32, b: i32) (i32, bool) = {$/;"	f
addi64	$HARELIB/math/checked/checked.ha	/^export fn addi64(a: i64, b: i64) (i64, bool) = {$/;"	f
addi8	$HARELIB/math/checked/checked.ha	/^export fn addi8(a: i8, b: i8) (i8, bool) = {$/;"	f
addr	$HARELIB/net/dns/query.ha	/^export fn query(query: *message, servers: ip::addr...) (*message | error) = {$/;"	f
addr	$HARELIB/net/ip/ip.ha	/^export type addr = (addr4 | addr6);$/;"	t
addr	$HARELIB/net/tcp/+darwin.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
addr	$HARELIB/net/tcp/+freebsd.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
addr	$HARELIB/net/tcp/+linux.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
addr	$HARELIB/net/tcp/+openbsd.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
addr	$HARELIB/net/unix/addr.ha	/^export type addr = str;$/;"	t
addr	$HARELIB/unix/hosts/hosts.ha	/^export fn lookup(name: const str) ([]ip::addr | error) = {$/;"	f
addr	$HARELIB/unix/resolvconf/load.ha	/^export fn load() []ip::addr = {$/;"	f
addr4	$HARELIB/net/ip/ip.ha	/^export type addr4 = [4]u8;$/;"	t
addr6	$HARELIB/net/ip/ip.ha	/^export type addr6 = [16]u8;$/;"	t
addr_to_line	$HARELIB/debug/dwarf/addr_to_line.ha	/^export fn addr_to_line($/;"	f
addu	$HARELIB/math/uints.ha	/^export fn addu(x: uint, y: uint, carry: uint) (uint, uint) = {$/;"	f
addu16	$HARELIB/math/checked/checked.ha	/^export fn addu16(a: u16, b: u16) (u16, bool) = {$/;"	f
addu32	$HARELIB/math/checked/checked.ha	/^export fn addu32(a: u32, b: u32) (u32, bool) = {$/;"	f
addu32	$HARELIB/math/uints.ha	/^export fn addu32(x: u32, y: u32, carry: u32) (u32, u32) = {$/;"	f
addu64	$HARELIB/math/checked/checked.ha	/^export fn addu64(a: u64, b: u64) (u64, bool) = {$/;"	f
addu64	$HARELIB/math/uints.ha	/^export fn addu64(x: u64, y: u64, carry: u64) (u64, u64) = {$/;"	f
addu8	$HARELIB/math/checked/checked.ha	/^export fn addu8(a: u8, b: u8) (u8, bool) = {$/;"	f
addvector	$HARELIB/net/msg.ha	/^export fn addvector(msg: *msghdr, vec: []u8) void = {$/;"	f
adler32	$HARELIB/hash/adler32/adler32.ha	/^export fn adler32() state = state {$/;"	f
aes	$HARELIB/crypto/aes/block.ha	/^export fn aes() block = block {$/;"	f
afield	$HARELIB/debug/dwarf/abbrev.ha	/^export type afield = struct {$/;"	t
again	$HARELIB/errors/common.ha	/^export type again = !void;$/;"	t
alarm	$HARELIB/rt/+linux/+x86_64.ha	/^export fn alarm(seconds: uint) uint = {$/;"	f
alias	$HARELIB/hare/types/types.ha	/^export type alias = struct {$/;"	t
alias_type	$HARELIB/hare/ast/type.ha	/^export type alias_type = struct {$/;"	t
align_expr	$HARELIB/hare/ast/expr.ha	/^export type align_expr = *_type;$/;"	t
alignment	$HARELIB/fmt/iter.ha	/^export type alignment = enum {$/;"	t
alloc_expr	$HARELIB/hare/ast/expr.ha	/^export type alloc_expr = struct {$/;"	t
alloc_form	$HARELIB/hare/ast/expr.ha	/^export type alloc_form = enum {$/;"	t
allocfiles	$HARELIB/net/unix/cmsg.ha	/^export fn allocfiles(buf: *net::msghdr, nfile: size) void = {$/;"	f
amode	$HARELIB/os/+darwin/fs.ha	/^export type amode = enum int {$/;"	t
amode	$HARELIB/os/+freebsd/fs.ha	/^export type amode = enum int {$/;"	t
amode	$HARELIB/os/+linux/fs.ha	/^export type amode = enum int {$/;"	t
amode	$HARELIB/os/+openbsd/fs.ha	/^export type amode = enum int {$/;"	t
analytical	$HARELIB/time/chrono/timescale.ha	/^export type analytical = ![]time::instant;$/;"	t
append_expr	$HARELIB/hare/ast/expr.ha	/^export type append_expr = struct {$/;"	t
appendrune	$HARELIB/memio/ops.ha	/^export fn appendrune(out: io::handle, r: rune) (size | io::error) =$/;"	f
arange_lookup	$HARELIB/debug/dwarf/aranges.ha	/^export fn arange_lookup($/;"	f
arch	$HARELIB/hare/types/arch.ha	/^export type arch = struct {$/;"	t
arch	$HARELIB/os/environ.ha	/^export type arch = enum {$/;"	t
arch_jmpbuf	$HARELIB/rt/+aarch64/arch_jmp.ha	/^export type arch_jmpbuf = [22]u64;$/;"	t
arch_jmpbuf	$HARELIB/rt/+riscv64/arch_jmp.ha	/^export type arch_jmpbuf = [26]u64;$/;"	t
arch_jmpbuf	$HARELIB/rt/+x86_64/arch_jmp.ha	/^export type arch_jmpbuf = [8]u64;$/;"	t
arch_name	$HARELIB/os/environ.ha	/^export fn arch_name(arch: arch) const str = {$/;"	f
architecture	$HARELIB/os/+darwin/platform_environ.ha	/^export fn architecture() arch = {$/;"	f
architecture	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn architecture() arch = {$/;"	f
architecture	$HARELIB/os/+linux/platform_environ.ha	/^export fn architecture() arch = {$/;"	f
architecture	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn architecture() arch = {$/;"	f
argc128	$HARELIB/math/complex/complex.ha	/^export fn argc128(z: c128) f64 = math::atan2f64(z.1, z.0);$/;"	f
argon2d	$HARELIB/crypto/argon2/argon2.ha	/^export fn argon2d($/;"	f
argon2i	$HARELIB/crypto/argon2/argon2.ha	/^export fn argon2i($/;"	f
argon2id	$HARELIB/crypto/argon2/argon2.ha	/^export fn argon2id($/;"	f
array	$HARELIB/hare/types/types.ha	/^export type array = struct {$/;"	t
array_literal	$HARELIB/hare/ast/expr.ha	/^export type array_literal = struct {$/;"	t
asformat	$HARELIB/time/date/format.ha	/^export fn asformat(layout: str, d: *date) (str | io::error) = {$/;"	f
asinc128	$HARELIB/math/complex/complex.ha	/^export fn asinc128(z: c128) c128 = {$/;"	f
asinf64	$HARELIB/math/trig.ha	/^export fn asinf64(x: f64) f64 = {$/;"	f
asinhc128	$HARELIB/math/complex/complex.ha	/^export fn asinhc128(z: c128) c128 = {$/;"	f
asinhf64	$HARELIB/math/trig.ha	/^export fn asinhf64(x: f64) f64 = {$/;"	f
asprint	$HARELIB/fmt/wrappers.ha	/^export fn asprint(args: formattable...) str = {$/;"	f
asprintf	$HARELIB/fmt/wrappers.ha	/^export fn asprintf(fmt: str, args: field...) str = {$/;"	f
assert_expr	$HARELIB/hare/ast/expr.ha	/^export type assert_expr = struct {$/;"	t
assign_expr	$HARELIB/hare/ast/expr.ha	/^export type assign_expr = struct {$/;"	t
atan2f64	$HARELIB/math/trig.ha	/^export fn atan2f64(y: f64, x: f64) f64 = {$/;"	f
atanc128	$HARELIB/math/complex/complex.ha	/^export fn atanc128(x: c128) c128 = {$/;"	f
atanf64	$HARELIB/math/trig.ha	/^export fn atanf64(x: f64) f64 = {$/;"	f
atanhc128	$HARELIB/math/complex/complex.ha	/^export fn atanhc128(x: c128) c128 = {$/;"	f
atanhf64	$HARELIB/math/trig.ha	/^export fn atanhf64(x: f64) f64 = {$/;"	f
auxv64	$HARELIB/format/elf/types.ha	/^export type auxv64 = struct {$/;"	t
b64stream	$HARELIB/encoding/pem/pem.ha	/^export type b64stream = struct {$/;"	t
backlog	$HARELIB/net/tcp/options.ha	/^export type backlog = u32;$/;"	t
backlog	$HARELIB/net/unix/options.ha	/^export type backlog = u32;$/;"	t
bad_key	$HARELIB/net/dns/error.ha	/^export type bad_key = !void;$/;"	t
bad_sig	$HARELIB/net/dns/error.ha	/^export type bad_sig = !void;$/;"	t
bad_time	$HARELIB/net/dns/error.ha	/^export type bad_time = !void;$/;"	t
badformat	$HARELIB/encoding/asn1/errors.ha	/^export type badformat = !void;$/;"	t
badsig	$HARELIB/crypto/rsa/errors.ha	/^export type badsig = !void;$/;"	t
bar	$HARELIB/hare/parse/+test/types.ha	/^export type bar = union {$/;"	t
bar	$HARELIB/hare/parse/+test/unit_test.ha	/^	roundtrip("export type foo::bar = *int, baz = const void;\\n\\n"$/;"	t
base	$HARELIB/strconv/types.ha	/^export type base = enum uint {$/;"	t
basename	$HARELIB/path/posix.ha	/^export fn basename(path: const str) const str = {$/;"	f
bat	$HARELIB/hare/parse/+test/types.ha	/^export type bat = [void]int;$/;"	t
baz	$HARELIB/hare/parse/+test/types.ha	/^export type baz = struct {$/;"	t
begetu16	$HARELIB/endian/big.ha	/^export fn begetu16(buf: []u8) u16 = {$/;"	f
begetu32	$HARELIB/endian/big.ha	/^export fn begetu32(buf: []u8) u32 = {$/;"	f
begetu64	$HARELIB/endian/big.ha	/^export fn begetu64(buf: []u8) u64 = {$/;"	f
beputu16	$HARELIB/endian/big.ha	/^export fn beputu16(buf: []u8, in: u16) void = {$/;"	f
beputu32	$HARELIB/endian/big.ha	/^export fn beputu32(buf: []u8, in: u32) void = {$/;"	f
beputu64	$HARELIB/endian/big.ha	/^export fn beputu64(buf: []u8, in: u64) void = {$/;"	f
binarithm_expr	$HARELIB/hare/ast/expr.ha	/^export type binarithm_expr = struct {$/;"	t
binarithm_op	$HARELIB/hare/ast/expr.ha	/^export type binarithm_op = enum {$/;"	t
bind	$HARELIB/rt/+darwin/syscalls.ha	/^export fn bind(sockfd: int, addr: *const sockaddr, addrlen: u32) (void | errno) = {$/;"	f
bind	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn bind(sockfd: int, addr: *const sockaddr, addrlen: u32) (void | errno) = {$/;"	f
bind	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn bind(sockfd: int, addr: *const sockaddr, addrlen: u32) (int | errno) = {$/;"	f
bind	$HARELIB/rt/+linux/syscalls.ha	/^export fn bind(sockfd: int, addr: *const sockaddr, addrlen: u32) (int | errno) = {$/;"	f
bind	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn bind($/;"	f
binding	$HARELIB/hare/ast/expr.ha	/^export type binding = struct {$/;"	t
binding	$HARELIB/hare/unit/expr.ha	/^export type binding = struct {$/;"	t
binding_expr	$HARELIB/hare/ast/expr.ha	/^export type binding_expr = struct {$/;"	t
binding_kind	$HARELIB/hare/ast/expr.ha	/^export type binding_kind = enum {$/;"	t
binding_unpack	$HARELIB/hare/ast/expr.ha	/^export type binding_unpack = [](str | void);$/;"	t
bindings	$HARELIB/hare/unit/expr.ha	/^export type bindings = []binding;$/;"	t
bit_size_u	$HARELIB/math/uints.ha	/^export fn bit_size_u(x: uint) u8 = {$/;"	f
bit_size_u16	$HARELIB/math/uints.ha	/^export fn bit_size_u16(x: u16) u8 = {$/;"	f
bit_size_u32	$HARELIB/math/uints.ha	/^export fn bit_size_u32(x: u32) u8 = {$/;"	f
bit_size_u64	$HARELIB/math/uints.ha	/^export fn bit_size_u64(x: u64) u8 = {$/;"	f
bit_size_u8	$HARELIB/math/uints.ha	/^export fn bit_size_u8(x: u8) u8 = {$/;"	f
bitstr_isset	$HARELIB/encoding/asn1/decoder.ha	/^export fn bitstr_isset(bitstr: ([]u8, u8), pos: size) (bool | invalid) = {$/;"	f
blake2b	$HARELIB/crypto/blake2b/blake2b.ha	/^export fn blake2b(key: []u8, sz: size) digest = {$/;"	f
blkcnt_t	$HARELIB/rt/+darwin/types.ha	/^export type blkcnt_t    = i64;$/;"	t
blkcnt_t	$HARELIB/rt/+freebsd/types.ha	/^export type blkcnt_t = i64;$/;"	t
blkcnt_t	$HARELIB/rt/+openbsd/types.ha	/^export type blkcnt_t = i64;$/;"	t
blksize_t	$HARELIB/rt/+darwin/types.ha	/^export type blksize_t   = i32;$/;"	t
blksize_t	$HARELIB/rt/+freebsd/types.ha	/^export type blksize_t = i32;$/;"	t
blksize_t	$HARELIB/rt/+openbsd/types.ha	/^export type blksize_t = i32;$/;"	t
block	$HARELIB/crypto/aes/block.ha	/^export type block = struct {$/;"	t
block	$HARELIB/crypto/aes/xts/xts.ha	/^export type block = struct {$/;"	t
block	$HARELIB/crypto/cipher/block.ha	/^export type block = *blockvtable;$/;"	t
block	$HARELIB/unix/signal/+darwin.ha	/^export fn block(signals: sig...) sigset = {$/;"	f
block	$HARELIB/unix/signal/+freebsd.ha	/^export fn block(signals: sig...) sigset = {$/;"	f
block	$HARELIB/unix/signal/+linux.ha	/^export fn block(signals: sig...) sigset = {$/;"	f
block	$HARELIB/unix/signal/+openbsd.ha	/^export fn block(signals: sig...) sigset = {$/;"	f
blocksz	$HARELIB/crypto/cipher/block.ha	/^export fn blocksz(b: *block) size = b.blocksz;$/;"	f
blockvtable	$HARELIB/crypto/cipher/block.ha	/^export type blockvtable = struct {$/;"	t
borrowedread	$HARELIB/memio/stream.ha	/^export fn borrowedread(st: *stream, amt: size) ([]u8 | io::EOF) = {$/;"	f
box	$HARELIB/crypto/authenc.ha	/^export type box = (mac, nonce, []u8);$/;"	t
break_expr	$HARELIB/hare/ast/expr.ha	/^export type break_expr = label;$/;"	t
bsformat	$HARELIB/time/date/format.ha	/^export fn bsformat($/;"	f
bsprint	$HARELIB/fmt/wrappers.ha	/^export fn bsprint(buf: []u8, args: formattable...) str = {$/;"	f
bsprintf	$HARELIB/fmt/wrappers.ha	/^export fn bsprintf(buf: []u8, fmt: str, args: field...) str = {$/;"	f
bsz	$HARELIB/crypto/mac/mac.ha	/^export fn bsz(m: *mac) size = m.bsz;$/;"	f
bsz	$HARELIB/hash/hash.ha	/^export fn bsz(h: *hash) size = h.bsz;$/;"	f
buffer	$HARELIB/crypto/random/+darwin.ha	/^export fn buffer(buf: []u8) void = {$/;"	f
buffer	$HARELIB/crypto/random/+freebsd.ha	/^export fn buffer(buf: []u8) void = {$/;"	f
buffer	$HARELIB/crypto/random/+linux.ha	/^export fn buffer(buf: []u8) void = {$/;"	f
buffer	$HARELIB/crypto/random/+openbsd.ha	/^export fn buffer(buf: []u8) void = {$/;"	f
buffer	$HARELIB/memio/stream.ha	/^export fn buffer(in: *stream) []u8 = {$/;"	f
buffer	$HARELIB/path/buffer.ha	/^export type buffer = struct {$/;"	t
builtin	$HARELIB/hare/types/types.ha	/^export type builtin = enum u8 {$/;"	t
builtin_type	$HARELIB/hare/ast/type.ha	/^export type builtin_type = enum {$/;"	t
builtin_type	$HARELIB/hare/unparse/type.ha	/^export fn builtin_type(b: ast::builtin_type) str = switch (b) {$/;"	f
busy	$HARELIB/errors/common.ha	/^export type busy = !void;$/;"	t
byteindex	$HARELIB/strings/index.ha	/^export fn byteindex(haystack: str, needle: (str | rune)) (size | void) = {$/;"	f
bytereader	$HARELIB/encoding/asn1/decoder.ha	/^export fn bytereader(d: *decoder, c: class, tagid: u32) (bytestream | error) = {$/;"	f
bytestream	$HARELIB/encoding/asn1/decoder.ha	/^export type bytestream = struct {$/;"	t
bytewstream	$HARELIB/encoding/asn1/encoder.ha	/^export type bytewstream = struct {$/;"	t
c128	$HARELIB/math/complex/complex.ha	/^export type c128 = (f64, f64);$/;"	t
c128to64	$HARELIB/math/complex/complex.ha	/^export fn c128to64(z: c128) c64 = (z.0: f32, z.1: f32);$/;"	f
c64	$HARELIB/math/complex/complex.ha	/^export type c64 = (f32, f32);$/;"	t
c64to128	$HARELIB/math/complex/complex.ha	/^export fn c64to128(z: c64) c128 = (z.0: f64, z.1: f64);$/;"	f
caa	$HARELIB/net/dns/types.ha	/^export type caa = struct {$/;"	t
cache	$HARELIB/dirs/xdg.ha	/^export fn cache(prog: str) str = lookup(prog, "XDG_CACHE_HOME", ".cache");$/;"	f
calculus	$HARELIB/time/date/reckon.ha	/^export type calculus = enum uint {$/;"	t
call_expr	$HARELIB/hare/ast/expr.ha	/^export type call_expr = struct {$/;"	t
cancelled	$HARELIB/errors/common.ha	/^export type cancelled = !void;$/;"	t
cannotrename	$HARELIB/fs/types.ha	/^export type cannotrename = !void;$/;"	t
cant_extend	$HARELIB/path/error.ha	/^export type cant_extend = !void;$/;"	t
caps	$HARELIB/linux/keyctl/+linux/types.ha	/^export type caps = enum u8 {$/;"	t
capture	$HARELIB/regex/regex.ha	/^export type capture = struct {$/;"	t
cast_expr	$HARELIB/hare/ast/expr.ha	/^export type cast_expr = struct {$/;"	t
cast_kind	$HARELIB/hare/ast/expr.ha	/^export type cast_kind = enum {$/;"	t
cbc_decrypt	$HARELIB/crypto/cipher/cbc.ha	/^export fn cbc_decrypt(c: *cbc_mode, dest: []u8, src: []u8) void = {$/;"	f
cbc_decryptor	$HARELIB/crypto/cipher/cbc.ha	/^export fn cbc_decryptor(b: *block, iv: []u8, buf: []u8) cbc_mode = {$/;"	f
cbc_encrypt	$HARELIB/crypto/cipher/cbc.ha	/^export fn cbc_encrypt(c: *cbc_mode, dest: []u8, src: []u8) void = {$/;"	f
cbc_encryptor	$HARELIB/crypto/cipher/cbc.ha	/^export fn cbc_encryptor(b: *block, iv: []u8, buf: []u8) cbc_mode = {$/;"	f
cbc_mode	$HARELIB/crypto/cipher/cbc.ha	/^export type cbc_mode = struct {$/;"	t
ccopyu32	$HARELIB/crypto/math/bits.ha	/^export fn ccopyu32(ctl: u32, dest: []u32, src: const []u32) void = {$/;"	f
ceilf64	$HARELIB/math/math.ha	/^export fn ceilf64(x: f64) f64 = -floorf64(-x);$/;"	f
chacha20	$HARELIB/crypto/chacha/chacha20.ha	/^export fn chacha20() stream = {$/;"	f
chacha20_init	$HARELIB/crypto/chacha/chacha20.ha	/^export fn chacha20_init($/;"	f
chachapoly	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn chachapoly() stream = {$/;"	f
char	$HARELIB/types/c/arch+aarch64.ha	/^export type char = uchar;$/;"	t
char	$HARELIB/types/c/arch+riscv64.ha	/^export type char = uchar;$/;"	t
char	$HARELIB/types/c/arch+x86_64.ha	/^export type char = schar;$/;"	t
char16	$HARELIB/types/c/types.ha	/^export type char16 = uint_least16;$/;"	t
char32	$HARELIB/types/c/types.ha	/^export type char32 = uint_least32;$/;"	t
char8	$HARELIB/types/c/types.ha	/^export type char8 = uchar;$/;"	t
charclass	$HARELIB/regex/regex.ha	/^export type charclass = enum {$/;"	t
charset	$HARELIB/regex/regex.ha	/^export type charset = [](charset_lit_item | charset_range_item |$/;"	t
chdir	$HARELIB/os/+darwin/fs.ha	/^export fn chdir(target: (*fs::fs | str)) (void | fs::error) = {$/;"	f
chdir	$HARELIB/os/+freebsd/fs.ha	/^export fn chdir(target: (*fs::fs | str)) (void | fs::error) = {$/;"	f
chdir	$HARELIB/os/+linux/fs.ha	/^export fn chdir(target: (*fs::fs | str)) (void | fs::error) = {$/;"	f
chdir	$HARELIB/os/+openbsd/fs.ha	/^export fn chdir(target: (*fs::fs | str)) (void | fs::error) = {$/;"	f
chdir	$HARELIB/os/exec/cmd.ha	/^export fn chdir(cmd: *command, dir: str) void = {$/;"	f
chdir	$HARELIB/rt/+darwin/syscalls.ha	/^export fn chdir(path: path) (void | errno) = {$/;"	f
chdir	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn chdir(path: path) (void | errno) = {$/;"	f
chdir	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn chdir(path: path) (void | errno) = {$/;"	f
chdir	$HARELIB/rt/+linux/syscalls.ha	/^export fn chdir(path: path) (void | errno) = {$/;"	f
chdir	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn chdir(path: path) (void | errno) = {$/;"	f
check	$HARELIB/hare/unit/check.ha	/^export fn check($/;"	f
check	$HARELIB/os/exec/+darwin/process.ha	/^export fn check(stat: *status) (void | !exit_status) = {$/;"	f
check	$HARELIB/os/exec/+freebsd/process.ha	/^export fn check(stat: *status) (void | !exit_status) = {$/;"	f
check	$HARELIB/os/exec/+linux/process.ha	/^export fn check(stat: *status) (void | !exit_status) = {$/;"	f
check	$HARELIB/os/exec/+openbsd/process.ha	/^export fn check(stat: *status) (void | !exit_status) = {$/;"	f
chmod	$HARELIB/fs/fs.ha	/^export fn chmod(fs: *fs, path: str, mode: mode) (void | error) = {$/;"	f
chmod	$HARELIB/os/os.ha	/^export fn chmod(path: str, mode: fs::mode) (void | fs::error) = fs::chmod(cwd, path, mode);$/;"	f
chmod	$HARELIB/rt/+linux/syscalls.ha	/^export fn chmod(path: path, mode: uint) (void | errno) = {$/;"	f
chmodfunc	$HARELIB/fs/types.ha	/^export type chmodfunc = fn(fs: *fs, path: str, mode: mode) (void | error);$/;"	t
chown	$HARELIB/fs/fs.ha	/^export fn chown(fs: *fs, path: str, uid: uint, gid: uint) (void | error) = {$/;"	f
chown	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn chown(id: serial, uid: uint, gid: uint) (void | error) = {$/;"	f
chown	$HARELIB/os/os.ha	/^export fn chown(path: str, uid: uint, gid: uint) (void | fs::error) = fs::chown(cwd, path, uid, /;"	f
chown	$HARELIB/rt/+linux/syscalls.ha	/^export fn chown(path: path, uid: uint, gid: uint) (void | errno) = {$/;"	f
chownfunc	$HARELIB/fs/types.ha	/^export type chownfunc = fn(fs: *fs, path: str, uid: uint, gid: uint) (void | error);$/;"	t
chroot	$HARELIB/os/+darwin/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
chroot	$HARELIB/os/+freebsd/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
chroot	$HARELIB/os/+linux/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
chroot	$HARELIB/os/+openbsd/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
chroot	$HARELIB/rt/+darwin/syscalls.ha	/^export fn chroot(path: path) (void | errno) = {$/;"	f
chroot	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn chroot(path: path) (void | errno) = {$/;"	f
chroot	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn chroot(path: path) (void | errno) = {$/;"	f
chroot	$HARELIB/rt/+linux/syscalls.ha	/^export fn chroot(path: path) (void | errno) = {$/;"	f
chroot	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn chroot(path: path) (void | errno) = {$/;"	f
chunk	$HARELIB/rt/malloc.ha	/^export type chunk = union {$/;"	t
clamp	$HARELIB/crypto/curve25519/curve25519.ha	/^export fn clamp(scalar: []u8) void = {$/;"	f
class	$HARELIB/encoding/asn1/types.ha	/^export type class = enum u8 {$/;"	t
class	$HARELIB/net/dns/types.ha	/^export type class = enum u16 {$/;"	t
clearenv	$HARELIB/os/exec/cmd.ha	/^export fn clearenv(cmd: *command) void = {$/;"	f
clearexcept	$HARELIB/math/fenv_func.ha	/^export fn clearexcept(ex: fexcept) void = rt::feclearexcept(ex: uint);$/;"	f
clock	$HARELIB/time/+darwin/functions.ha	/^export type clock = enum {$/;"	t
clock	$HARELIB/time/+freebsd/functions.ha	/^export type clock = enum {$/;"	t
clock	$HARELIB/time/+linux/functions.ha	/^export type clock = enum {$/;"	t
clock	$HARELIB/time/+openbsd/functions.ha	/^export type clock = enum {$/;"	t
clock_gettime	$HARELIB/rt/+darwin/syscalls.ha	/^export fn clock_gettime(clock_id: int, tp: *timespec) (void | errno) = {$/;"	f
clock_gettime	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn clock_gettime(clock_id: int, tp: *timespec) (void | errno) = {$/;"	f
clock_gettime	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn clock_gettime(clock_id: int, tp: *timespec) (void | errno) = {$/;"	f
clock_gettime	$HARELIB/rt/+linux/syscalls.ha	/^export fn clock_gettime(clock_id: int, tp: *timespec) (void | errno) = {$/;"	f
clock_gettime	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn clock_gettime(clock: int, now: *timespec) (void | errno) = {$/;"	f
clock_t	$HARELIB/rt/+linux/types.ha	/^export type clock_t = i64;$/;"	t
clock_t	$HARELIB/rt/+openbsd/types.ha	/^export type clock_t = i64;$/;"	t
clockid_t	$HARELIB/rt/+darwin/types.ha	/^export type clockid_t = enum int {$/;"	t
clockid_t	$HARELIB/rt/+openbsd/types.ha	/^export type clockid_t = i32;$/;"	t
clone	$HARELIB/rt/+linux/+aarch64.ha	/^export fn clone($/;"	f
clone	$HARELIB/rt/+linux/+riscv64.ha	/^export fn clone($/;"	f
clone	$HARELIB/rt/+linux/+x86_64.ha	/^export fn clone($/;"	f
close	$HARELIB/debug/image/open.ha	/^export fn close(image: *image) void = {$/;"	f
close	$HARELIB/fs/fs.ha	/^export fn close(fs: *fs) void = {$/;"	f
close	$HARELIB/hash/hash.ha	/^export fn close(h: *hash) void = io::close(h)!;$/;"	f
close	$HARELIB/io/handle.ha	/^export fn close(h: handle) (void | error) = {$/;"	f
close	$HARELIB/net/+darwin.ha	/^export fn close(sock: socket) (void | error) = match (io::close(sock)) {$/;"	f
close	$HARELIB/net/+freebsd.ha	/^export fn close(sock: socket) (void | error) = match (io::close(sock)) {$/;"	f
close	$HARELIB/net/+linux.ha	/^export fn close(sock: socket) (void | error) = match (io::close(sock)) {$/;"	f
close	$HARELIB/net/+openbsd.ha	/^export fn close(sock: socket) (void | error) = match (io::close(sock)) {$/;"	f
close	$HARELIB/rt/+darwin/syscalls.ha	/^export fn close(fd: int) (void | errno) = {$/;"	f
close	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn close(fd: int) (void | errno) = {$/;"	f
close	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn close(fd: int) (void | errno) = {$/;"	f
close	$HARELIB/rt/+linux/syscalls.ha	/^export fn close(fd: int) (void | errno) = {$/;"	f
close	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn close(fd: int) (void | errno) = {$/;"	f
close_explicit	$HARELIB/encoding/asn1/decoder.ha	/^export fn close_explicit(d: *decoder) (void | badformat) = close_cons(d);$/;"	f
close_seq	$HARELIB/encoding/asn1/decoder.ha	/^export fn close_seq(d: *decoder) (void | badformat) = close_cons(d);$/;"	f
close_set	$HARELIB/encoding/asn1/decoder.ha	/^export fn close_set(d: *decoder) (void | badformat) = close_cons(d);$/;"	f
closefd	$HARELIB/os/exec/types.ha	/^export type closefd = void;$/;"	t
closefunc	$HARELIB/fs/types.ha	/^export type closefunc = fn(fs: *fs) void;$/;"	t
closer	$HARELIB/io/types.ha	/^export type closer = fn(s: *stream) (void | error);$/;"	t
closestd	$HARELIB/os/exec/cmd.ha	/^export fn closestd(cmd: *command) void = {$/;"	f
cmd_help	$HARELIB/getopt/getopts.ha	/^export type cmd_help = str;$/;"	t
cmdfile	$HARELIB/os/exec/+darwin/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
cmdfile	$HARELIB/os/exec/+freebsd/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
cmdfile	$HARELIB/os/exec/+linux/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
cmpfunc	$HARELIB/sort/types.ha	/^export type cmpfunc = fn(a: const *opaque, b: const *opaque) int;$/;"	t
cmpu32	$HARELIB/crypto/math/bits.ha	/^export fn cmpu32(x: u32, y: u32) i32 = gtu32(x, y): i32 | -(gtu32(y, x): i32);$/;"	f
cmsg	$HARELIB/rt/+darwin/socket.ha	/^export type cmsg = struct {$/;"	t
cmsg	$HARELIB/rt/+freebsd/socket.ha	/^export type cmsg = struct {$/;"	t
cmsg	$HARELIB/rt/+linux/socket.ha	/^export type cmsg = struct {$/;"	t
cmsg	$HARELIB/rt/+openbsd/socket.ha	/^export type cmsg = struct {$/;"	t
cmsghdr	$HARELIB/rt/+darwin/socket.ha	/^export type cmsghdr = struct {$/;"	t
cmsghdr	$HARELIB/rt/+freebsd/socket.ha	/^export type cmsghdr = struct {$/;"	t
cmsghdr	$HARELIB/rt/+linux/+aarch64.ha	/^export type cmsghdr = struct {$/;"	t
cmsghdr	$HARELIB/rt/+linux/+riscv64.ha	/^export type cmsghdr = struct {$/;"	t
cmsghdr	$HARELIB/rt/+linux/+x86_64.ha	/^export type cmsghdr = struct {$/;"	t
cmsghdr	$HARELIB/rt/+openbsd/socket.ha	/^export type cmsghdr = struct {$/;"	t
cname	$HARELIB/net/dns/types.ha	/^export type cname = struct {$/;"	t
code	$HARELIB/unix/signal/+darwin.ha	/^export type code = enum int {$/;"	t
code	$HARELIB/unix/signal/+freebsd.ha	/^export type code = enum int {$/;"	t
code	$HARELIB/unix/signal/+linux.ha	/^export type code = enum int {$/;"	t
code	$HARELIB/unix/signal/+openbsd.ha	/^export type code = enum int {$/;"	t
code_sample	$HARELIB/hare/parse/doc/doc.ha	/^export type code_sample = str;$/;"	t
coincident	$HARELIB/time/chrono/arithmetic.ha	/^export fn coincident(a: *moment, b: *moment) bool = {$/;"	f
command	$HARELIB/getopt/getopts.ha	/^export type command = struct {$/;"	t
command	$HARELIB/linux/keyctl/+linux/types.ha	/^export type command = enum int {$/;"	t
command	$HARELIB/os/exec/types.ha	/^export type command = struct {$/;"	t
comment	$HARELIB/hare/lex/lex.ha	/^export fn comment(lex: *lexer) str = lex.comment;$/;"	f
compare	$HARELIB/crypto/authenc.ha	/^export fn compare(a: []u8, b: []u8) bool = {$/;"	f
compare	$HARELIB/crypto/bcrypt/bcrypt.ha	/^export fn compare(hash: []u8, password: []u8) (bool | errors::invalid) = {$/;"	f
compare	$HARELIB/strings/compare.ha	/^export fn compare(a: str, b: str) int = {$/;"	f
compare	$HARELIB/time/arithm.ha	/^export fn compare(a: instant, b: instant) i8 = {$/;"	f
compare	$HARELIB/time/chrono/arithmetic.ha	/^export fn compare(a: *moment, b: *moment) (i8 | discontinuity) = {$/;"	f
compare	$HARELIB/uuid/uuid.ha	/^export fn compare(a: uuid, b: uuid) bool = bytes::equal(a, b);$/;"	f
compile	$HARELIB/regex/regex.ha	/^export fn compile(expr: str) (regex | error) = {$/;"	f
compile	$HARELIB/strings/template/template.ha	/^export fn compile(input: str) (template | invalid) = {$/;"	f
complex	$HARELIB/math/complex/complex.ha	/^export type complex = (c64 | c128);$/;"	t
compound	$HARELIB/hare/unit/expr.ha	/^export type compound = []*expr;$/;"	t
compound_expr	$HARELIB/hare/ast/expr.ha	/^export type compound_expr = struct {$/;"	t
concat	$HARELIB/memio/ops.ha	/^export fn concat(out: io::handle, strs: str...) (size | io::error) =$/;"	f
concat	$HARELIB/strings/concat.ha	/^export fn concat(strs: str...) str = {$/;"	f
conf	$HARELIB/crypto/argon2/argon2.ha	/^export type conf = struct {$/;"	t
config	$HARELIB/dirs/xdg.ha	/^export fn config(prog: str) str = lookup(prog, "XDG_CONFIG_HOME", ".config");$/;"	f
conjc128	$HARELIB/math/complex/complex.ha	/^export fn conjc128(z: c128) c128 = (z.0, -z.1);$/;"	f
conjc64	$HARELIB/math/complex/complex.ha	/^export fn conjc64(z: c64) c64 = (z.0, -z.1);$/;"	f
connect	$HARELIB/net/tcp/+darwin.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/tcp/+freebsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/tcp/+linux.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/tcp/+openbsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/udp/+darwin.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/udp/+freebsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/udp/+linux.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/udp/+openbsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/unix/+darwin.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/unix/+freebsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/unix/+linux.ha	/^export fn connect($/;"	f
connect	$HARELIB/net/unix/+openbsd.ha	/^export fn connect($/;"	f
connect	$HARELIB/rt/+darwin/syscalls.ha	/^export fn connect(sockfd: int, addr: *const sockaddr, addrlen: u32) (void | errno) = {$/;"	f
connect	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn connect(sockfd: int, addr: *const sockaddr, addrlen: u32) (void | errno) = {$/;"	f
connect	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn connect(sockfd: int, addr: *const sockaddr, addrlen: u32) (int | errno) = {$/;"	f
connect	$HARELIB/rt/+linux/syscalls.ha	/^export fn connect(sockfd: int, addr: *const sockaddr, addrlen: u32) (int | errno) = {$/;"	f
connect	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn connect($/;"	f
connect_option	$HARELIB/net/tcp/options.ha	/^export type connect_option = (keepalive | net::sockflag);$/;"	t
connect_option	$HARELIB/net/udp/options.ha	/^export type connect_option = net::sockflag;$/;"	t
connect_option	$HARELIB/net/unix/options.ha	/^export type connect_option = net::sockflag;$/;"	t
constant	$HARELIB/hare/unit/expr.ha	/^export type constant = (...ast::value | i64 | u64 | f64); \/\/ TODO: composite types$/;"	t
contains	$HARELIB/bytes/contains.ha	/^export fn contains(haystack: []u8, needles: (u8 | []u8)...) bool = {$/;"	f
contains	$HARELIB/strings/contains.ha	/^export fn contains(haystack: str, needles: (str | rune)...) bool = {$/;"	f
context	$HARELIB/hare/module/types.ha	/^export type context = struct {$/;"	t
context	$HARELIB/hare/unparse/syn.ha	/^export type context = struct {$/;"	t
continue_expr	$HARELIB/hare/ast/expr.ha	/^export type continue_expr = label;$/;"	t
convert	$HARELIB/time/chrono/timescale.ha	/^export fn convert(i: time::instant, tscs: *timescale...) (time::instant | analytical) = {$/;"	f
copier	$HARELIB/io/types.ha	/^export type copier = fn(to: *stream, from: *stream) (size | error);$/;"	t
copy	$HARELIB/io/copy.ha	/^export fn copy(dest: handle, src: handle) (size | error) = {$/;"	f
copysign	$HARELIB/math/floats.ha	/^export fn copysign(x: types::floating, y: types::floating) f64 = {$/;"	f
copysignf32	$HARELIB/math/floats.ha	/^export fn copysignf32(x: f32, y: f32) f32 = {$/;"	f
copysignf64	$HARELIB/math/floats.ha	/^export fn copysignf64(x: f64, y: f64) f64 = {$/;"	f
cosc128	$HARELIB/math/complex/complex.ha	/^export fn cosc128(z: c128) c128 = {$/;"	f
cosf64	$HARELIB/math/trig.ha	/^export fn cosf64(x: f64) f64 = {$/;"	f
coshc128	$HARELIB/math/complex/complex.ha	/^export fn coshc128(z: c128) c128 = {$/;"	f
coshf64	$HARELIB/math/trig.ha	/^export fn coshf64(x: f64) f64 = {$/;"	f
cpu_set	$HARELIB/rt/+linux/+aarch64.ha	/^export type cpu_set = struct {$/;"	t
cpu_set	$HARELIB/rt/+linux/+riscv64.ha	/^export type cpu_set = struct {$/;"	t
cpu_set	$HARELIB/rt/+linux/+x86_64.ha	/^export type cpu_set = struct {$/;"	t
cpucount	$HARELIB/os/+darwin/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
cpucount	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
cpucount	$HARELIB/os/+linux/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
cpucount	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
cpuid_ecxflag	$HARELIB/rt/+x86_64/cpuid.ha	/^export type cpuid_ecxflag = enum uint {$/;"	t
cpuid_edxflag	$HARELIB/rt/+x86_64/cpuid.ha	/^export type cpuid_edxflag = enum uint {$/;"	t
cpuid_getvendor	$HARELIB/rt/+x86_64/cpuid.ha	/^export fn cpuid_getvendor() (cpuid_vendor | cpuid_unknownvendor) = {$/;"	f
cpuid_hasflags	$HARELIB/rt/+x86_64/cpuid.ha	/^export fn cpuid_hasflags(edx: u32, ecx: u32) bool = {$/;"	f
cpuid_unknownvendor	$HARELIB/rt/+x86_64/cpuid.ha	/^export type cpuid_unknownvendor = !void;$/;"	t
cpuid_vendor	$HARELIB/rt/+x86_64/cpuid.ha	/^export type cpuid_vendor = enum {$/;"	t
crc16	$HARELIB/hash/crc16/crc16.ha	/^export fn crc16(table: *[256]u16) state = state {$/;"	f
crc32	$HARELIB/hash/crc32/crc32.ha	/^export fn crc32(table: *[256]u32) state = state {$/;"	f
crc64	$HARELIB/hash/crc64/crc64.ha	/^export fn crc64(table: *[256]u64) state = state {$/;"	f
create	$HARELIB/fs/fs.ha	/^export fn create($/;"	f
create	$HARELIB/os/os.ha	/^export fn create($/;"	f
create_explicit	$HARELIB/encoding/asn1/encoder.ha	/^export fn create_explicit(e: *encoder, c: class, tag: u32) (void | overflow) =$/;"	f
create_file	$HARELIB/fs/fs.ha	/^export fn create_file($/;"	f
create_seq	$HARELIB/encoding/asn1/encoder.ha	/^export fn create_seq(e: *encoder) (void | overflow) =$/;"	f
createfilefunc	$HARELIB/fs/types.ha	/^export type createfilefunc = fn($/;"	t
createfunc	$HARELIB/fs/types.ha	/^export type createfunc = fn($/;"	t
ctr	$HARELIB/crypto/cipher/ctr.ha	/^export fn ctr(h: io::handle, b: *block, iv: []u8, buf: []u8) ctr_stream = {$/;"	f
ctr_stream	$HARELIB/crypto/cipher/ctr.ha	/^export type ctr_stream = struct {$/;"	t
curve	$HARELIB/crypto/ec/types.ha	/^export type curve = struct {$/;"	t
cut	$HARELIB/bytes/tokenize.ha	/^export fn cut(in: []u8, delim: ([]u8 | u8)) ([]u8, []u8) = {$/;"	f
cut	$HARELIB/strings/tokenize.ha	/^export fn cut(in: str, delim: str) (str, str) = {$/;"	f
d_ext_state	$HARELIB/rt/+linux/+riscv64.ha	/^export type d_ext_state = struct {$/;"	t
data	$HARELIB/dirs/xdg.ha	/^export fn data(prog: str) str = {$/;"	f
datasz	$HARELIB/encoding/asn1/encoder.ha	/^export type datasz = u32; \/\/ XXX: might want to use size here$/;"	t
date	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_utctime(d: *decoder, maxyear: u16) (date::date | error) = {$/;"	f
date	$HARELIB/time/date/date.ha	/^export type date = struct {$/;"	t
day	$HARELIB/time/date/observe.ha	/^export fn day(d: *date) int = _day(d);$/;"	f
daydate	$HARELIB/time/chrono/chronology.ha	/^export fn daydate(m: *moment) i64 = {$/;"	f
daytime	$HARELIB/time/chrono/chronology.ha	/^export fn daytime(m: *moment) i64 = {$/;"	f
dealias	$HARELIB/hare/types/lookup.ha	/^export fn dealias(t: *_type) const *_type = {$/;"	f
debug_info_finish	$HARELIB/debug/dwarf/info.ha	/^export fn debug_info_finish(di: *debug_info_reader) void = {$/;"	f
debug_info_next	$HARELIB/debug/dwarf/info.ha	/^export fn debug_info_next(di: *debug_info_reader) (entry | io::EOF) = {$/;"	f
debug_info_reader	$HARELIB/debug/dwarf/info.ha	/^export type debug_info_reader = struct {$/;"	t
decl	$HARELIB/hare/ast/decl.ha	/^export type decl = struct {$/;"	t
decl	$HARELIB/hare/parse/decl.ha	/^export fn decls(lexer: *lex::lexer) ([]ast::decl | error) = {$/;"	f
decl	$HARELIB/hare/unit/unit.ha	/^export type decl = struct {$/;"	t
decl	$HARELIB/hare/unparse/decl.ha	/^export fn decl($/;"	f
decl_const	$HARELIB/hare/ast/decl.ha	/^export type decl_const = struct {$/;"	t
decl_const	$HARELIB/hare/parse/decl.ha	/^export fn define(lexer: *lex::lexer) (ast::decl_const | error) = {$/;"	f
decl_finish	$HARELIB/hare/ast/decl.ha	/^export fn decl_finish(d: decl) void = {$/;"	f
decl_func	$HARELIB/hare/ast/decl.ha	/^export type decl_func = struct {$/;"	t
decl_func	$HARELIB/hare/unit/unit.ha	/^export type decl_func = struct {$/;"	t
decl_global	$HARELIB/hare/ast/decl.ha	/^export type decl_global = struct {$/;"	t
decl_ref	$HARELIB/hare/parse/doc/doc.ha	/^export type decl_ref = ast::ident;$/;"	t
decl_type	$HARELIB/hare/ast/decl.ha	/^export type decl_type = struct {$/;"	t
decls	$HARELIB/hare/parse/decl.ha	/^export fn decls(lexer: *lex::lexer) ([]ast::decl | error) = {$/;"	f
decode	$HARELIB/crypto/bigint/encoding.ha	/^export fn decode(dest: []u8, src: const []word) void = {$/;"	f
decode	$HARELIB/encoding/base64/base64.ha	/^export fn decode($/;"	f
decode	$HARELIB/encoding/utf8/decode.ha	/^export fn decode(src: []u8) decoder = decoder {$/;"	f
decode	$HARELIB/net/dns/decode.ha	/^export fn decode(buf: []u8) (*message | format) = {$/;"	f
decode	$HARELIB/uuid/uuid.ha	/^export fn decode(in: io::handle) (uuid | invalid | io::error) = {$/;"	f
decodedsize	$HARELIB/encoding/base64/base64.ha	/^export fn decodedsize(sz: size) size = {$/;"	f
decodelen	$HARELIB/crypto/bigint/encoding.ha	/^export fn decodelen(src: const []word) size = {$/;"	f
decodequery	$HARELIB/net/uri/query.ha	/^export fn decodequery(q: const str) query_decoder = query_decoder {$/;"	f
decoder	$HARELIB/encoding/asn1/decoder.ha	/^export type decoder = struct {$/;"	t
decoder	$HARELIB/encoding/base32/base32.ha	/^export type decoder = struct {$/;"	t
decoder	$HARELIB/encoding/base64/base64.ha	/^export type decoder = struct {$/;"	t
decoder	$HARELIB/encoding/hex/hex.ha	/^export type decoder = struct {$/;"	t
decoder	$HARELIB/encoding/pem/pem.ha	/^export type decoder = struct {$/;"	t
decoder	$HARELIB/encoding/utf8/decode.ha	/^export type decoder = struct {$/;"	t
decodeslice	$HARELIB/encoding/base32/base32.ha	/^export fn decodeslice($/;"	f
decodeslice	$HARELIB/encoding/base64/base64.ha	/^export fn decodeslice($/;"	f
decodestr	$HARELIB/encoding/base32/base32.ha	/^export fn decodestr(enc: *encoding, in: str) ([]u8 | errors::invalid) = {$/;"	f
decodestr	$HARELIB/encoding/base64/base64.ha	/^export fn decodestr(enc: *encoding, in: str) ([]u8 | errors::invalid) = {$/;"	f
decodestr	$HARELIB/encoding/hex/hex.ha	/^export fn decodestr(s: str) ([]u8 | io::error) = {$/;"	f
decodestr	$HARELIB/uuid/uuid.ha	/^export fn decodestr(in: str) (uuid | invalid) = {$/;"	f
decrodd	$HARELIB/crypto/bigint/arithm.ha	/^export fn decrodd(x: []word) void = {$/;"	f
decrypt	$HARELIB/crypto/aes/xts/xts.ha	/^export fn decrypt(b: *block, dest: []u8, src: []u8, sector: u64) void = {$/;"	f
decrypt	$HARELIB/crypto/authenc.ha	/^export fn decrypt($/;"	f
decrypt	$HARELIB/crypto/cipher/block.ha	/^export fn decrypt(b: *block, dest: []u8, src: []u8) void =$/;"	f
defer_expr	$HARELIB/hare/ast/expr.ha	/^export type defer_expr = *expr;$/;"	t
deferred	$HARELIB/hare/types/store.ha	/^export type deferred = !void;$/;"	t
define	$HARELIB/hare/parse/decl.ha	/^export fn define(lexer: *lex::lexer) (ast::decl_const | error) = {$/;"	f
delete_expr	$HARELIB/hare/ast/expr.ha	/^export type delete_expr = struct {$/;"	t
dep_cycle	$HARELIB/hare/module/types.ha	/^export type dep_cycle = ![]str;$/;"	t
derdecoder	$HARELIB/encoding/asn1/decoder.ha	/^export fn derdecoder(src: io::handle) decoder = {$/;"	f
derencoder	$HARELIB/encoding/asn1/encoder.ha	/^export fn derencoder(mem: *memio::stream) encoder = encoder {$/;"	f
derencoder_nested	$HARELIB/encoding/asn1/encoder.ha	/^export fn derencoder_nested(b: *bytewstream) encoder = encoder {$/;"	f
derive	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn derive($/;"	f
derive	$HARELIB/crypto/x25519/x25519.ha	/^export fn derive(shared: []u8, priv: []u8, pub: []u8) void = {$/;"	f
derivekey	$HARELIB/crypto/keyderiv.ha	/^export fn derivekey($/;"	f
destroy	$HARELIB/crypto/keystore/impl+linux.ha	/^export fn destroy(key: key) void = {$/;"	f
destroy	$HARELIB/crypto/keystore/impl.ha	/^export fn destroy(key: key) void = {$/;"	f
dev_t	$HARELIB/rt/+darwin/types.ha	/^export type dev_t       = i32;$/;"	t
dev_t	$HARELIB/rt/+freebsd/types.ha	/^export type dev_t = u64;$/;"	t
dev_t	$HARELIB/rt/+linux/types.ha	/^export type dev_t = u64;$/;"	t
dev_t	$HARELIB/rt/+openbsd/types.ha	/^export type dev_t = i32;$/;"	t
dh_params	$HARELIB/linux/keyctl/+linux/types.ha	/^export type dh_params = struct {$/;"	t
dial	$HARELIB/net/dial/dial.ha	/^export fn dial($/;"	f
dial_uri	$HARELIB/net/dial/dial.ha	/^export fn dial_uri(proto: str, uri: *uri::uri) (net::socket | error) = {$/;"	f
dialer	$HARELIB/net/dial/registry.ha	/^export type dialer = fn(addr: str, service: str) (net::socket | error);$/;"	t
diff	$HARELIB/time/arithm.ha	/^export fn diff(a: instant, b: instant) duration = {$/;"	f
diff	$HARELIB/time/chrono/arithmetic.ha	/^export fn diff(a: *moment, b: *moment) (time::duration | discontinuity) = {$/;"	f
digest	$HARELIB/crypto/blake2b/blake2b.ha	/^export type digest = struct {$/;"	t
digest	$HARELIB/crypto/sha512/sha512.ha	/^export type digest = struct {$/;"	t
dir	$HARELIB/temp/+darwin.ha	/^export fn dir() str = {$/;"	f
dir	$HARELIB/temp/+freebsd.ha	/^export fn dir() str = {$/;"	f
dir	$HARELIB/temp/+linux.ha	/^export fn dir() str = {$/;"	f
dirent	$HARELIB/fs/types.ha	/^export type dirent = struct {$/;"	t
dirent	$HARELIB/rt/+darwin/types.ha	/^export type dirent = struct {$/;"	t
dirent	$HARELIB/rt/+openbsd/types.ha	/^export type dirent = struct {$/;"	t
dirent64	$HARELIB/rt/+linux/types.ha	/^export type dirent64 = struct {$/;"	t
dirent_dup	$HARELIB/fs/types.ha	/^export fn dirent_dup(e: *dirent) dirent = {$/;"	f
dirent_finish	$HARELIB/fs/types.ha	/^export fn dirent_finish(e: *dirent) void = free(e.name);$/;"	f
dirents_free	$HARELIB/fs/util.ha	/^export fn dirents_free(d: []dirent) void = {$/;"	f
dirfdfs_set_getdents_bufsz	$HARELIB/os/+darwin/dirfdfs.ha	/^export fn dirfdfs_set_getdents_bufsz(fs: *fs::fs, sz: size) void = {$/;"	f
dirfdfs_set_getdents_bufsz	$HARELIB/os/+freebsd/dirfdfs.ha	/^export fn dirfdfs_set_getdents_bufsz(fs: *fs::fs, sz: size) void = {$/;"	f
dirfdfs_set_getdents_bufsz	$HARELIB/os/+linux/dirfdfs.ha	/^export fn dirfdfs_set_getdents_bufsz(fs: *fs::fs, sz: size) void = {$/;"	f
dirfdfs_set_getdents_bufsz	$HARELIB/os/+openbsd/dirfdfs.ha	/^export fn dirfdfs_set_getdents_bufsz(fs: *fs::fs, sz: size) void = {$/;"	f
dirfdopen	$HARELIB/os/+darwin/dirfdfs.ha	/^export fn dirfdopen(fd: io::file) *fs::fs = {$/;"	f
dirfdopen	$HARELIB/os/+freebsd/dirfdfs.ha	/^export fn dirfdopen(fd: io::file) *fs::fs = {$/;"	f
dirfdopen	$HARELIB/os/+linux/dirfdfs.ha	/^export fn dirfdopen(fd: io::file, resolve: resolve_flag...) *fs::fs = {$/;"	f
dirfdopen	$HARELIB/os/+openbsd/dirfdfs.ha	/^export fn dirfdopen(fd: io::file) *fs::fs = {$/;"	f
dirfile	$HARELIB/os/+darwin/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
dirfile	$HARELIB/os/+freebsd/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
dirfile	$HARELIB/os/+linux/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
dirfs_clone	$HARELIB/os/+linux/dirfdfs.ha	/^export fn dirfs_clone(fs: *fs::fs, resolve: resolve_flag...) *fs::fs = {$/;"	f
dirname	$HARELIB/path/posix.ha	/^export fn dirname(path: const str) const str = {$/;"	f
diropen	$HARELIB/os/os.ha	/^export fn diropen(path: str) (*fs::fs | fs::error) = {$/;"	f
discontinuity	$HARELIB/time/chrono/timescale.ha	/^export type discontinuity = !void;$/;"	t
discontinuity	$HARELIB/time/date/locality.ha	/^export fn in(loc: chrono::locality, d: date) (date | chrono::discontinuity) = {$/;"	f
divc128	$HARELIB/math/complex/complex.ha	/^export fn divc128(a: c128, b: c128) c128 = {$/;"	f
divc64	$HARELIB/math/complex/complex.ha	/^export fn divc64(a: c64, b: c64) c64 = {$/;"	f
divu	$HARELIB/math/uints.ha	/^export fn divu(hi: uint, lo: uint, y: uint) (uint, uint) = {$/;"	f
divu32	$HARELIB/crypto/math/arithm.ha	/^export fn divu32(hi: u32, lo: u32, y: u32) (u32, u32) = {$/;"	f
divu32	$HARELIB/math/uints.ha	/^export fn divu32(hi: u32, lo: u32, y: u32) (u32, u32) = {$/;"	f
divu64	$HARELIB/math/uints.ha	/^export fn divu64(hi: u64, lo: u64, y: u64) (u64, u64) = {$/;"	f
dl_info	$HARELIB/rt/+openbsd/dynamic_linker.ha	/^export type dl_info = struct {$/;"	t
dnskey	$HARELIB/net/dns/types.ha	/^export type dnskey = struct {$/;"	t
doc	$HARELIB/hare/parse/doc/doc.ha	/^export type doc = [](paragraph | list | code_sample);$/;"	t
drain	$HARELIB/io/drain.ha	/^export fn drain(in: handle) ([]u8 | error) = {$/;"	f
dsz	$HARELIB/encoding/asn1/decoder.ha	/^export fn dsz(d: head) size = d.end - d.data;$/;"	f
dump	$HARELIB/encoding/hex/hex.ha	/^export fn dump(out: io::handle, data: []u8) (void | io::error) = {$/;"	f
dup	$HARELIB/io/+darwin/dup.ha	/^export fn dup(old: file, flags: dupflag) (file | error) = {$/;"	f
dup	$HARELIB/io/+freebsd/dup.ha	/^export fn dup(old: file, flags: dupflag) (file | error) = {$/;"	f
dup	$HARELIB/io/+linux/dup.ha	/^export fn dup(old: file, flags: dupflag) (file | error) = {$/;"	f
dup	$HARELIB/io/+openbsd/dup.ha	/^export fn dup(old: file, flags: dupflag) (file | error) = {$/;"	f
dup	$HARELIB/net/uri/uri.ha	/^export fn dup(u: *uri) uri = {$/;"	f
dup	$HARELIB/rt/+linux/syscalls.ha	/^export fn dup(fd: int) (int | errno) = {$/;"	f
dup	$HARELIB/strings/dup.ha	/^export fn dup(s: const str) str = {$/;"	f
dup2	$HARELIB/io/+darwin/dup.ha	/^export fn dup2(old: file, new: file, flags: dupflag) (file | error) = {$/;"	f
dup2	$HARELIB/io/+freebsd/dup.ha	/^export fn dup2(old: file, new: file, flags: dupflag) (file | error) = {$/;"	f
dup2	$HARELIB/io/+linux/dup.ha	/^export fn dup2(old: file, new: file, flags: dupflag) (file | error) = {$/;"	f
dup2	$HARELIB/io/+openbsd/dup.ha	/^export fn dup2(old: file, new: file, flags: dupflag) (file | error) = {$/;"	f
dup2	$HARELIB/rt/+darwin/syscalls.ha	/^export fn dup2(oldfd: int, newfd: int) (int | errno) = {$/;"	f
dup2	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn dup2(oldfd: int, newfd: int) (int | errno) = {$/;"	f
dup2	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn dup2(oldfd: int, newfd: int) (int | errno) = {$/;"	f
dup2	$HARELIB/rt/+linux/syscalls.ha	/^export fn dup2(oldfd: int, newfd: int) (int | errno) = {$/;"	f
dup2	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn dup2(oldfd: int, newfd: int) (int | errno) = {$/;"	f
dup3	$HARELIB/rt/+linux/syscalls.ha	/^export fn dup3(oldfd: int, newfd: int, flags: int) (int | errno) = {$/;"	f
dupall	$HARELIB/strings/dup.ha	/^export fn dupall(s: []str) []str = {$/;"	f
dupflag	$HARELIB/io/+darwin/dup.ha	/^export type dupflag = enum {$/;"	t
dupflag	$HARELIB/io/+freebsd/dup.ha	/^export type dupflag = enum {$/;"	t
dupflag	$HARELIB/io/+linux/dup.ha	/^export type dupflag = enum {$/;"	t
dupflag	$HARELIB/io/+openbsd/dup.ha	/^export type dupflag = enum {$/;"	t
duration	$HARELIB/time/chrono/arithmetic.ha	/^export fn diff(a: *moment, b: *moment) (time::duration | discontinuity) = {$/;"	f
duration	$HARELIB/time/chrono/timezone.ha	/^export fn fixedzone(ts: *timescale, daylen: time::duration, z: zone) timezone = {$/;"	f
duration	$HARELIB/time/date/tarithm.ha	/^export fn add(d: date, x: time::duration) date = {$/;"	f
duration	$HARELIB/time/types.ha	/^export type duration = i64;$/;"	t
duration_to_timespec	$HARELIB/time/+darwin/functions.ha	/^export fn duration_to_timespec(n: duration) rt::timespec = rt::timespec {$/;"	f
duration_to_timespec	$HARELIB/time/+freebsd/functions.ha	/^export fn duration_to_timespec(n: duration) rt::timespec = rt::timespec {$/;"	f
duration_to_timespec	$HARELIB/time/+linux/functions.ha	/^export fn duration_to_timespec(d: duration) rt::timespec = rt::timespec {$/;"	f
duration_to_timespec	$HARELIB/time/+openbsd/functions.ha	/^export fn duration_to_timespec(n: duration) rt::timespec = rt::timespec {$/;"	f
dyn64	$HARELIB/format/elf/types.ha	/^export type dyn64 = struct {$/;"	t
dynamic	$HARELIB/memio/stream.ha	/^export fn dynamic() stream = dynamic_from([]);$/;"	f
dynamic_from	$HARELIB/memio/stream.ha	/^export fn dynamic_from(in: []u8) stream = stream {$/;"	f
edns_opt	$HARELIB/net/dns/types.ha	/^export type edns_opt = struct {$/;"	t
elf_machine	$HARELIB/format/elf/types.ha	/^export type elf_machine = enum u16 {$/;"	t
elf_type	$HARELIB/format/elf/types.ha	/^export type elf_type = enum u16 {$/;"	t
encode	$HARELIB/crypto/bigint/encoding.ha	/^export fn encode(dest: []word, src: const []u8) void = {$/;"	f
encode	$HARELIB/encoding/asn1/encoder.ha	/^export fn encode(e: *encoder) ([]u8 | io::error) = {$/;"	f
encode	$HARELIB/encoding/base64/base64.ha	/^export fn encode($/;"	f
encode	$HARELIB/encoding/hex/hex.ha	/^export fn encode(out: io::handle, in: []u8) (size | io::error) = {$/;"	f
encode	$HARELIB/net/dns/encode.ha	/^export fn encode(buf: []u8, msg: *message) (size | error) = {$/;"	f
encode	$HARELIB/uuid/uuid.ha	/^export fn encode(out: io::handle, in: uuid) (size | io::error) = {$/;"	f
encodedsize	$HARELIB/encoding/base64/base64.ha	/^export fn encodedsize(sz: size) size = if (sz == 0) 0 else ((sz - 1)\/ 3 + 1) * 4;$/;"	f
encodelen	$HARELIB/crypto/bigint/encoding.ha	/^export fn encodelen(x: []u8) size = {$/;"	f
encodemod	$HARELIB/crypto/bigint/encoding.ha	/^export fn encodemod(dest: []word, src: const []u8, m: const []word) u32 = {$/;"	f
encodequery	$HARELIB/net/uri/query.ha	/^export fn encodequery(pairs: [](str, str)) str = {$/;"	f
encoder	$HARELIB/encoding/asn1/encoder.ha	/^export type encoder = struct {$/;"	t
encoder	$HARELIB/encoding/base32/base32.ha	/^export type encoder = struct {$/;"	t
encoder	$HARELIB/encoding/base64/base64.ha	/^export type encoder = struct {$/;"	t
encoder	$HARELIB/encoding/hex/hex.ha	/^export type encoder = struct {$/;"	t
encodereduce	$HARELIB/crypto/bigint/encoding.ha	/^export fn encodereduce(dest: []word, src: const []u8, m: const []word) void = {$/;"	f
encoderune	$HARELIB/encoding/utf8/encode.ha	/^export fn encoderune(r: rune) []u8 = {$/;"	f
encodeslice	$HARELIB/encoding/base32/base32.ha	/^export fn encodeslice(enc: *encoding, in: []u8) []u8 = {$/;"	f
encodeslice	$HARELIB/encoding/base64/base64.ha	/^export fn encodeslice(enc: *encoding, in: []u8) []u8 = {$/;"	f
encodestr	$HARELIB/encoding/base32/base32.ha	/^export fn encodestr(enc: *encoding, in: []u8) str = {$/;"	f
encodestr	$HARELIB/encoding/base64/base64.ha	/^export fn encodestr(enc: *encoding, in: []u8) str = {$/;"	f
encodestr	$HARELIB/encoding/hex/hex.ha	/^export fn encodestr(in: []u8) str = {$/;"	f
encodestr	$HARELIB/uuid/uuid.ha	/^export fn encodestr(in: uuid) str = {$/;"	f
encodeto	$HARELIB/encoding/asn1/encoder.ha	/^export fn encodeto(e: *encoder, dest: io::handle) (size | io::error) = {$/;"	f
encodeuri	$HARELIB/uuid/uuid.ha	/^export fn encodeuri(in: uuid) str = {$/;"	f
encoding	$HARELIB/encoding/base32/base32.ha	/^export type encoding = struct {$/;"	t
encoding	$HARELIB/encoding/base64/base64.ha	/^export type encoding = struct {$/;"	t
encoding_init	$HARELIB/encoding/base32/base32.ha	/^export fn encoding_init(enc: *encoding, alphabet: str) void = {$/;"	f
encoding_init	$HARELIB/encoding/base64/base64.ha	/^export fn encoding_init(enc: *encoding, alphabet: str) void = {$/;"	f
encrypt	$HARELIB/crypto/aes/xts/xts.ha	/^export fn encrypt(b: *block, dest: []u8, src: []u8, sector: u64) void = {$/;"	f
encrypt	$HARELIB/crypto/authenc.ha	/^export fn encrypt($/;"	f
encrypt	$HARELIB/crypto/cipher/block.ha	/^export fn encrypt(b: *block, dest: []u8, src: []u8) void =$/;"	f
end	$HARELIB/strings/sub.ha	/^export type end = void;$/;"	t
endian	$HARELIB/endian/endian.ha	/^export type endian = struct {$/;"	t
ensure	$HARELIB/rt/ensure.ha	/^export fn ensure(s: *slice, membsz: size) void = {$/;"	f
ent_reader	$HARELIB/format/tar/types.ha	/^export type ent_reader = struct {$/;"	t
entry	$HARELIB/debug/dwarf/info.ha	/^export type entry = struct {$/;"	t
entry	$HARELIB/format/ini/scan.ha	/^export type entry = (const str, const str, const str);$/;"	t
entry	$HARELIB/format/tar/types.ha	/^export type entry = struct {$/;"	t
entry_dup	$HARELIB/format/ini/scan.ha	/^export fn entry_dup(ent: entry) entry = ($/;"	f
entry_finish	$HARELIB/debug/dwarf/info.ha	/^export fn entry_finish(ent: *entry) void = {$/;"	f
entry_finish	$HARELIB/format/ini/scan.ha	/^export fn entry_finish(ent: entry) void = {$/;"	f
entry_type	$HARELIB/format/tar/types.ha	/^export type entry_type = enum u8 {$/;"	t
enum_field	$HARELIB/hare/ast/type.ha	/^export type enum_field = struct {$/;"	t
enum_type	$HARELIB/hare/ast/type.ha	/^export type enum_type = struct {$/;"	t
epoll_create	$HARELIB/rt/+linux/syscalls.ha	/^export fn epoll_create(size_: int) (int | errno) = {$/;"	f
epoll_create1	$HARELIB/rt/+linux/syscalls.ha	/^export fn epoll_create1(flags: int) (int | errno) = {$/;"	f
epoll_ctl	$HARELIB/rt/+linux/syscalls.ha	/^export fn epoll_ctl($/;"	f
epoll_data	$HARELIB/rt/+linux/types.ha	/^export type epoll_data = union {$/;"	t
epoll_event	$HARELIB/rt/+linux/+aarch64.ha	/^export type epoll_event = struct {$/;"	t
epoll_event	$HARELIB/rt/+linux/+riscv64.ha	/^export type epoll_event = struct {$/;"	t
epoll_event	$HARELIB/rt/+linux/+x86_64.ha	/^export type epoll_event = struct @packed {$/;"	t
epoll_pwait	$HARELIB/rt/+linux/syscalls.ha	/^export fn epoll_pwait($/;"	f
epoll_wait	$HARELIB/rt/+linux/syscalls.ha	/^export fn epoll_wait($/;"	f
eq0u32	$HARELIB/crypto/math/bits.ha	/^export fn eq0u32(x: u32) u32 = {$/;"	f
eqslice	$HARELIB/crypto/math/bits.ha	/^export fn eqslice(x: []u8, y: []u8) int = {$/;"	f
equ32	$HARELIB/crypto/math/bits.ha	/^export fn equ32(x: u32, y: u32) u32 = {$/;"	f
equ8	$HARELIB/crypto/math/bits.ha	/^export fn equ8(x: u8, y: u8) int = ((((x ^ y) : u32) - 1) >> 31) : int;$/;"	f
equal	$HARELIB/bytes/equal.ha	/^export fn equal(a: []u8, b: []u8) bool = {$/;"	f
equal	$HARELIB/math/complex/complex.ha	/^export fn equal(a: complex, b: complex) bool = {$/;"	f
equal	$HARELIB/net/ip/ip.ha	/^export fn equal(l: addr, r: addr) bool = {$/;"	f
equalc128	$HARELIB/math/complex/complex.ha	/^export fn equalc128(a: c128, b: c128) bool = a.0 == b.0 && a.1 == b.1;$/;"	f
equalc64	$HARELIB/math/complex/complex.ha	/^export fn equalc64(a: c64, b: c64) bool = a.0 == b.0 && a.1 == b.1;$/;"	f
equalshex	$HARELIB/crypto/bigint/+test/utils.ha	/^export fn equalshex(x: []word, h: str) bool = {$/;"	f
eqwithin	$HARELIB/math/math.ha	/^export fn eqwithin($/;"	f
eqwithinf32	$HARELIB/math/math.ha	/^export fn eqwithinf32(x: f32, y: f32, tol: f32) bool = {$/;"	f
eqwithinf64	$HARELIB/math/math.ha	/^export fn eqwithinf64(x: f64, y: f64, tol: f64) bool = {$/;"	f
era	$HARELIB/time/date/observe.ha	/^export fn era(d: *date) int = _era(d);$/;"	f
errcontext	$HARELIB/hare/module/types.ha	/^export type errcontext = !(str, *error);$/;"	t
errname	$HARELIB/rt/+darwin/errno.ha	/^export fn errname(err: errno) str = {$/;"	f
errname	$HARELIB/rt/+freebsd/errno.ha	/^export fn errname(err: errno) str = {$/;"	f
errname	$HARELIB/rt/+linux/errno.ha	/^export fn errname(err: errno) str = {$/;"	f
errname	$HARELIB/rt/+openbsd/errno.ha	/^export fn errname(err: errno) str = {$/;"	f
errno	$HARELIB/errors/rt.ha	/^export fn errno(errno: rt::errno) error = {$/;"	f
errno	$HARELIB/rt/+darwin/errno.ha	/^export type errno = !int;$/;"	t
errno	$HARELIB/rt/+freebsd/errno.ha	/^export type errno = !int;$/;"	t
errno	$HARELIB/rt/+linux/errno.ha	/^export type errno = !int;$/;"	t
errno	$HARELIB/rt/+openbsd/errno.ha	/^export type errno = !int;$/;"	t
error	$HARELIB/bufio/scanner.ha	/^export fn scan_byte(scan: *scanner) (u8 | io::EOF | io::error) = {$/;"	f
error	$HARELIB/bufio/stream.ha	/^export fn flush(s: io::handle) (void | io::error) = {$/;"	f
error	$HARELIB/crypto/ec/keygen.ha	/^export fn keygen(c: *curve, priv: []u8, rand: io::handle) (size | io::error) =$/;"	f
error	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn newkey(priv: *privkey, rand: io::handle) (void | io::error) =$/;"	f
error	$HARELIB/crypto/keystore/impl+linux.ha	/^export fn newkey(buf: []u8, name: str) (key | errors::error) = {$/;"	f
error	$HARELIB/crypto/keystore/impl.ha	/^export fn newkey(buf: []u8, name: str) (key | errors::error) = {$/;"	f
error	$HARELIB/crypto/rsa/errors.ha	/^export type error = !($/;"	t
error	$HARELIB/debug/dwarf/line.ha	/^export fn line_next(prog: *line_program) (line_state | io::EOF | io::error) = {$/;"	f
error	$HARELIB/debug/image/self+darwin.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
error	$HARELIB/debug/image/self+freebsd.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
error	$HARELIB/debug/image/self+linux.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
error	$HARELIB/debug/image/self+openbsd.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
error	$HARELIB/dirs/xdg.ha	/^export fn runtime() (str | fs::error) = {$/;"	f
error	$HARELIB/encoding/asn1/encoder.ha	/^export fn encodeto(e: *encoder, dest: io::handle) (size | io::error) = {$/;"	f
error	$HARELIB/encoding/asn1/errors.ha	/^export type error = !(...io::error | ...asn1error);$/;"	t
error	$HARELIB/encoding/asn1/oid.ha	/^export fn strrawoid(der: []u8) (str | io::error) = {$/;"	f
error	$HARELIB/encoding/hex/hex.ha	/^export fn encode(out: io::handle, in: []u8) (size | io::error) = {$/;"	f
error	$HARELIB/encoding/pem/pem.ha	/^export fn strerror(err: io::error) const str = {$/;"	f
error	$HARELIB/errors/common.ha	/^export type error = !($/;"	t
error	$HARELIB/fmt/print.ha	/^export fn fprint(h: io::handle, args: formattable...) (io::error | size) = {$/;"	f
error	$HARELIB/fmt/wrappers.ha	/^export fn println(args: formattable...) (io::error | size) =$/;"	f
error	$HARELIB/format/ini/types.ha	/^export type error = !(io::error | utf8::invalid | syntaxerr);$/;"	t
error	$HARELIB/format/tar/reader.ha	/^export fn skip(ent: *entry) (void | io::error) = {$/;"	f
error	$HARELIB/format/tar/types.ha	/^export type error = !(invalid | io::error);$/;"	t
error	$HARELIB/fs/types.ha	/^export type error = !($/;"	t
error	$HARELIB/getopt/getopts.ha	/^export type error = !($/;"	t
error	$HARELIB/hare/lex/lex.ha	/^export type error = !(io::error | syntax);$/;"	t
error	$HARELIB/hare/module/format.ha	/^export fn format_srcset(out: io::handle, srcs: *srcset) (size | io::error) = {$/;"	f
error	$HARELIB/hare/module/types.ha	/^export type error = !($/;"	t
error	$HARELIB/hare/module/util.ha	/^export fn next(it: *fs::iterator) (fs::dirent | void | fs::error) = {$/;"	f
error	$HARELIB/hare/parse/doc/doc.ha	/^export type error = !lex::error;$/;"	t
error	$HARELIB/hare/parse/parse.ha	/^export type error = !lex::error;$/;"	t
error	$HARELIB/hare/types/store.ha	/^export type error = !(noresolver | errors::opaque_);$/;"	t
error	$HARELIB/hare/unit/errors.ha	/^export type error = !(types::error | void);$/;"	t
error	$HARELIB/hare/unparse/ident.ha	/^export fn ident(out: io::handle, id: ast::ident) (size | io::error) = {$/;"	f
error	$HARELIB/hare/unparse/syn.ha	/^export fn syn_wrap(ctx: *context, s: str, kind: synkind) (size | io::error) = {$/;"	f
error	$HARELIB/io/+darwin/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
error	$HARELIB/io/+freebsd/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
error	$HARELIB/io/+linux/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
error	$HARELIB/io/+openbsd/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
error	$HARELIB/io/types.ha	/^export type error = !(...errors::error | underread);$/;"	t
error	$HARELIB/linux/keyctl/+linux/types.ha	/^export type error = !(nokey | errors::error);$/;"	t
error	$HARELIB/memio/ops.ha	/^export fn rjoin(out: io::handle, delim: str, strs: str...) (size | io::error) = {$/;"	f
error	$HARELIB/net/dial/registry.ha	/^export type error = !(invalid_address | unknown_service | net::error | dns::error$/;"	t
error	$HARELIB/net/dns/error.ha	/^export type error = !(format | server_failure | name_error$/;"	t
error	$HARELIB/net/errors.ha	/^export type error = !(unknownproto | ...errors::error);$/;"	t
error	$HARELIB/net/ip/ip.ha	/^export fn fmt(s: io::handle, item: (...addr | subnet)) (size | io::error) = {$/;"	f
error	$HARELIB/net/udp/+darwin.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
error	$HARELIB/net/udp/+freebsd.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
error	$HARELIB/net/udp/+linux.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
error	$HARELIB/net/udp/+openbsd.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
error	$HARELIB/net/unix/socketpair.ha	/^export fn socketpair(flags: net::sockflag...) ((net::socket, net::socket) | net::error) = {$/;"	f
error	$HARELIB/net/uri/fmt.ha	/^export fn fmt(out: io::handle, u: *const uri) (size | io::error) = {$/;"	f
error	$HARELIB/os/+darwin/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
error	$HARELIB/os/+darwin/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
error	$HARELIB/os/+freebsd/fs.ha	/^export fn chroot(target: str) (void | fs::error) = {$/;"	f
error	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
error	$HARELIB/os/+linux/fs.ha	/^export fn mkfile(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
error	$HARELIB/os/+linux/memory.ha	/^export fn munlockall() (void | errors::error) = {$/;"	f
error	$HARELIB/os/+linux/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
error	$HARELIB/os/+openbsd/fs.ha	/^export fn mkfile(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
error	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn cpucount() (size | errors::error) = {$/;"	f
error	$HARELIB/os/exec/+darwin/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
error	$HARELIB/os/exec/+freebsd/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
error	$HARELIB/os/exec/+linux/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
error	$HARELIB/os/exec/+openbsd/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
error	$HARELIB/os/exec/types.ha	/^export type error = !(nocmd | ...errors::error | io::error | fs::error);$/;"	t
error	$HARELIB/os/os.ha	/^export fn symlink(target: str, path: str) (void | fs::error) =$/;"	f
error	$HARELIB/path/error.ha	/^export type error = !(cant_extend | too_long | not_prefix);$/;"	t
error	$HARELIB/regex/regex.ha	/^export type error = !str;$/;"	t
error	$HARELIB/shlex/escape.ha	/^export fn quote(sink: io::handle, s: str) (size | io::error) = {$/;"	f
error	$HARELIB/strconv/types.ha	/^export type error = !(invalid | overflow);$/;"	t
error	$HARELIB/temp/+darwin.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
error	$HARELIB/temp/+freebsd.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
error	$HARELIB/temp/+linux.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
error	$HARELIB/time/chrono/error.ha	/^export type error = !($/;"	t
error	$HARELIB/time/date/error.ha	/^export type error = !(insufficient | invalid | parsefail);$/;"	t
error	$HARELIB/time/date/format.ha	/^export fn asformat(layout: str, d: *date) (str | io::error) = {$/;"	f
error	$HARELIB/unix/+darwin/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+darwin/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
error	$HARELIB/unix/+freebsd/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+freebsd/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
error	$HARELIB/unix/+linux/creds.ha	/^export fn setpgid(targ: pid, pgid: pid) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+linux/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+linux/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
error	$HARELIB/unix/+openbsd/creds.ha	/^export fn setpgid(targ: pid, pgid: pid) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+openbsd/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/+openbsd/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
error	$HARELIB/unix/hosts/hosts.ha	/^export type error = !(io::error | invalid | utf8::invalid | ip::invalid$/;"	t
error	$HARELIB/unix/passwd/group.ha	/^export fn nextgr(in: io::handle) (grent | io::EOF | io::error | invalid) = {$/;"	f
error	$HARELIB/unix/passwd/passwd.ha	/^export fn nextpw(in: io::handle) (pwent | io::EOF | io::error | invalid) = {$/;"	f
error	$HARELIB/unix/poll/types.ha	/^export type error = !errors::error;$/;"	t
error	$HARELIB/unix/signal/+linux.ha	/^export fn update(fd: io::file, signals: sig...) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+darwin/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+darwin/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
error	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+freebsd/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+freebsd/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
error	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+linux/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+linux/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
error	$HARELIB/unix/tty/+linux/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+openbsd/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/+openbsd/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
error	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
error	$HARELIB/unix/tty/types.ha	/^export type error = !(errors::invalid$/;"	t
error	$HARELIB/uuid/uuid.ha	/^export fn uri(out: io::handle, in: uuid) (size | io::error) = {$/;"	f
error	$HARELIB/wordexp/error.ha	/^export type error = !(io::error | exec::error | utf8::invalid | sh_error);$/;"	t
error_assert_expr	$HARELIB/hare/ast/expr.ha	/^export type error_assert_expr = *expr;$/;"	t
errorf	$HARELIB/fmt/wrappers.ha	/^export fn errorf(fmt: str, args: field...) (io::error | size) =$/;"	f
errorfln	$HARELIB/fmt/wrappers.ha	/^export fn errorfln(fmt: str, args: field...) (io::error | size) =$/;"	f
errorln	$HARELIB/fmt/wrappers.ha	/^export fn errorln(args: formattable...) (io::error | size) =$/;"	f
event	$HARELIB/unix/poll/+darwin.ha	/^export type event = enum i16 {$/;"	t
event	$HARELIB/unix/poll/+freebsd.ha	/^export type event = enum i16 {$/;"	t
event	$HARELIB/unix/poll/+linux.ha	/^export type event = enum i16 {$/;"	t
event	$HARELIB/unix/poll/+openbsd.ha	/^export type event = enum i16 {$/;"	t
eventfd	$HARELIB/rt/+linux/syscalls.ha	/^export fn eventfd(initval: uint, flags: int) (int | errno) = {$/;"	f
ewordlen	$HARELIB/crypto/bigint/encoding.ha	/^export fn ewordlen(x: const []word) u32 = {$/;"	f
exec	$HARELIB/os/exec/cmd.ha	/^export fn exec(cmd: *command) never = {$/;"	f
exec_line_program	$HARELIB/debug/dwarf/line.ha	/^export fn exec_line_program($/;"	f
execute	$HARELIB/strings/template/template.ha	/^export fn execute($/;"	f
execve	$HARELIB/rt/+darwin/syscalls.ha	/^export fn execve($/;"	f
execve	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn execve($/;"	f
execve	$HARELIB/rt/+linux/syscalls.ha	/^export fn execve(path: path, argv: *[*]nullable *const u8,$/;"	f
execve	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn execve(path: path, argv: *[*]nullable *const u8,$/;"	f
execveat	$HARELIB/rt/+linux/syscalls.ha	/^export fn execveat(dirfd: int, path: path, argv: *[*]nullable *const u8,$/;"	f
exists	$HARELIB/errors/common.ha	/^export type exists = !void;$/;"	t
exists	$HARELIB/fs/fs.ha	/^export fn exists(fs: *fs, path: str) bool = {$/;"	f
exists	$HARELIB/os/os.ha	/^export fn exists(path: str) bool = fs::exists(cwd, path);$/;"	f
exit	$HARELIB/os/+darwin/exit+test.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+darwin/exit.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+freebsd/exit+test.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+freebsd/exit.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+linux/exit+test.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+linux/exit.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+openbsd/exit+test.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/+openbsd/exit.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/os/exec/+darwin/process.ha	/^export fn exit(stat: *status) exit_status = {$/;"	f
exit	$HARELIB/os/exec/+freebsd/process.ha	/^export fn exit(stat: *status) exit_status = {$/;"	f
exit	$HARELIB/os/exec/+linux/process.ha	/^export fn exit(stat: *status) exit_status = {$/;"	f
exit	$HARELIB/os/exec/+openbsd/process.ha	/^export fn exit(stat: *status) exit_status = {$/;"	f
exit	$HARELIB/rt/+darwin/syscalls.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn exit(status: int) never = c_exit(status);$/;"	f
exit	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn exit(status: int) never = {$/;"	f
exit	$HARELIB/rt/+linux/syscalls.ha	/^export fn exit(status: int) never = {$/;"	f
exit_status	$HARELIB/os/exec/+darwin/process.ha	/^export type exit_status = (exited | signaled);$/;"	t
exit_status	$HARELIB/os/exec/+freebsd/process.ha	/^export type exit_status = (exited | signaled);$/;"	t
exit_status	$HARELIB/os/exec/+linux/process.ha	/^export type exit_status = (exited | signaled);$/;"	t
exit_status	$HARELIB/os/exec/+openbsd/process.ha	/^export type exit_status = (exited | signaled);$/;"	t
exited	$HARELIB/os/exec/+darwin/process.ha	/^export type exited = int;$/;"	t
exited	$HARELIB/os/exec/+freebsd/process.ha	/^export type exited = int;$/;"	t
exited	$HARELIB/os/exec/+linux/process.ha	/^export type exited = int;$/;"	t
exited	$HARELIB/os/exec/+openbsd/process.ha	/^export type exited = int;$/;"	t
exitstr	$HARELIB/os/exec/+darwin/process.ha	/^export fn exitstr(status: exit_status) const str = {$/;"	f
exitstr	$HARELIB/os/exec/+freebsd/process.ha	/^export fn exitstr(status: exit_status) const str = {$/;"	f
exitstr	$HARELIB/os/exec/+linux/process.ha	/^export fn exitstr(status: exit_status) const str = {$/;"	f
exitstr	$HARELIB/os/exec/+openbsd/process.ha	/^export fn exitstr(status: exit_status) const str = {$/;"	f
exp2f64	$HARELIB/math/math.ha	/^export fn exp2f64(x: f64) f64 = {$/;"	f
expand	$HARELIB/crypto/hkdf/hkdf.ha	/^export fn expand($/;"	f
expc128	$HARELIB/math/complex/complex.ha	/^export fn expc128(z: c128) c128 = {$/;"	f
expect_implicit	$HARELIB/encoding/asn1/decoder.ha	/^export fn expect_implicit(d: *decoder, c: class, tag: u32) (void | error) = {$/;"	f
expectabort	$HARELIB/test/util+test.ha	/^export fn expectabort() void = {$/;"	f
expectabort	$HARELIB/test/util.ha	/^export fn expectabort() void = {$/;"	f
expf64	$HARELIB/math/math.ha	/^export fn expf64(x: f64) f64 = {$/;"	f
expiration	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type expiration = (oneshot | interval | interval_delayed);$/;"	t
expmultif64	$HARELIB/math/math.ha	/^export fn expmultif64(hi: f64, lo: f64, k: i64) f64 = {$/;"	f
expr	$HARELIB/hare/ast/expr.ha	/^export type expr = struct {$/;"	t
expr	$HARELIB/hare/parse/expr.ha	/^export fn expr(lexer: *lex::lexer) (ast::expr | error) = {$/;"	f
expr	$HARELIB/hare/unit/expr.ha	/^export type expr = struct {$/;"	t
expr	$HARELIB/hare/unparse/expr.ha	/^export fn expr($/;"	f
expr_finish	$HARELIB/hare/ast/expr.ha	/^export fn expr_finish(e: nullable *expr) void = match (e) {$/;"	f
extract	$HARELIB/crypto/hkdf/hkdf.ha	/^export fn extract($/;"	f
f32bits	$HARELIB/math/floats.ha	/^export fn f32bits(n: f32) u32 = *(&n: *u32);$/;"	f
f32frombits	$HARELIB/math/floats.ha	/^export fn f32frombits(n: u32) f32 = *(&n: *f32);$/;"	f
f32tos	$HARELIB/strconv/ftos.ha	/^export fn f32tos(n: f32) const str = {$/;"	f
f64bits	$HARELIB/math/floats.ha	/^export fn f64bits(n: f64) u64 = *(&n: *u64);$/;"	f
f64frombits	$HARELIB/math/floats.ha	/^export fn f64frombits(n: u64) f64 = *(&n: *f64);$/;"	f
f64rand	$HARELIB/math/random/random.ha	/^export fn f64rand(r: *random) f64 = {$/;"	f
f64tos	$HARELIB/strconv/ftos.ha	/^export fn f64tos(n: f64) const str = {$/;"	f
f_ext_state	$HARELIB/rt/+linux/+riscv64.ha	/^export type f_ext_state = struct {$/;"	t
f_owner_ex	$HARELIB/rt/+linux/types.ha	/^export type f_owner_ex = struct {$/;"	t
faccessat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn faccessat($/;"	f
faccessat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn faccessat($/;"	f
faccessat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn faccessat($/;"	f
faccessat	$HARELIB/rt/+linux/syscalls.ha	/^export fn faccessat($/;"	f
failure	$HARELIB/glob/glob.ha	/^export type failure = !struct {$/;"	t
fallocate	$HARELIB/rt/+linux/syscalls.ha	/^export fn fallocate(fd: int, mode: int, off: i64, ln: i64) (void | errno) = {$/;"	f
fatal	$HARELIB/fmt/wrappers.ha	/^export fn fatal(args: formattable...) never = {$/;"	f
fatal	$HARELIB/log/funcs.ha	/^export fn fatal(fields: fmt::formattable...) never = {$/;"	f
fatalf	$HARELIB/fmt/wrappers.ha	/^export fn fatalf(fmt: str, args: field...) never = {$/;"	f
fatalf	$HARELIB/log/funcs.ha	/^export fn fatalf(fmt: str, fields: fmt::field...) never = {$/;"	f
fchdir	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fchdir(fd: int) (void | errno) = {$/;"	f
fchdir	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fchdir(fd: int) (void | errno) = {$/;"	f
fchdir	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fchdir(fd: int) (void | errno) = {$/;"	f
fchdir	$HARELIB/rt/+linux/syscalls.ha	/^export fn fchdir(fd: int) (void | errno) = {$/;"	f
fchdir	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fchdir(fd: int) (void | errno) = {$/;"	f
fchmodat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fchmodat(dirfd: int, path: path, mode: uint, flags: int) (void | errno) = {$/;"	f
fchmodat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fchmodat(dirfd: int, path: path, mode: uint, flags: int) (void | errno) = {$/;"	f
fchmodat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fchmodat(dirfd: int, path: path, mode: uint, flags: int) (void | errno) = {$/;"	f
fchmodat	$HARELIB/rt/+linux/syscalls.ha	/^export fn fchmodat(dirfd: int, path: path, mode: uint, flags: int) (void | errno) = {$/;"	f
fchmodat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fchmodat($/;"	f
fchownat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fchownat(dirfd: int, path: path, uid: uint, gid: uint, flags: int) (void | errno) = {$/;"	f
fchownat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fchownat(dirfd: int, path: path, uid: uint, gid: uint, flags: int) (void | errno) = {$/;"	f
fchownat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fchownat(dirfd: int, path: path, uid: uint, gid: uint, flags: int) (void | errno) = {$/;"	f
fchownat	$HARELIB/rt/+linux/syscalls.ha	/^export fn fchownat(dirfd: int, path: path, uid: uint, gid: uint, flags: int) (void | errno) = {$/;"	f
fchownat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fchownat($/;"	f
fcntl	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fcntl(fd: int, cmd: int, arg: fcntl_arg) (int | errno) = {$/;"	f
fcntl	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fcntl(fd: int, cmd: int, arg: fcntl_arg) (int | errno) = {$/;"	f
fcntl	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fcntl(fd: int, cmd: int, arg: fcntl_arg) (int | errno) = {$/;"	f
fcntl	$HARELIB/rt/+linux/syscalls.ha	/^export fn fcntl(fd: int, cmd: int, arg: fcntl_arg) (int | errno) = {$/;"	f
fcntl	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fcntl(fd: int, cmd: int, arg: fcntl_arg) (int | errno) = {$/;"	f
fcntl_arg	$HARELIB/rt/+darwin/syscalls.ha	/^export type fcntl_arg = (void | int | *st_flock | *u64 | *[*]u8);$/;"	t
fcntl_arg	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export type fcntl_arg = (void | int | *st_flock | *u64 | *[*]u8);$/;"	t
fcntl_arg	$HARELIB/rt/+freebsd/syscalls.ha	/^export type fcntl_arg = (void | int | *st_flock | *u64);$/;"	t
fcntl_arg	$HARELIB/rt/+linux/syscalls.ha	/^export type fcntl_arg = (void | int | *st_flock | *f_owner_ex | *u64);$/;"	t
fcntl_arg	$HARELIB/rt/+openbsd/syscalls.ha	/^export type fcntl_arg = (void | int | *st_flock | *u64);$/;"	t
fdopen	$HARELIB/io/+darwin/platform_file.ha	/^export fn fdopen(fd: int) file = fd;$/;"	f
fdopen	$HARELIB/io/+freebsd/platform_file.ha	/^export fn fdopen(fd: int) file = fd;$/;"	f
fdopen	$HARELIB/io/+linux/platform_file.ha	/^export fn fdopen(fd: int) file = fd;$/;"	f
fdopen	$HARELIB/io/+openbsd/platform_file.ha	/^export fn fdopen(fd: int) file = fd;$/;"	f
feclearexcept	$HARELIB/rt/fenv_defs.ha	/^export fn feclearexcept(ex: uint) void;$/;"	f
fegetround	$HARELIB/rt/fenv_defs.ha	/^export fn fegetround() uint;$/;"	f
feraiseexcept	$HARELIB/rt/fenv_defs.ha	/^export fn feraiseexcept(ex: uint) void;$/;"	f
fesetround	$HARELIB/rt/fenv_defs.ha	/^export fn fesetround(mode: uint) void;$/;"	f
fetestexcept	$HARELIB/rt/fenv_defs.ha	/^export fn fetestexcept(ex: uint) uint;$/;"	f
fexcept	$HARELIB/math/fenv+aarch64.ha	/^export type fexcept = enum uint {$/;"	t
fexcept	$HARELIB/math/fenv+riscv64.ha	/^export type fexcept = enum uint {$/;"	t
fexcept	$HARELIB/math/fenv+x86_64.ha	/^export type fexcept = enum uint {$/;"	t
fexecve	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fexecve(fd: int, argv: *[*]nullable *const u8,$/;"	f
fexecve	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fexecve(fd: int, argv: *[*]nullable *const char,$/;"	f
fexecve	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fexecve(fd: int, argv: *[*]nullable *const u8,$/;"	f
fflags	$HARELIB/strconv/ftos.ha	/^export type fflags = enum uint {$/;"	t
fflags_t	$HARELIB/rt/+darwin/types.ha	/^export type fflags_t    = u32;$/;"	t
fflags_t	$HARELIB/rt/+freebsd/types.ha	/^export type fflags_t = u32;$/;"	t
ffmt	$HARELIB/strconv/ftos.ha	/^export type ffmt = enum {$/;"	t
fftosf	$HARELIB/strconv/ftos.ha	/^export fn fftosf($/;"	f
field	$HARELIB/debug/dwarf/info.ha	/^export type field = struct {$/;"	t
field	$HARELIB/fmt/iter.ha	/^export type field = (...formattable | *mods);$/;"	t
field	$HARELIB/log/funcs.ha	/^export fn printfln(fmt: str, fields: fmt::field...) void = {$/;"	f
file	$HARELIB/fs/fs.ha	/^export fn open_file(fs: *fs, path: str, flags: flag...) (io::file | error) = {$/;"	f
file	$HARELIB/io/+darwin/platform_file.ha	/^export type file = int;$/;"	t
file	$HARELIB/io/+freebsd/platform_file.ha	/^export type file = int;$/;"	t
file	$HARELIB/io/+linux/platform_file.ha	/^export type file = int;$/;"	t
file	$HARELIB/io/+openbsd/platform_file.ha	/^export type file = int;$/;"	t
file	$HARELIB/net/unix/cmsg.ha	/^export fn recvfiles(buf: *net::msghdr, nfile: size) []io::file = {$/;"	f
file	$HARELIB/os/+darwin/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
file	$HARELIB/os/+freebsd/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
file	$HARELIB/os/+linux/dirfdfs.ha	/^export fn dirfile(fs: *fs::fs) io::file = {$/;"	f
file	$HARELIB/os/exec/+darwin/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
file	$HARELIB/os/exec/+darwin/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
file	$HARELIB/os/exec/+freebsd/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
file	$HARELIB/os/exec/+freebsd/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
file	$HARELIB/os/exec/+linux/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
file	$HARELIB/os/exec/+linux/platform_cmd.ha	/^export fn cmdfile(file: io::file, name: str, args: str...) command = {$/;"	f
file	$HARELIB/os/exec/+openbsd/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
file	$HARELIB/temp/+darwin.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
file	$HARELIB/temp/+freebsd.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
file	$HARELIB/temp/+linux.ha	/^export fn file(iomode: io::mode, mode: fs::mode) (io::file | fs::error) = {$/;"	f
file	$HARELIB/unix/tty/+darwin/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
file	$HARELIB/unix/tty/+darwin/open.ha	/^export fn open() (io::file | error) = {$/;"	f
file	$HARELIB/unix/tty/+darwin/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
file	$HARELIB/unix/tty/+darwin/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
file	$HARELIB/unix/tty/+freebsd/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
file	$HARELIB/unix/tty/+freebsd/open.ha	/^export fn open() (io::file | error) = {$/;"	f
file	$HARELIB/unix/tty/+freebsd/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
file	$HARELIB/unix/tty/+freebsd/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
file	$HARELIB/unix/tty/+linux/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
file	$HARELIB/unix/tty/+linux/open.ha	/^export fn open() (io::file | error) = {$/;"	f
file	$HARELIB/unix/tty/+linux/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
file	$HARELIB/unix/tty/+linux/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
file	$HARELIB/unix/tty/+openbsd/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
file	$HARELIB/unix/tty/+openbsd/open.ha	/^export fn open() (io::file | error) = {$/;"	f
file	$HARELIB/unix/tty/+openbsd/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
file	$HARELIB/unix/tty/+openbsd/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
file_conflict	$HARELIB/hare/module/types.ha	/^export type file_conflict = ![]str;$/;"	t
filestat	$HARELIB/fs/types.ha	/^export type filestat = struct {$/;"	t
find	$HARELIB/hare/module/srcs.ha	/^export fn find(ctx: *context, loc: location) ((str, srcset) | error) = {$/;"	f
find	$HARELIB/regex/regex.ha	/^export fn find(re: *regex, string: str) result = {$/;"	f
findall	$HARELIB/regex/regex.ha	/^export fn findall(re: *regex, string: str) []result = {$/;"	f
fini	$HARELIB/rt/+darwin/initfini.ha	/^export fn fini() void = {$/;"	f
fini	$HARELIB/rt/+freebsd/initfini.ha	/^export fn fini() void = {$/;"	f
fini	$HARELIB/rt/+linux/initfini.ha	/^export fn fini() void = {$/;"	f
finish	$HARELIB/bufio/scanner.ha	/^export fn finish(scan: *scanner) void = {$/;"	f
finish	$HARELIB/crypto/aes/xts/xts.ha	/^export fn finish(b: *block) void = {$/;"	f
finish	$HARELIB/crypto/cipher/cipher.ha	/^export fn finish(a: *block) void = {$/;"	f
finish	$HARELIB/crypto/mac/mac.ha	/^export fn finish(m: *mac) void = {$/;"	f
finish	$HARELIB/encoding/asn1/decoder.ha	/^export fn finish(d: *decoder) (void | error) = {$/;"	f
finish	$HARELIB/encoding/pem/pem.ha	/^export fn finish(dec: *decoder) void = {$/;"	f
finish	$HARELIB/format/ini/scan.ha	/^export fn finish(sc: *scanner) void = {$/;"	f
finish	$HARELIB/fs/fs.ha	/^export fn finish(iter: *iterator) void = {$/;"	f
finish	$HARELIB/getopt/getopts.ha	/^export fn finish(cmd: *command) void = {$/;"	f
finish	$HARELIB/glob/glob.ha	/^export fn finish(gen: *generator) void = {$/;"	f
finish	$HARELIB/hare/module/deps.ha	/^export fn finish(mod: *module) void = {$/;"	f
finish	$HARELIB/net/msg.ha	/^export fn finish(msg: *msghdr) void = {$/;"	f
finish	$HARELIB/net/uri/uri.ha	/^export fn finish(u: *uri) void = {$/;"	f
finish	$HARELIB/os/exec/cmd.ha	/^export fn finish(cmd: *command) void = {$/;"	f
finish	$HARELIB/regex/regex.ha	/^export fn finish(re: *regex) void = {$/;"	f
finish	$HARELIB/strings/template/template.ha	/^export fn finish(tmpl: *template) void = {$/;"	f
finish	$HARELIB/unix/hosts/hosts.ha	/^export fn finish(host: host) void = {$/;"	f
finish_error	$HARELIB/hare/module/types.ha	/^export fn finish_error(e: error) void = {$/;"	f
finish_explicit	$HARELIB/encoding/asn1/encoder.ha	/^export fn finish_explicit(e: *encoder) void = finish_cons(e);$/;"	f
finish_seq	$HARELIB/encoding/asn1/encoder.ha	/^export fn finish_seq(e: *encoder) void = finish_cons(e);$/;"	f
finish_srcset	$HARELIB/hare/module/srcs.ha	/^export fn finish_srcset(srcs: *srcset) void = {$/;"	f
finishfunc	$HARELIB/fs/types.ha	/^export type finishfunc = fn(iter: *iterator) void;$/;"	t
fixed	$HARELIB/memio/stream.ha	/^export fn fixed(in: []u8) stream = stream {$/;"	f
fixedzone	$HARELIB/time/chrono/timezone.ha	/^export fn fixedzone(ts: *timescale, daylen: time::duration, z: zone) timezone = {$/;"	f
flag	$HARELIB/fnmatch/fnmatch.ha	/^export type flag = enum uint {$/;"	t
flag	$HARELIB/fs/types.ha	/^export type flag = enum int {$/;"	t
flag	$HARELIB/glob/glob.ha	/^export type flag = enum uint {$/;"	t
flag	$HARELIB/hare/lex/lex.ha	/^export type flag = enum uint {$/;"	t
flag	$HARELIB/hare/types/types.ha	/^export type flag = enum u8 {$/;"	t
flag	$HARELIB/unix/signal/+darwin.ha	/^export type flag = enum int {$/;"	t
flag	$HARELIB/unix/signal/+freebsd.ha	/^export type flag = enum int {$/;"	t
flag	$HARELIB/unix/signal/+linux.ha	/^export type flag = enum int {$/;"	t
flag	$HARELIB/unix/signal/+openbsd.ha	/^export type flag = enum int {$/;"	t
flag	$HARELIB/wordexp/wordexp.ha	/^export type flag = enum uint {$/;"	t
flag_help	$HARELIB/getopt/getopts.ha	/^export type flag_help = (rune, str);$/;"	t
floatinfo	$HARELIB/math/floats.ha	/^export type floatinfo = struct {$/;"	t
floating	$HARELIB/math/floats.ha	/^export fn signf(x: types::floating) i64 = {$/;"	f
floating	$HARELIB/math/math.ha	/^export fn isclose(x: types::floating, y: types::floating) bool = {$/;"	f
floating	$HARELIB/strconv/numeric.ha	/^export fn floatingtosb(n: types::floating, b: base) const str = {$/;"	f
floating	$HARELIB/types/classes.ha	/^export type floating = (f32 | f64);$/;"	t
floatingtos	$HARELIB/strconv/numeric.ha	/^export fn floatingtos(n: types::floating) const str = floatingtosb(n, base::DEC);$/;"	f
floatingtosb	$HARELIB/strconv/numeric.ha	/^export fn floatingtosb(n: types::floating, b: base) const str = {$/;"	f
flock	$HARELIB/rt/+darwin/syscalls.ha	/^export fn flock(fd: int, op: int) (void | errno) = {$/;"	f
flock	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn flock(fd: int, op: int) (void | errno) = {$/;"	f
flock	$HARELIB/rt/+linux/syscalls.ha	/^export fn flock(fd: int, op: int) (void | errno) = {$/;"	f
flock	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn flock(fd: int, op: int) (void | errno) = {$/;"	f
floorf64	$HARELIB/math/math.ha	/^export fn floorf64(x: f64) f64 = {$/;"	f
flush	$HARELIB/bufio/stream.ha	/^export fn flush(s: io::handle) (void | io::error) = {$/;"	f
fmt	$HARELIB/net/ip/ip.ha	/^export fn fmt(s: io::handle, item: (...addr | subnet)) (size | io::error) = {$/;"	f
fmt	$HARELIB/net/uri/fmt.ha	/^export fn fmt(out: io::handle, u: *const uri) (size | io::error) = {$/;"	f
fndecl_attr	$HARELIB/hare/ast/decl.ha	/^export type fndecl_attr = enum {$/;"	t
fnmatch	$HARELIB/fnmatch/fnmatch.ha	/^export fn fnmatch(pattern: str, string: str, flags: flag...) bool = {$/;"	f
fnv32	$HARELIB/hash/fnv/fnv.ha	/^export fn fnv32() state32 = state32 {$/;"	f
fnv32a	$HARELIB/hash/fnv/fnv.ha	/^export fn fnv32a() state32 = state32 {$/;"	f
fnv64	$HARELIB/hash/fnv/fnv.ha	/^export fn fnv64() state64 = state64 {$/;"	f
fnv64a	$HARELIB/hash/fnv/fnv.ha	/^export fn fnv64a() state64 = state64 {$/;"	f
foo	$HARELIB/hare/parse/+test/types.ha	/^export type foo = fn(int...) void;$/;"	t
foo	$HARELIB/hare/parse/+test/unit_test.ha	/^	roundtrip("export type foo::bar = *int, baz = const void;\\n\\n"$/;"	t
for_expr	$HARELIB/hare/ast/expr.ha	/^export type for_expr = struct {$/;"	t
fork	$HARELIB/os/exec/+darwin/exec.ha	/^export fn fork() (process | void | error) = {$/;"	f
fork	$HARELIB/os/exec/+freebsd/exec.ha	/^export fn fork() (process | void | error) = {$/;"	f
fork	$HARELIB/os/exec/+linux/exec.ha	/^export fn fork() (process | void | error) = {$/;"	f
fork	$HARELIB/os/exec/+openbsd/exec.ha	/^export fn fork() (process | void | error) = {$/;"	f
fork	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fork() (pid_t | void | errno) = {$/;"	f
fork	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fork() (int | void | errno) = {$/;"	f
fork	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fork() (pid_t | void | errno) = {$/;"	f
fork	$HARELIB/rt/+linux/syscalls.ha	/^export fn fork() (pid_t | void | errno) = {$/;"	f
fork	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fork() (int | void | errno) = {$/;"	f
format	$HARELIB/hare/module/format.ha	/^export fn format(out: io::handle, mod: *module) (size | io::error) = {$/;"	f
format	$HARELIB/net/dns/error.ha	/^export type format = !void;$/;"	t
format	$HARELIB/time/date/format.ha	/^export fn format($/;"	f
format_srcset	$HARELIB/hare/module/format.ha	/^export fn format_srcset(out: io::handle, srcs: *srcset) (size | io::error) = {$/;"	f
format_tags	$HARELIB/hare/module/format.ha	/^export fn format_tags($/;"	f
formattable	$HARELIB/fmt/iter.ha	/^export type formattable = (...types::numeric | uintptr | str | rune | bool |$/;"	t
formattable	$HARELIB/log/funcs.ha	/^export fn println(fields: fmt::formattable...) void = {$/;"	f
fp_state	$HARELIB/rt/+linux/+riscv64.ha	/^export type fp_state = union {$/;"	t
fpregs	$HARELIB/rt/+darwin/+aarch64.ha	/^export type fpregs = struct {$/;"	t
fpregs	$HARELIB/rt/+darwin/+riscv64.ha	/^export type fpregs = struct {$/;"	t
fpregs	$HARELIB/rt/+freebsd/+aarch64.ha	/^export type fpregs = struct {$/;"	t
fpregs	$HARELIB/rt/+freebsd/+riscv64.ha	/^export type fpregs = struct {$/;"	t
fprint	$HARELIB/fmt/print.ha	/^export fn fprint(h: io::handle, args: formattable...) (io::error | size) = {$/;"	f
fprintf	$HARELIB/fmt/print.ha	/^export fn fprintf($/;"	f
fprintfln	$HARELIB/fmt/wrappers.ha	/^export fn fprintfln($/;"	f
fprintln	$HARELIB/fmt/wrappers.ha	/^export fn fprintln(h: io::handle, args: formattable...) (io::error | size) =$/;"	f
frame_pc	$HARELIB/debug/+aarch64/walk.ha	/^export fn frame_pc(frame: stackframe) uintptr = frame.lr;$/;"	f
frame_pc	$HARELIB/debug/+riscv64/walk.ha	/^export fn frame_pc(frame: stackframe) uintptr = frame.ra;$/;"	f
frame_pc	$HARELIB/debug/+x86_64/walk.ha	/^export fn frame_pc(frame: stackframe) uintptr = frame.ip;$/;"	f
free_	$HARELIB/rt/malloc+debug.ha	/^export @symbol("rt.free") fn free_(_p: nullable *opaque) void = {$/;"	f
free_	$HARELIB/rt/malloc+libc.ha	/^export @symbol("rt.free") fn free_(p: nullable *opaque) void = {$/;"	f
free_	$HARELIB/rt/malloc.ha	/^export @symbol("rt.free") fn free_(p: nullable *opaque) void = {$/;"	f
free_expr	$HARELIB/hare/ast/expr.ha	/^export type free_expr = *expr;$/;"	t
free_slice	$HARELIB/hare/module/deps.ha	/^export fn free_slice(mods: []module) void = {$/;"	f
freeall	$HARELIB/hare/parse/doc/doc.ha	/^export fn freeall(doc: doc) void = {$/;"	f
freeall	$HARELIB/strings/dup.ha	/^export fn freeall(s: []str) void = {$/;"	f
freebsd11_dirent	$HARELIB/rt/+freebsd/types.ha	/^export type freebsd11_dirent = struct {$/;"	t
freebsd11_stat	$HARELIB/rt/+freebsd/types.ha	/^export type freebsd11_stat = struct {$/;"	t
frexp	$HARELIB/math/floats.ha	/^export fn frexp(n: types::floating) (f64, i64) = {$/;"	f
frexpf32	$HARELIB/math/floats.ha	/^export fn frexpf32(n: f32) (f32, i64) = {$/;"	f
frexpf64	$HARELIB/math/floats.ha	/^export fn frexpf64(n: f64) (f64, i64) = {$/;"	f
from_datetime	$HARELIB/time/chrono/chronology.ha	/^export fn from_datetime($/;"	f
from_instant	$HARELIB/time/date/date.ha	/^export fn from_instant(loc: chrono::locality, i: time::instant) date = {$/;"	f
from_moment	$HARELIB/time/date/date.ha	/^export fn from_moment(m: chrono::moment) date = {$/;"	f
from_native	$HARELIB/net/ip/+darwin.ha	/^export fn from_native(a: rt::sockaddr) (addr, u16)  = {$/;"	f
from_native	$HARELIB/net/ip/+freebsd.ha	/^export fn from_native(a: rt::sockaddr) (addr, u16)  = {$/;"	f
from_native	$HARELIB/net/ip/+linux.ha	/^export fn from_native(a: rt::sockaddr) (addr, u16)  = {$/;"	f
from_native	$HARELIB/net/ip/+openbsd.ha	/^export fn from_native(a: rt::sockaddr) (addr, u16)  = {$/;"	f
from_str	$HARELIB/time/date/date.ha	/^export fn from_str($/;"	f
from_unix	$HARELIB/time/conv.ha	/^export fn from_unix(u: i64) instant = instant {$/;"	f
fromhex	$HARELIB/crypto/bigint/+test/utils.ha	/^export fn fromhex(h: str) []word = {$/;"	f
fromhexmod	$HARELIB/crypto/bigint/+test/utils.ha	/^export fn fromhexmod(h: str, m: []word) []word = {$/;"	f
frommonty	$HARELIB/crypto/bigint/monty.ha	/^export fn frommonty(x: []word, m: const []word, m0i: word) void = {$/;"	f
fromrunes	$HARELIB/strings/runes.ha	/^export fn fromrunes(rs: []rune) str = {$/;"	f
fromstr	$HARELIB/types/c/strings.ha	/^export fn fromstr(s: const str) *char = {$/;"	f
fromstr_buf	$HARELIB/types/c/strings.ha	/^export fn fromstr_buf(s: const str, sl: []char) *char = {$/;"	f
fromutf8	$HARELIB/strings/utf8.ha	/^export fn fromutf8(in: []u8) (str | utf8::invalid) = {$/;"	f
fromutf8_unsafe	$HARELIB/strings/utf8.ha	/^export fn fromutf8_unsafe(in: []u8) str = {$/;"	f
fround	$HARELIB/math/fenv+aarch64.ha	/^export type fround = enum uint {$/;"	t
fround	$HARELIB/math/fenv+riscv64.ha	/^export type fround = enum uint {$/;"	t
fround	$HARELIB/math/fenv+x86_64.ha	/^export type fround = enum uint {$/;"	t
fstat	$HARELIB/fs/fs.ha	/^export fn fstat(fs: *fs, fd: io::file) (filestat | error) = {$/;"	f
fstat	$HARELIB/os/os.ha	/^export fn fstat(fd: io::file) (fs::filestat | fs::error) = fs::fstat(cwd, fd);$/;"	f
fstat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fstat(fd: int, stat: *st) (errno | void) =$/;"	f
fstat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fstat(fd: int, stat: *st) (errno | void) =$/;"	f
fstat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fstat(fd: int, stat: *st) (errno | void) =$/;"	f
fstat	$HARELIB/rt/+linux/stat.ha	/^export fn fstat(fd: int, statbuf: *st) (errno | void) =$/;"	f
fstatat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn fstatat(fd: int, path: path, stat: *st, flag: int) (void | errno) = {$/;"	f
fstatat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn fstatat(fd: int, path: path, stat: *st, flag: int) (void | errno) = {$/;"	f
fstatat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn fstatat(fd: int, path: path, stat: *st, flag: int) (void | errno) = {$/;"	f
fstatat	$HARELIB/rt/+linux/stat.ha	/^export fn fstatat($/;"	f
fstatat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn fstatat($/;"	f
fstatfunc	$HARELIB/fs/types.ha	/^export type fstatfunc = fn(fs: *fs, file: io::file) (filestat | error);$/;"	t
ftosf	$HARELIB/strconv/ftos.ha	/^export fn ftosf($/;"	f
ftruncate	$HARELIB/rt/+darwin/syscalls.ha	/^export fn ftruncate(fd: int, ln: off_t) (void | errno) = {$/;"	f
ftruncate	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn ftruncate(fd: int, ln: off_t) (void | errno) = {$/;"	f
ftruncate	$HARELIB/rt/+linux/syscalls.ha	/^export fn ftruncate(fd: int, ln: off_t) (void | errno) = {$/;"	f
ftruncate	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn ftruncate(fd: int, length: i64) (void | errno) = {$/;"	f
func	$HARELIB/hare/types/types.ha	/^export type func = struct {$/;"	t
func_param	$HARELIB/hare/ast/type.ha	/^export type func_param = struct {$/;"	t
func_type	$HARELIB/hare/ast/type.ha	/^export type func_type = struct {$/;"	t
fxsave64	$HARELIB/rt/+openbsd/+x86_64.ha	/^export type fxsave64 = struct {$/;"	t
gather	$HARELIB/hare/module/deps.ha	/^export fn gather($/;"	f
gcd	$HARELIB/math/uints.ha	/^export fn gcd(a: u64, b: u64) u64 = {$/;"	f
gcm	$HARELIB/crypto/cipher/gcm.ha	/^export fn gcm() gcmstream = {$/;"	f
gcm_init	$HARELIB/crypto/cipher/gcm.ha	/^export fn gcm_init($/;"	f
gcm_seal	$HARELIB/crypto/cipher/gcm.ha	/^export fn gcm_seal(s: *gcmstream, tag: []u8) void = {$/;"	f
gcm_verify	$HARELIB/crypto/cipher/gcm.ha	/^export fn gcm_verify(s: *gcmstream, tag: []u8) (void | errors::invalid) = {$/;"	f
gcmstream	$HARELIB/crypto/cipher/gcm.ha	/^export type gcmstream = struct {$/;"	t
generate	$HARELIB/crypto/bcrypt/bcrypt.ha	/^export fn generate(password: []u8, cost: uint) []u8 = {$/;"	f
generate	$HARELIB/uuid/uuid.ha	/^export fn generate() uuid = {$/;"	f
generator	$HARELIB/glob/glob.ha	/^export type generator = struct {$/;"	t
get_abbrev	$HARELIB/debug/dwarf/abbrev.ha	/^export fn get_abbrev(table: *abbrev_table, code: u64) const nullable *abbrev = {$/;"	f
get_cache	$HARELIB/hare/module/cache.ha	/^export fn get_cache(harecache: str, modpath: str) (str | error) = {$/;"	f
get_keyring_id	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn get_keyring_id(key: serial, create: bool) (serial | error) = {$/;"	f
get_strp	$HARELIB/debug/dwarf/strings.ha	/^export fn get_strp(table: *string_table, offs: u64) const str = {$/;"	f
getcontrol	$HARELIB/net/msg.ha	/^export fn getcontrol($/;"	f
getcwd	$HARELIB/os/+darwin/fs.ha	/^export fn getcwd() str = c::tostr(rt::getcwd() as *const u8: *const c::char)!;$/;"	f
getcwd	$HARELIB/os/+freebsd/fs.ha	/^export fn getcwd() str = c::tostr(rt::getcwd() as *const u8: *const c::char)!;$/;"	f
getcwd	$HARELIB/os/+linux/fs.ha	/^export fn getcwd() str = c::tostr(rt::getcwd() as *const u8: *const c::char)!;$/;"	f
getcwd	$HARELIB/os/+openbsd/fs.ha	/^export fn getcwd() str = c::tostr(rt::getcwd() as *const u8: *const c::char)!;$/;"	f
getcwd	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getcwd() (*const u8 | errno) = {$/;"	f
getcwd	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getcwd() (*const char | errno) = {$/;"	f
getcwd	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getcwd() (*const u8 | errno) = {$/;"	f
getcwd	$HARELIB/rt/+linux/syscalls.ha	/^export fn getcwd() (*const u8 | errno) = {$/;"	f
getcwd	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getcwd() (*const u8 | errno) = {$/;"	f
getdents	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getdents(dirfd: int, buf: *opaque, nbytes: size) (size | errno) = {$/;"	f
getdents	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getdents(dirfd: int, buf: *opaque, nbytes: size) (size | errno) = {$/;"	f
getdents	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getdents(dirfd: int, buf: *opaque, nbytes: size) (size | errno) = {$/;"	f
getdents	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getdents(dirfd: int, buf: *opaque, nbytes: size) (int | errno) = {$/;"	f
getdents64	$HARELIB/rt/+linux/syscalls.ha	/^export fn getdents64(dirfd: int, dirp: *opaque, count: size) (size | errno) = {$/;"	f
getegid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getegid() gid_t =  syscall0(SYS_getegid): gid_t;$/;"	f
getegid	$HARELIB/unix/+darwin/creds.ha	/^export fn getegid() gid = rt::getegid(): gid;$/;"	f
getegid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getegid() gid = {$/;"	f
getegid	$HARELIB/unix/+linux/creds.ha	/^export fn getegid() gid = {$/;"	f
getegid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getegid() uid = rt::getegid();$/;"	f
getenv	$HARELIB/os/environ.ha	/^export fn getenv(name: const str) (str | void) = {$/;"	f
getenvs	$HARELIB/os/+darwin/platform_environ.ha	/^export fn getenvs() []str = {$/;"	f
getenvs	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn getenvs() []str = {$/;"	f
getenvs	$HARELIB/os/+linux/platform_environ.ha	/^export fn getenvs() []str = {$/;"	f
getenvs	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn getenvs() []str = {$/;"	f
geteuid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn geteuid() uid_t =  syscall0(SYS_geteuid): uid_t;$/;"	f
geteuid	$HARELIB/unix/+darwin/creds.ha	/^export fn geteuid() uid = rt::geteuid(): uid;$/;"	f
geteuid	$HARELIB/unix/+freebsd/creds.ha	/^export fn geteuid() uid = {$/;"	f
geteuid	$HARELIB/unix/+linux/creds.ha	/^export fn geteuid() uid = {$/;"	f
geteuid	$HARELIB/unix/+openbsd/creds.ha	/^export fn geteuid() uid = rt::geteuid();$/;"	f
getflags	$HARELIB/net/msg.ha	/^export fn getflags(msg: *msghdr) int = {$/;"	f
getgid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getgid() gid_t =  syscall0(SYS_getgid): gid_t;$/;"	f
getgid	$HARELIB/unix/+darwin/creds.ha	/^export fn getgid() gid = rt::getgid(): gid;$/;"	f
getgid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getgid() gid = {$/;"	f
getgid	$HARELIB/unix/+linux/creds.ha	/^export fn getgid() gid = {$/;"	f
getgid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getgid() uid = rt::getgid();$/;"	f
getgid	$HARELIB/unix/passwd/group.ha	/^export fn getgid(gid: unix::gid) (grent | void) = {$/;"	f
getgroup	$HARELIB/unix/passwd/group.ha	/^export fn getgroup(name: str) (grent | void) = {$/;"	f
getgroups	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getgroups(gids: []gid_t) (uint | errno) = {$/;"	f
getgroups	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getgroups(gids: []uint) (uint | errno) = {$/;"	f
getgroups	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getgroups(gids: []gid_t) (uint | errno) = {$/;"	f
getgroups	$HARELIB/rt/+linux/syscalls.ha	/^export fn getgroups(gids: []gid_t) (uint | errno) = {$/;"	f
getgroups	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getgroups(gids: []gid_t) (uint | errno) = {$/;"	f
getgroups	$HARELIB/unix/+darwin/creds.ha	/^export fn getgroups() []gid = {$/;"	f
getgroups	$HARELIB/unix/+freebsd/creds.ha	/^export fn getgroups() []gid = {$/;"	f
getgroups	$HARELIB/unix/+linux/creds.ha	/^export fn getgroups() []gid = {$/;"	f
getgroups	$HARELIB/unix/+openbsd/creds.ha	/^export fn getgroups() []gid = {$/;"	f
getmeta	$HARELIB/rt/malloc.ha	/^export fn getmeta(p: *opaque) *meta = {$/;"	f
getpeername	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getpeername(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (void | err/;"	f
getpeername	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getpeername(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (void | err/;"	f
getpeername	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getpeername(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errn/;"	f
getpeername	$HARELIB/rt/+linux/syscalls.ha	/^export fn getpeername(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errn/;"	f
getpeername	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getpeername($/;"	f
getpgid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getpgid(pid: pid_t) (pid_t | errno) = {$/;"	f
getpgid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getpgid(pid: pid_t) (pid_t | errno) = {$/;"	f
getpgid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getpgid(pid: pid_t) (pid_t | errno) = {$/;"	f
getpgid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getpgid(pid: pid_t) (pid_t | errno) = {$/;"	f
getpgid	$HARELIB/unix/+linux/creds.ha	/^export fn getpgid(pid: pid) (pid | errors::noentry) = {$/;"	f
getpgid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpgid(pid: pid) (pid | errors::noentry) = {$/;"	f
getpgrp	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getpgrp() pid_t = syscall0(SYS_getpgrp): pid_t;$/;"	f
getpgrp	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getpgrp() pid_t = syscall0(SYS_getpgrp): pid_t;$/;"	f
getpgrp	$HARELIB/rt/+linux/syscalls.ha	/^export fn getpgrp() pid_t = syscall0(SYS_getpgrp): pid_t;$/;"	f
getpgrp	$HARELIB/unix/+darwin/creds.ha	/^export fn getpgrp() pid = rt::getpgrp();$/;"	f
getpgrp	$HARELIB/unix/+freebsd/creds.ha	/^export fn getpgrp() pid = rt::getpgrp();$/;"	f
getpgrp	$HARELIB/unix/+linux/creds.ha	/^export fn getpgrp() pid = rt::getpgrp();$/;"	f
getpgrp	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpgrp() pid = rt::getpgrp();$/;"	f
getpid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getpid() pid_t = syscall0(SYS_getpid): pid_t;$/;"	f
getpid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getpid() pid_t = syscall0(SYS_getpid): pid_t;$/;"	f
getpid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getpid() pid_t = syscall0(SYS_getpid): pid_t;$/;"	f
getpid	$HARELIB/unix/+darwin/creds.ha	/^export fn getpid() pid = rt::getpid();$/;"	f
getpid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getpid() pid = rt::getpid();$/;"	f
getpid	$HARELIB/unix/+linux/creds.ha	/^export fn getpid() pid = rt::getpid();$/;"	f
getpid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpid() pid = rt::getpid();$/;"	f
getppid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getppid() pid_t = syscall0(SYS_getppid): pid_t;$/;"	f
getppid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getppid() pid_t = syscall0(SYS_getppid): pid_t;$/;"	f
getppid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getppid() pid_t = syscall0(SYS_getppid): pid_t;$/;"	f
getppid	$HARELIB/unix/+darwin/creds.ha	/^export fn getppid() pid = rt::getppid();$/;"	f
getppid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getppid() pid = rt::getppid();$/;"	f
getppid	$HARELIB/unix/+linux/creds.ha	/^export fn getppid() pid = rt::getppid();$/;"	f
getppid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getppid() pid = rt::getppid();$/;"	f
getpriority	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getpriority(which: int, who: id_t) (int | errno) = {$/;"	f
getpriority	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getpriority(which: int, who: id_t) (int | errno) = {$/;"	f
getpriority	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getpriority(which: int, who: id_t) (int | errno) = {$/;"	f
getpriority	$HARELIB/rt/+linux/syscalls.ha	/^export fn getpriority(which: int, who: id_t) (int | errno) = {$/;"	f
getpriority	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getpriority(which: int, who: id_t) (int | errno) = {$/;"	f
getprocmask	$HARELIB/unix/signal/+darwin.ha	/^export fn getprocmask() sigset = {$/;"	f
getprocmask	$HARELIB/unix/signal/+freebsd.ha	/^export fn getprocmask() sigset = {$/;"	f
getprocmask	$HARELIB/unix/signal/+linux.ha	/^export fn getprocmask() sigset = {$/;"	f
getprocmask	$HARELIB/unix/signal/+openbsd.ha	/^export fn getprocmask() sigset = {$/;"	f
getpsid	$HARELIB/unix/+darwin/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
getpsid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
getpsid	$HARELIB/unix/+linux/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
getpsid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
getrandom	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getrandom(buf: *opaque, buflen: size, flags: uint) (size | errno) = {$/;"	f
getrandom	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getrandom(buf: *opaque, buflen: size, flags: uint) (size | errno) = {$/;"	f
getrandom	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getrandom(buf: *opaque, bufln: size, flags: uint) (size | errno) = {$/;"	f
getrandom	$HARELIB/rt/+linux/syscalls.ha	/^export fn getrandom(buf: *opaque, bufln: size, flags: uint) (size | errno) = {$/;"	f
getresgid	$HARELIB/rt/+darwin/syscalls.ha	/^\/\/ export fn getresgid(gid: *gid_t, egid: *gid_t, sgid: *gid_t) (void | errno) = {$/;"	f
getresgid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^\/\/ export fn getresgid(gid: *gid_t, egid: *gid_t, sgid: *gid_t) (void | errno) = {$/;"	f
getresgid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getresgid(gid: *gid_t, egid: *gid_t, sgid: *gid_t) (void | errno) = {$/;"	f
getresgid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getresgid(gid: *gid_t, egid: *gid_t, sgid: *gid_t) (void | errno) = {$/;"	f
getresuid	$HARELIB/rt/+darwin/syscalls.ha	/^\/\/ export fn getresuid(uid: *uid_t, euid: *uid_t, suid: *uid_t) (void | errno) = {$/;"	f
getresuid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^\/\/ export fn getresuid(uid: *uid_t, euid: *uid_t, suid: *uid_t) (void | errno) = {$/;"	f
getresuid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getresuid(uid: *uid_t, euid: *uid_t, suid: *uid_t) (void | errno) = {$/;"	f
getresuid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getresuid(uid: *uid_t, euid: *uid_t, suid: *uid_t) (void | errno) = {$/;"	f
getrlimit	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getrlimit(resource: int, rlim: *rlimit) (void | errno) = {$/;"	f
getrlimit	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getrlimit(resource: int, rlim: *rlimit) (void | errno) = {$/;"	f
getrlimit	$HARELIB/rt/+linux/syscalls.ha	/^export fn getrlimit(resource: int, rlim: *rlimit) (void | errno) = {$/;"	f
getround	$HARELIB/math/fenv_func.ha	/^export fn getround() fround = rt::fegetround(): fround;$/;"	f
getsid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getsid(pid: pid_t) (pid_t | errno) = {$/;"	f
getsid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getsid(pid: pid_t) (pid_t | errno) = {$/;"	f
getsid	$HARELIB/rt/+linux/syscalls.ha	/^export fn getsid(pid: pid_t) (pid_t | errno) = {$/;"	f
getsid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getsid(pid: pid_t) (pid_t | errno) = {$/;"	f
getsid	$HARELIB/unix/+darwin/creds.ha	/^export fn getsid() pid = rt::getsid(0)!;$/;"	f
getsid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getsid() pid = rt::getsid(0)!;$/;"	f
getsid	$HARELIB/unix/+linux/creds.ha	/^export fn getsid() pid = rt::getsid(0)!;$/;"	f
getsid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getsid() pid = rt::getsid(0)!;$/;"	f
getsockname	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getsockname(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (void | err/;"	f
getsockname	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getsockname(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (void | err/;"	f
getsockname	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getsockname(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errn/;"	f
getsockname	$HARELIB/rt/+linux/syscalls.ha	/^export fn getsockname(sockfd: int, addr: nullable *sockaddr, addrlen: nullable *u32) (int | errn/;"	f
getsockname	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getsockname($/;"	f
getsockopt	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getsockopt(sockfd: int, level: int, optname: int, optval: nullable *opaque, optlen: nu/;"	f
getsockopt	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn getsockopt(sockfd: int, level: int, optname: int, optval: nullable *opaque, optlen: nu/;"	f
getsockopt	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn getsockopt(sockfd: int, level: int, optname: int, optval: nullable *opaque, optlen: nu/;"	f
getsockopt	$HARELIB/rt/+linux/syscalls.ha	/^export fn getsockopt(sockfd: int, level: int, optname: int, optval: nullable *opaque, optlen: nu/;"	f
getsockopt	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn getsockopt($/;"	f
getsym	$HARELIB/linux/vdso/+linux/vdso.ha	/^export fn getsym(symname: str, symver: str) nullable *opaque = {$/;"	f
getuid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn getuid() uid_t =  syscall0(SYS_getuid): uid_t;$/;"	f
getuid	$HARELIB/unix/+darwin/creds.ha	/^export fn getuid() uid = rt::getuid(): uid;$/;"	f
getuid	$HARELIB/unix/+freebsd/creds.ha	/^export fn getuid() uid = {$/;"	f
getuid	$HARELIB/unix/+linux/creds.ha	/^export fn getuid() uid = {$/;"	f
getuid	$HARELIB/unix/+openbsd/creds.ha	/^export fn getuid() uid = rt::getuid();$/;"	f
getuid	$HARELIB/unix/passwd/passwd.ha	/^export fn getuid(uid: unix::uid) (pwent | void) = {$/;"	f
getuser	$HARELIB/unix/passwd/passwd.ha	/^export fn getuser(username: str) (pwent | void) = {$/;"	f
geu32	$HARELIB/crypto/math/bits.ha	/^export fn geu32(x: u32, y: u32) u32 = notu32(gtu32(y, x));$/;"	f
gid	$HARELIB/unix/+darwin/creds.ha	/^export type gid = rt::gid_t;$/;"	t
gid	$HARELIB/unix/+freebsd/creds.ha	/^export type gid = rt::gid_t;$/;"	t
gid	$HARELIB/unix/+linux/creds.ha	/^export type gid = rt::gid_t;$/;"	t
gid	$HARELIB/unix/+openbsd/creds.ha	/^export type gid = rt::gid_t;$/;"	t
gid	$HARELIB/unix/passwd/group.ha	/^export fn getgid(gid: unix::gid) (grent | void) = {$/;"	f
gid_t	$HARELIB/rt/+darwin/types.ha	/^export type gid_t       = uint;$/;"	t
gid_t	$HARELIB/rt/+freebsd/types.ha	/^export type gid_t = uint;$/;"	t
gid_t	$HARELIB/rt/+linux/types.ha	/^export type gid_t = uint;$/;"	t
gid_t	$HARELIB/rt/+openbsd/types.ha	/^export type gid_t = u32;$/;"	t
glob	$HARELIB/glob/glob.ha	/^export fn glob(pattern: str, flags: flag...) generator = {$/;"	f
gpregs	$HARELIB/rt/+darwin/+aarch64.ha	/^export type gpregs = struct {$/;"	t
gpregs	$HARELIB/rt/+darwin/+riscv64.ha	/^export type gpregs = struct {$/;"	t
gpregs	$HARELIB/rt/+freebsd/+aarch64.ha	/^export type gpregs = struct {$/;"	t
gpregs	$HARELIB/rt/+freebsd/+riscv64.ha	/^export type gpregs = struct {$/;"	t
grantpt	$HARELIB/rt/+darwin/syscalls.ha	/^export fn grantpt(fd: int) (void | errno) = {$/;"	f
grantpt	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn grantpt(fd: int) (void | errno) = {$/;"	f
grent	$HARELIB/unix/passwd/group.ha	/^export type grent = struct {$/;"	t
grent_finish	$HARELIB/unix/passwd/group.ha	/^export fn grent_finish(ent: *grent) void = {$/;"	f
gtu32	$HARELIB/crypto/math/bits.ha	/^export fn gtu32(x: u32, y: u32) u32 = {$/;"	f
handle	$HARELIB/bufio/scanner.ha	/^export fn newscanner_static(src: io::handle, buffer: []u8) scanner = {$/;"	f
handle	$HARELIB/bufio/stream.ha	/^export fn unreadrune(s: io::handle, rn: rune) void = {$/;"	f
handle	$HARELIB/crypto/cipher/ctr.ha	/^export fn ctr(h: io::handle, b: *block, iv: []u8, buf: []u8) ctr_stream = {$/;"	f
handle	$HARELIB/encoding/asn1/decoder.ha	/^export fn derdecoder(src: io::handle) decoder = {$/;"	f
handle	$HARELIB/encoding/hex/hex.ha	/^export fn newencoder(out: io::handle) encoder = {$/;"	f
handle	$HARELIB/encoding/pem/pem.ha	/^export fn newdecoder(in: io::handle) decoder = {$/;"	f
handle	$HARELIB/format/ini/scan.ha	/^export fn scan(in: io::handle) scanner = scanner {$/;"	f
handle	$HARELIB/format/tar/reader.ha	/^export fn read(src: io::handle) reader = {$/;"	f
handle	$HARELIB/fs/fs.ha	/^export fn open(fs: *fs, path: str, flags: flag...) (io::handle | error) = {$/;"	f
handle	$HARELIB/io/handle.ha	/^export type handle = (file | *stream);$/;"	t
handle	$HARELIB/log/logger.ha	/^export fn new(sink: io::handle) stdlogger = {$/;"	f
handle	$HARELIB/unix/hosts/hosts.ha	/^export fn iter(in: io::handle) iterator = iterator {$/;"	f
handle	$HARELIB/unix/signal/+darwin.ha	/^export fn handle($/;"	f
handle	$HARELIB/unix/signal/+freebsd.ha	/^export fn handle($/;"	f
handle	$HARELIB/unix/signal/+linux.ha	/^export fn handle($/;"	f
handle	$HARELIB/unix/signal/+openbsd.ha	/^export fn handle($/;"	f
handler	$HARELIB/unix/signal/types.ha	/^export type handler = fn(sig: sig, info: *siginfo, ucontext: *opaque) void;$/;"	t
hash	$HARELIB/crypto/hmac/hmac.ha	/^export fn hmac(h: *hash::hash, key: const []u8, buf: []u8) state = {$/;"	f
hash	$HARELIB/hare/types/hash.ha	/^export fn hash(t: *_type) u32 = {$/;"	f
hash	$HARELIB/hash/adler32/adler32.ha	/^export fn sum32(h: *hash::hash) u32 = {$/;"	f
hash	$HARELIB/hash/crc16/crc16.ha	/^export fn sum16(h: *hash::hash) u16 = {$/;"	f
hash	$HARELIB/hash/crc32/crc32.ha	/^export fn sum32(h: *hash::hash) u32 = {$/;"	f
hash	$HARELIB/hash/crc64/crc64.ha	/^export fn sum64(h: *hash::hash) u64 = {$/;"	f
hash	$HARELIB/hash/fnv/fnv.ha	/^export fn sum64(h: *hash::hash) u64 = {$/;"	f
hash	$HARELIB/hash/hash.ha	/^export type hash = struct {$/;"	t
hashhdr	$HARELIB/format/elf/types.ha	/^export type hashhdr = struct {$/;"	t
hasprefix	$HARELIB/bytes/contains.ha	/^export fn hasprefix(in: []u8, prefix: []u8) bool = {$/;"	f
hasprefix	$HARELIB/strings/suffix.ha	/^export fn hasprefix(in: str, prefix: (str | rune)) bool = {$/;"	f
hassuffix	$HARELIB/bytes/contains.ha	/^export fn hassuffix(in: []u8, suffix: []u8) bool = {$/;"	f
hassuffix	$HARELIB/strings/suffix.ha	/^export fn hassuffix(in: str, suff: (str | rune)) bool = {$/;"	f
hchacha20	$HARELIB/crypto/chacha/chacha20.ha	/^export fn hchacha20(out: []u8, key: []u8, nonce: []u8) void = {$/;"	f
head	$HARELIB/encoding/asn1/decoder.ha	/^export type head = struct {$/;"	t
header	$HARELIB/net/dns/types.ha	/^export type header = struct {$/;"	t
header64	$HARELIB/format/elf/types.ha	/^export type header64 = struct {$/;"	t
help	$HARELIB/getopt/getopts.ha	/^export type help = (cmd_help | flag_help | parameter_help | subcmd_help);$/;"	t
hkdf	$HARELIB/crypto/hkdf/hkdf.ha	/^export fn hkdf($/;"	f
hmac	$HARELIB/crypto/hmac/hmac.ha	/^export fn hmac(h: *hash::hash, key: const []u8, buf: []u8) state = {$/;"	f
host	$HARELIB/unix/hosts/hosts.ha	/^export type host = struct {$/;"	t
hostname	$HARELIB/os/+darwin/platform_environ.ha	/^export fn hostname() const str = {$/;"	f
hostname	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn hostname() const str = {$/;"	f
hostname	$HARELIB/os/+linux/platform_environ.ha	/^export fn hostname() const str = {$/;"	f
hostname	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn hostname() const str = {$/;"	f
hour	$HARELIB/time/date/observe.ha	/^export fn hour(d: *date) int = _hour(d);$/;"	f
how	$HARELIB/unix/signal/+darwin.ha	/^export type how = enum int {$/;"	t
how	$HARELIB/unix/signal/+freebsd.ha	/^export type how = enum int {$/;"	t
how	$HARELIB/unix/signal/+linux.ha	/^export type how = enum int {$/;"	t
how	$HARELIB/unix/signal/+openbsd.ha	/^export type how = enum int {$/;"	t
hsalsa20	$HARELIB/crypto/salsa/salsa20.ha	/^export fn hsalsa20(out: []u8, key: []u8, nonce: []u8) void = {$/;"	f
htonu16	$HARELIB/endian/network.ha	/^export fn htonu16(in: u16) u16 = {$/;"	f
htonu32	$HARELIB/endian/network.ha	/^export fn htonu32(in: u32) u32 = {$/;"	f
htonu64	$HARELIB/endian/network.ha	/^export fn htonu64(in: u64) u64 = {$/;"	f
hwsupport	$HARELIB/crypto/aes/block.ha	/^export fn hwsupport() bool = hwsup;$/;"	f
hypotf64	$HARELIB/math/trig.ha	/^export fn hypotf64(a: f64, b: f64) f64 = {$/;"	f
i16s	$HARELIB/sort/cmp/cmp.ha	/^export fn i16s(a: const *opaque, b: const *opaque) int = {$/;"	f
i16tos	$HARELIB/strconv/itos.ha	/^export fn i16tos(i: i16) const str = i64tos(i);$/;"	f
i16tosb	$HARELIB/strconv/itos.ha	/^export fn i16tosb(i: i16, b: base) const str = i64tosb(i, b);$/;"	f
i32s	$HARELIB/sort/cmp/cmp.ha	/^export fn i32s(a: const *opaque, b: const *opaque) int = {$/;"	f
i32tos	$HARELIB/strconv/itos.ha	/^export fn i32tos(i: i32) const str = i64tos(i);$/;"	f
i32tosb	$HARELIB/strconv/itos.ha	/^export fn i32tosb(i: i32, b: base) const str = i64tosb(i, b);$/;"	f
i64s	$HARELIB/sort/cmp/cmp.ha	/^export fn i64s(a: const *opaque, b: const *opaque) int = {$/;"	f
i64tos	$HARELIB/strconv/itos.ha	/^export fn i64tos(i: i64) const str = i64tosb(i, base::DEC);$/;"	f
i64tosb	$HARELIB/strconv/itos.ha	/^export fn i64tosb(i: i64, b: base) const str = {$/;"	f
i8s	$HARELIB/sort/cmp/cmp.ha	/^export fn i8s(a: const *opaque, b: const *opaque) int = {$/;"	f
i8tos	$HARELIB/strconv/itos.ha	/^export fn i8tos(i: i8) const str = i64tos(i);$/;"	f
i8tosb	$HARELIB/strconv/itos.ha	/^export fn i8tosb(i: i8, b: base) const str = i64tosb(i, b);$/;"	f
id_t	$HARELIB/rt/+darwin/types.ha	/^export type id_t        = uint;$/;"	t
id_t	$HARELIB/rt/+freebsd/types.ha	/^export type id_t = uint;$/;"	t
id_t	$HARELIB/rt/+linux/types.ha	/^export type id_t = uint;$/;"	t
id_t	$HARELIB/rt/+openbsd/types.ha	/^export type id_t = u32;$/;"	t
ident	$HARELIB/hare/ast/ident.ha	/^export type ident = []str;$/;"	t
ident	$HARELIB/hare/module/deps.ha	/^export fn parse_deps(files: str...) ([]ast::ident | error) = {$/;"	f
ident	$HARELIB/hare/parse/ident.ha	/^export fn identstr(in: str) (ast::ident | error) = {$/;"	f
ident	$HARELIB/hare/unparse/ident.ha	/^export fn identstr(id: ast::ident) str = {$/;"	f
ident_abi	$HARELIB/format/elf/types.ha	/^export type ident_abi = enum u8 {$/;"	t
ident_class	$HARELIB/format/elf/types.ha	/^export type ident_class = enum u8 {$/;"	t
ident_data	$HARELIB/format/elf/types.ha	/^export type ident_data = enum u8 {$/;"	t
ident_dup	$HARELIB/hare/ast/ident.ha	/^export fn ident_dup(id: ident) ident = strings::dupall(id);$/;"	f
ident_eq	$HARELIB/hare/ast/ident.ha	/^export fn ident_eq(a: ident, b: ident) bool = {$/;"	f
ident_free	$HARELIB/hare/ast/ident.ha	/^export fn ident_free(ident: ident) void = strings::freeall(ident);$/;"	f
ident_trailing	$HARELIB/hare/parse/ident.ha	/^export fn ident_trailing(lexer: *lex::lexer) ((ast::ident, bool) | error) = {$/;"	f
identstr	$HARELIB/hare/parse/ident.ha	/^export fn identstr(in: str) (ast::ident | error) = {$/;"	f
identstr	$HARELIB/hare/unparse/ident.ha	/^export fn identstr(id: ast::ident) str = {$/;"	f
if_expr	$HARELIB/hare/ast/expr.ha	/^export type if_expr = struct {$/;"	t
ignore	$HARELIB/unix/signal/+darwin.ha	/^export fn ignore(signum: sig) void = {$/;"	f
ignore	$HARELIB/unix/signal/+freebsd.ha	/^export fn ignore(signum: sig) void = {$/;"	f
ignore	$HARELIB/unix/signal/+linux.ha	/^export fn ignore(signum: sig) void = {$/;"	f
ignore	$HARELIB/unix/signal/+openbsd.ha	/^export fn ignore(signum: sig) void = {$/;"	f
image	$HARELIB/debug/image/open.ha	/^export type image = struct {$/;"	t
import	$HARELIB/hare/ast/import.ha	/^export type import = struct {$/;"	t
import	$HARELIB/hare/parse/import.ha	/^export fn imports(lexer: *lex::lexer) ([]ast::import | error) = {$/;"	f
import	$HARELIB/hare/unparse/import.ha	/^export fn import($/;"	f
import_alias	$HARELIB/hare/ast/import.ha	/^export type import_alias = str;$/;"	t
import_finish	$HARELIB/hare/ast/import.ha	/^export fn import_finish(import: import) void = {$/;"	f
import_members	$HARELIB/hare/ast/import.ha	/^export type import_members = []str;$/;"	t
import_wildcard	$HARELIB/hare/ast/import.ha	/^export type import_wildcard = void;$/;"	t
imports	$HARELIB/hare/parse/import.ha	/^export fn imports(lexer: *lex::lexer) ([]ast::import | error) = {$/;"	f
imports_finish	$HARELIB/hare/ast/import.ha	/^export fn imports_finish(imports: []import) void = {$/;"	f
in6_addr	$HARELIB/rt/+darwin/socket.ha	/^export type in6_addr = struct {$/;"	t
in6_addr	$HARELIB/rt/+freebsd/socket.ha	/^export type in6_addr = struct {$/;"	t
in6_addr	$HARELIB/rt/+linux/socket.ha	/^export type in6_addr = struct {$/;"	t
in6_addr	$HARELIB/rt/+openbsd/socket.ha	/^export type in6_addr = struct {$/;"	t
in_addr	$HARELIB/rt/+darwin/socket.ha	/^export type in_addr = struct {$/;"	t
in_addr	$HARELIB/rt/+freebsd/socket.ha	/^export type in_addr = struct {$/;"	t
in_addr	$HARELIB/rt/+linux/socket.ha	/^export type in_addr = struct {$/;"	t
in_addr	$HARELIB/rt/+openbsd/socket.ha	/^export type in_addr = struct {$/;"	t
index	$HARELIB/bytes/index.ha	/^export fn index(haystack: []u8, needle: (u8 | []u8)) (size | void) = {$/;"	f
index	$HARELIB/strings/index.ha	/^export fn index(haystack: str, needle: (str | rune)) (size | void) = {$/;"	f
init	$HARELIB/bufio/stream.ha	/^export fn init($/;"	f
init	$HARELIB/crypto/aes/block.ha	/^export fn init(b: *block, key: []u8) void = initfuncptr(b, key);$/;"	f
init	$HARELIB/crypto/aes/xts/xts.ha	/^export fn init(b: *block, key: []u8) void = {$/;"	f
init	$HARELIB/crypto/blowfish/blowfish.ha	/^export fn init(c: *state, key: []u8) void = {$/;"	f
init	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn init($/;"	f
init	$HARELIB/crypto/poly1305/poly1305.ha	/^export fn init(p: *state, key: *key) void = {$/;"	f
init	$HARELIB/hare/lex/lex.ha	/^export fn init(in: *bufio::scanner, path: str, flags: flag...) lexer = {$/;"	f
init	$HARELIB/math/random/random.ha	/^export fn init(seed: u64) random = seed;$/;"	f
init	$HARELIB/path/buffer.ha	/^export fn init(items: str...) (buffer | error) = {$/;"	f
init	$HARELIB/rt/+darwin/initfini.ha	/^export fn init() void = {$/;"	f
init	$HARELIB/rt/+freebsd/initfini.ha	/^export fn init() void = {$/;"	f
init	$HARELIB/rt/+linux/initfini.ha	/^export fn init() void = {$/;"	f
init_salt	$HARELIB/crypto/blowfish/blowfish.ha	/^export fn init_salt(c: *state, key: []u8, salt: []u8) void = {$/;"	f
ino_t	$HARELIB/rt/+darwin/types.ha	/^export type ino_t       = u32;$/;"	t
ino_t	$HARELIB/rt/+freebsd/types.ha	/^export type ino_t = u64;$/;"	t
ino_t	$HARELIB/rt/+linux/types.ha	/^export type ino_t = u64;$/;"	t
ino_t	$HARELIB/rt/+openbsd/types.ha	/^export type ino_t = u64;$/;"	t
inotify_add_watch	$HARELIB/rt/+linux/syscalls.ha	/^export fn inotify_add_watch(fd: int, path: path, mask: u32) (int | errno) = {$/;"	f
inotify_event	$HARELIB/rt/+linux/syscalls.ha	/^export type inotify_event = struct {$/;"	t
inotify_init	$HARELIB/rt/+linux/syscalls.ha	/^export fn inotify_init() (int | errno) = {$/;"	f
inotify_init1	$HARELIB/rt/+linux/syscalls.ha	/^export fn inotify_init1(flags: int) (int | errno) = {$/;"	f
inotify_rm_watch	$HARELIB/rt/+linux/syscalls.ha	/^export fn inotify_rm_watch(fd: int, wd: int) (int | errno) = {$/;"	f
insert_expr	$HARELIB/hare/ast/expr.ha	/^export type insert_expr = append_expr;$/;"	t
inst	$HARELIB/regex/regex.ha	/^export type inst = (inst_lit | inst_any | inst_split | inst_jump |$/;"	t
inst_lit	$HARELIB/regex/regex.ha	/^export type inst_lit = rune,$/;"	t
instant	$HARELIB/hare/module/util.ha	/^export fn outdated(target: str, deps: []str, mtime: time::instant) bool = {$/;"	f
instant	$HARELIB/time/chrono/chronology.ha	/^export fn new(loc: locality, i: time::instant) moment = {$/;"	f
instant	$HARELIB/time/chrono/timescale.ha	/^export fn convert(i: time::instant, tscs: *timescale...) (time::instant | analytical) = {$/;"	f
instant	$HARELIB/time/date/date.ha	/^export fn from_instant(loc: chrono::locality, i: time::instant) date = {$/;"	f
instant	$HARELIB/time/types.ha	/^export type instant = struct {$/;"	t
instant_to_timespec	$HARELIB/time/+darwin/functions.ha	/^export fn instant_to_timespec(t: instant) rt::timespec = rt::timespec {$/;"	f
instant_to_timespec	$HARELIB/time/+freebsd/functions.ha	/^export fn instant_to_timespec(t: instant) rt::timespec = rt::timespec {$/;"	f
instant_to_timespec	$HARELIB/time/+linux/functions.ha	/^export fn instant_to_timespec(t: instant) rt::timespec = rt::timespec {$/;"	f
instant_to_timespec	$HARELIB/time/+openbsd/functions.ha	/^export fn instant_to_timespec(t: instant) rt::timespec = rt::timespec {$/;"	f
instruction	$HARELIB/strings/template/template.ha	/^export type instruction = (literal | variable);$/;"	t
insufficient	$HARELIB/encoding/asn1/t61.ha	/^export type insufficient = !void;$/;"	t
insufficient	$HARELIB/time/date/virtual.ha	/^export type insufficient = !lack; \/\/ TODO: drop alias workaround$/;"	t
int_fast16	$HARELIB/types/c/types.ha	/^export type int_fast16 = i16;$/;"	t
int_fast32	$HARELIB/types/c/types.ha	/^export type int_fast32 = i32;$/;"	t
int_fast64	$HARELIB/types/c/types.ha	/^export type int_fast64 = i64;$/;"	t
int_fast8	$HARELIB/types/c/types.ha	/^export type int_fast8 = i8;$/;"	t
int_least16	$HARELIB/types/c/types.ha	/^export type int_least16 = i16;$/;"	t
int_least32	$HARELIB/types/c/types.ha	/^export type int_least32 = i32;$/;"	t
int_least64	$HARELIB/types/c/types.ha	/^export type int_least64 = i64;$/;"	t
int_least8	$HARELIB/types/c/types.ha	/^export type int_least8 = i8;$/;"	t
integer	$HARELIB/strconv/numeric.ha	/^export fn integertosb(n: types::integer, b: base) const str = {$/;"	f
integer	$HARELIB/types/classes.ha	/^export type integer = (...signed | ...unsigned);$/;"	t
integertos	$HARELIB/strconv/numeric.ha	/^export fn integertos(n: types::integer) const str = integertosb(n, base::DEC);$/;"	f
integertosb	$HARELIB/strconv/numeric.ha	/^export fn integertosb(n: types::integer, b: base) const str = {$/;"	f
interrupted	$HARELIB/errors/common.ha	/^export type interrupted = !void;$/;"	t
interval	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type interval = time::duration;$/;"	t
interval	$HARELIB/time/types.ha	/^export type interval = (instant, instant);$/;"	t
interval_delayed	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type interval_delayed = (time::duration, time::duration);$/;"	t
intmax	$HARELIB/types/c/types.ha	/^export type intmax = i64;$/;"	t
intptr	$HARELIB/types/c/arch+aarch64.ha	/^export type intptr = i64;$/;"	t
intptr	$HARELIB/types/c/arch+riscv64.ha	/^export type intptr = i64;$/;"	t
intptr	$HARELIB/types/c/arch+x86_64.ha	/^export type intptr = i64;$/;"	t
ints	$HARELIB/sort/cmp/cmp.ha	/^export fn ints(a: const *opaque, b: const *opaque) int = {$/;"	f
invalid	$HARELIB/crypto/bcrypt/bcrypt.ha	/^export fn compare(hash: []u8, password: []u8) (bool | errors::invalid) = {$/;"	f
invalid	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn verify(s: *stream, tag: []u8) (void | errors::invalid) = {$/;"	f
invalid	$HARELIB/crypto/cipher/gcm.ha	/^export fn gcm_verify(s: *gcmstream, tag: []u8) (void | errors::invalid) = {$/;"	f
invalid	$HARELIB/crypto/ec/types.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/encoding/asn1/errors.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/encoding/base32/base32.ha	/^export fn decodestr(enc: *encoding, in: str) ([]u8 | errors::invalid) = {$/;"	f
invalid	$HARELIB/encoding/base64/base64.ha	/^export fn decodestr(enc: *encoding, in: str) ([]u8 | errors::invalid) = {$/;"	f
invalid	$HARELIB/encoding/utf8/types.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/errors/common.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/format/tar/types.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/memio/stream.ha	/^export fn string(in: *stream) (str | utf8::invalid) = {$/;"	f
invalid	$HARELIB/mime/parse.ha	/^export fn parse(in: str) ((str, type_params) | errors::invalid) = {$/;"	f
invalid	$HARELIB/net/ip/ip.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/net/unix/addr.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/net/uri/parse.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/os/environ.ha	/^export fn unsetenv(name: const str) (void | errors::invalid) = {$/;"	f
invalid	$HARELIB/os/exec/cmd.ha	/^export fn unsetenv(cmd: *command, key: str) (void | errors::invalid) = {$/;"	f
invalid	$HARELIB/strconv/types.ha	/^export type invalid = !size;$/;"	t
invalid	$HARELIB/strings/template/template.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/strings/utf8.ha	/^export fn fromutf8(in: []u8) (str | utf8::invalid) = {$/;"	f
invalid	$HARELIB/time/chrono/chronology.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/time/date/date.ha	/^export type invalid = !chrono::invalid;$/;"	t
invalid	$HARELIB/types/c/strings.ha	/^export fn tostrn(cstr: *const char, length: size) (const str | utf8::invalid) = {$/;"	f
invalid	$HARELIB/unix/hosts/hosts.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/unix/passwd/types.ha	/^export type invalid = !void;$/;"	t
invalid	$HARELIB/uuid/uuid.ha	/^export type invalid = !void;$/;"	t
invalid_address	$HARELIB/net/dial/registry.ha	/^export type invalid_address = !void;$/;"	t
invalidkey	$HARELIB/crypto/ecdh/ecdh.ha	/^export type invalidkey = !void;$/;"	t
invalidtzif	$HARELIB/time/chrono/tzdb.ha	/^export type invalidtzif = !void;$/;"	t
io_cqring_offsets	$HARELIB/rt/+linux/types.ha	/^export type io_cqring_offsets = struct {$/;"	t
io_sqring_offsets	$HARELIB/rt/+linux/types.ha	/^export type io_sqring_offsets = struct {$/;"	t
io_uring_buf	$HARELIB/rt/+linux/types.ha	/^export type io_uring_buf = struct {$/;"	t
io_uring_buf_reg	$HARELIB/rt/+linux/types.ha	/^export type io_uring_buf_reg = struct {$/;"	t
io_uring_buf_ring	$HARELIB/rt/+linux/types.ha	/^export type io_uring_buf_ring = struct {$/;"	t
io_uring_cqe	$HARELIB/rt/+linux/types.ha	/^export type io_uring_cqe = struct {$/;"	t
io_uring_enter	$HARELIB/rt/+linux/syscalls.ha	/^export fn io_uring_enter($/;"	f
io_uring_enter2	$HARELIB/rt/+linux/syscalls.ha	/^export fn io_uring_enter2($/;"	f
io_uring_file_index_range	$HARELIB/rt/+linux/types.ha	/^export type io_uring_file_index_range = struct {$/;"	t
io_uring_files_update	$HARELIB/rt/+linux/types.ha	/^export type io_uring_files_update = struct {$/;"	t
io_uring_getevents_arg	$HARELIB/rt/+linux/types.ha	/^export type io_uring_getevents_arg = struct {$/;"	t
io_uring_params	$HARELIB/rt/+linux/types.ha	/^export type io_uring_params = struct {$/;"	t
io_uring_probe	$HARELIB/rt/+linux/types.ha	/^export type io_uring_probe = struct {$/;"	t
io_uring_probe_op	$HARELIB/rt/+linux/types.ha	/^export type io_uring_probe_op = struct {$/;"	t
io_uring_recvmsg_out	$HARELIB/rt/+linux/types.ha	/^export type io_uring_recvmsg_out = struct {$/;"	t
io_uring_register	$HARELIB/rt/+linux/syscalls.ha	/^export fn io_uring_register($/;"	f
io_uring_restriction	$HARELIB/rt/+linux/types.ha	/^export type io_uring_restriction = struct {$/;"	t
io_uring_rsrc_register	$HARELIB/rt/+linux/types.ha	/^export type io_uring_rsrc_register = struct {$/;"	t
io_uring_rsrc_update	$HARELIB/rt/+linux/types.ha	/^export type io_uring_rsrc_update = struct {$/;"	t
io_uring_rsrc_update2	$HARELIB/rt/+linux/types.ha	/^export type io_uring_rsrc_update2 = struct {$/;"	t
io_uring_setup	$HARELIB/rt/+linux/syscalls.ha	/^export fn io_uring_setup(entries: u32, params: *io_uring_params) (int | errno) = {$/;"	f
io_uring_sqe	$HARELIB/rt/+linux/types.ha	/^export type io_uring_sqe = struct {$/;"	t
io_uring_sync_cancel_reg	$HARELIB/rt/+linux/types.ha	/^export type io_uring_sync_cancel_reg = struct {$/;"	t
ioctl	$HARELIB/rt/+darwin/syscalls.ha	/^export fn ioctl(fd: int, req: u64, arg: ioctl_arg) (int | errno) = {$/;"	f
ioctl	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn ioctl(fd: int, req: u64, arg: nullable *opaque) (int | errno) = {$/;"	f
ioctl	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn ioctl(fd: int, req: u64, arg: ioctl_arg) (int | errno) = {$/;"	f
ioctl	$HARELIB/rt/+linux/syscalls.ha	/^export fn ioctl(fd: int, req: u64, arg: ioctl_arg) (int | errno) = {$/;"	f
ioctl	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn ioctl(fd: int, req: u64, arg: ioctl_arg) (int | errno) = {$/;"	f
ioctl_arg	$HARELIB/rt/+darwin/syscalls.ha	/^export type ioctl_arg = (nullable *opaque | u64);$/;"	t
ioctl_arg	$HARELIB/rt/+freebsd/syscalls.ha	/^export type ioctl_arg = (nullable *opaque | u64);$/;"	t
ioctl_arg	$HARELIB/rt/+linux/syscalls.ha	/^export type ioctl_arg = (nullable *opaque | u64);$/;"	t
ioctl_arg	$HARELIB/rt/+openbsd/syscalls.ha	/^export type ioctl_arg = (nullable *opaque | u64);$/;"	t
iovec	$HARELIB/rt/+darwin/types.ha	/^export type iovec = struct {$/;"	t
iovec	$HARELIB/rt/+freebsd/types.ha	/^export type iovec = struct {$/;"	t
iovec	$HARELIB/rt/+linux/types.ha	/^export type iovec = struct {$/;"	t
iovec	$HARELIB/rt/+openbsd/types.ha	/^export type iovec = struct {$/;"	t
is_float	$HARELIB/hare/types/class.ha	/^export fn is_float(ty: const *_type) bool = {$/;"	f
is_integer	$HARELIB/hare/types/class.ha	/^export fn is_integer(ty: const *_type) bool = {$/;"	f
is_signed	$HARELIB/hare/types/class.ha	/^export fn is_signed(ty: const *_type) bool = {$/;"	f
isalnum	$HARELIB/ascii/ctype.ha	/^export fn isalnum(c: rune) bool =$/;"	f
isalpha	$HARELIB/ascii/ctype.ha	/^export fn isalpha(c: rune) bool =$/;"	f
isatty	$HARELIB/unix/tty/+darwin/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
isatty	$HARELIB/unix/tty/+freebsd/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
isatty	$HARELIB/unix/tty/+linux/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
isatty	$HARELIB/unix/tty/+openbsd/isatty.ha	/^export fn isatty(fd: io::file) bool = {$/;"	f
isblank	$HARELIB/ascii/ctype.ha	/^export fn isblank(c: rune) bool = (c == ' ' || c == '\\t');$/;"	f
isblockdev	$HARELIB/fs/util.ha	/^export fn isblockdev(mode: mode) bool = mode & IFMT == mode::BLK;$/;"	f
isbuffered	$HARELIB/bufio/stream.ha	/^export fn isbuffered(in: io::handle) bool = {$/;"	f
ischdev	$HARELIB/fs/util.ha	/^export fn ischdev(mode: mode) bool = mode & IFMT == mode::CHR;$/;"	f
isclose	$HARELIB/math/math.ha	/^export fn isclose(x: types::floating, y: types::floating) bool = {$/;"	f
isclosef32	$HARELIB/math/math.ha	/^export fn isclosef32(x: f32, y: f32) bool = {$/;"	f
isclosef64	$HARELIB/math/math.ha	/^export fn isclosef64(x: f64, y: f64) bool = {$/;"	f
iscntrl	$HARELIB/ascii/ctype.ha	/^export fn iscntrl(c: rune) bool =$/;"	f
isdigit	$HARELIB/ascii/ctype.ha	/^export fn isdigit(c: rune) bool =$/;"	f
isdir	$HARELIB/fs/util.ha	/^export fn isdir(mode: mode) bool = mode & IFMT == mode::DIR;$/;"	f
isfifo	$HARELIB/fs/util.ha	/^export fn isfifo(mode: mode) bool = mode & IFMT == mode::FIFO;$/;"	f
isfile	$HARELIB/fs/util.ha	/^export fn isfile(mode: mode) bool = mode & IFMT == mode::REG;$/;"	f
isgraph	$HARELIB/ascii/ctype.ha	/^export fn isgraph(c: rune) bool =$/;"	f
isinf	$HARELIB/math/complex/complex.ha	/^export fn isinf(z: c128) bool = math::isinf(z.0) || math::isinf(z.1);$/;"	f
isinf	$HARELIB/math/floats.ha	/^export fn isinf(n: f64) bool = {$/;"	f
isleapyear	$HARELIB/time/date/daydate.ha	/^export fn isleapyear(y: int) bool = {$/;"	f
islink	$HARELIB/fs/util.ha	/^export fn islink(mode: mode) bool = mode & IFMT == mode::LINK;$/;"	f
islower	$HARELIB/ascii/ctype.ha	/^export fn islower(c: rune) bool =$/;"	f
isnan	$HARELIB/math/complex/complex.ha	/^export fn isnan(z: c128) bool =$/;"	f
isnan	$HARELIB/math/floats.ha	/^export fn isnan(n: f64) bool = n != n;$/;"	f
isnegative	$HARELIB/math/floats.ha	/^export fn isnegative(x: types::floating) bool = {$/;"	f
isnegativef32	$HARELIB/math/floats.ha	/^export fn isnegativef32(x: f32) bool = signf32(x) == -1i32;$/;"	f
isnegativef64	$HARELIB/math/floats.ha	/^export fn isnegativef64(x: f64) bool = signf64(x) == -1i64;$/;"	f
isnormal	$HARELIB/math/floats.ha	/^export fn isnormal(n: types::floating) bool = {$/;"	f
isnormalf32	$HARELIB/math/floats.ha	/^export fn isnormalf32(n: f32) bool = {$/;"	f
isnormalf64	$HARELIB/math/floats.ha	/^export fn isnormalf64(n: f64) bool = {$/;"	f
isoweek	$HARELIB/time/date/observe.ha	/^export fn isoweek(d: *date) int = _isoweek(d);$/;"	f
isoweekyear	$HARELIB/time/date/observe.ha	/^export fn isoweekyear(d: *date) int = _isoweekyear(d);$/;"	f
ispositive	$HARELIB/math/floats.ha	/^export fn ispositive(x: types::floating) bool = {$/;"	f
ispositivef32	$HARELIB/math/floats.ha	/^export fn ispositivef32(x: f32) bool = signf32(x) == 1i32;$/;"	f
ispositivef64	$HARELIB/math/floats.ha	/^export fn ispositivef64(x: f64) bool = signf64(x) == 1i64;$/;"	f
isprint	$HARELIB/ascii/ctype.ha	/^export fn isprint(c: rune) bool =$/;"	f
ispunct	$HARELIB/ascii/ctype.ha	/^export fn ispunct(c: rune) bool =$/;"	f
isroot	$HARELIB/path/buffer.ha	/^export fn isroot(path: (*buffer | str)) bool = match (path) {$/;"	f
issocket	$HARELIB/fs/util.ha	/^export fn issocket(mode: mode) bool = mode & IFMT == mode::SOCK;$/;"	f
isspace	$HARELIB/ascii/ctype.ha	/^export fn isspace(c: rune) bool =$/;"	f
issubnormal	$HARELIB/math/floats.ha	/^export fn issubnormal(n: types::floating) bool = {$/;"	f
issubnormalf32	$HARELIB/math/floats.ha	/^export fn issubnormalf32(n: f32) bool = {$/;"	f
issubnormalf64	$HARELIB/math/floats.ha	/^export fn issubnormalf64(n: f64) bool = {$/;"	f
isupper	$HARELIB/ascii/ctype.ha	/^export fn isupper(c: rune) bool =$/;"	f
isxdigit	$HARELIB/ascii/ctype.ha	/^export fn isxdigit(c: rune) bool =$/;"	f
iszero	$HARELIB/crypto/bigint/util.ha	/^export fn iszero(x: []word) u32 = {$/;"	f
iter	$HARELIB/fs/fs.ha	/^export fn iter(fs: *fs, path: str) (*iterator | error) = {$/;"	f
iter	$HARELIB/os/os.ha	/^export fn iter(path: str) (*fs::iterator | fs::error) = fs::iter(cwd, path);$/;"	f
iter	$HARELIB/path/iter.ha	/^export fn iter(buf: *buffer) iterator = iterator {$/;"	f
iter	$HARELIB/strings/iter.ha	/^export fn iter(src: str) iterator = iterator {$/;"	f
iter	$HARELIB/unix/hosts/hosts.ha	/^export fn iter(in: io::handle) iterator = iterator {$/;"	f
iter_lookup	$HARELIB/unix/hosts/hosts.ha	/^export fn iter_lookup(it: *iterator, name: const str) ([]ip::addr | error) = {$/;"	f
iterator	$HARELIB/fs/types.ha	/^export type iterator = struct {$/;"	t
iterator	$HARELIB/path/iter.ha	/^export type iterator = struct {$/;"	t
iterator	$HARELIB/strings/iter.ha	/^export type iterator = struct {$/;"	t
iterator	$HARELIB/unix/hosts/hosts.ha	/^export type iterator = struct {$/;"	t
iterfunc	$HARELIB/fs/types.ha	/^export type iterfunc = fn(fs: *fs, path: str) (*iterator | error);$/;"	t
iterrem	$HARELIB/path/iter.ha	/^export fn iterrem(it: *iterator) str = strings::fromutf8_unsafe(it.cur);$/;"	f
iterstr	$HARELIB/strings/iter.ha	/^export fn iterstr(iter: *iterator) str = {$/;"	f
itimerspec	$HARELIB/rt/+linux/types.ha	/^export type itimerspec = struct {$/;"	t
itos	$HARELIB/strconv/itos.ha	/^export fn itos(i: int) const str = i64tos(i);$/;"	f
itosb	$HARELIB/strconv/itos.ha	/^export fn itosb(i: int, b: base) const str = i64tosb(i, b);$/;"	f
jmpbuf	$HARELIB/rt/jmp.ha	/^export type jmpbuf = struct {$/;"	t
join	$HARELIB/memio/ops.ha	/^export fn join(out: io::handle, delim: str, strs: str...) (size | io::error) = {$/;"	f
join	$HARELIB/strings/concat.ha	/^export fn join(delim: str, strs: str...) str = {$/;"	f
join_session_keyring	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn join_session_keyring(name: str) (serial | error) = {$/;"	f
kdf_params	$HARELIB/linux/keyctl/+linux/types.ha	/^export type kdf_params = struct {$/;"	t
keepalive	$HARELIB/net/tcp/options.ha	/^export type keepalive = void;$/;"	t
kevent	$HARELIB/rt/+openbsd/types.ha	/^export type kevent = struct {$/;"	t
kevent_poll	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn kevent_poll($/;"	f
key	$HARELIB/crypto/keystore/impl+linux.ha	/^export type key = keyctl::serial;$/;"	t
key	$HARELIB/crypto/keystore/impl.ha	/^export type key = []u8;$/;"	t
key	$HARELIB/crypto/poly1305/poly1305.ha	/^export type key = [32]u8;$/;"	t
key	$HARELIB/crypto/x25519/x25519.ha	/^export type key = [KEYSZ]u8;$/;"	t
keyctl	$HARELIB/rt/+linux/syscalls.ha	/^export fn keyctl($/;"	f
keygen	$HARELIB/crypto/ec/keygen.ha	/^export fn keygen(c: *curve, priv: []u8, rand: io::handle) (size | io::error) =$/;"	f
kill	$HARELIB/os/exec/+darwin/process.ha	/^export fn kill(proc: process) (void | errors::error) = {$/;"	f
kill	$HARELIB/os/exec/+freebsd/process.ha	/^export fn kill(proc: process) (void | errors::error) = {$/;"	f
kill	$HARELIB/os/exec/+linux/process.ha	/^export fn kill(proc: process) (void | errors::error) = {$/;"	f
kill	$HARELIB/os/exec/+openbsd/process.ha	/^export fn kill(proc: process) (void | errors::error) = {$/;"	f
kill	$HARELIB/rt/+darwin/syscalls.ha	/^export fn kill(pid: pid_t, signal: int) (void | errno) = {$/;"	f
kill	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn kill(pid: int, signal: int) (void | errno) = {$/;"	f
kill	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn kill(pid: pid_t, signal: int) (void | errno) = {$/;"	f
kill	$HARELIB/rt/+linux/syscalls.ha	/^export fn kill(pid: pid_t, signal: int) (void | errno) = {$/;"	f
kill	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn kill(pid: int, signal: int) (void | errno) = {$/;"	f
kqueue	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn kqueue() (int | errno) = {$/;"	f
kqueue1	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn kqueue1(flags: int) (int | errno) = {$/;"	f
label	$HARELIB/hare/ast/expr.ha	/^export type label = str;$/;"	t
lack	$HARELIB/time/date/virtual.ha	/^export type lack = enum u8 {$/;"	t
lbisect	$HARELIB/sort/bisect.ha	/^export fn lbisect($/;"	f
ldexpf32	$HARELIB/math/floats.ha	/^export fn ldexpf32(mantissa: f32, exp: i64) f32 = {$/;"	f
ldexpf64	$HARELIB/math/floats.ha	/^export fn ldexpf64(mantissa: f64, exp: i64) f64 = {$/;"	f
leading_zeros_u	$HARELIB/math/uints.ha	/^export fn leading_zeros_u(x: uint) u8 = UINT_SIZE - bit_size_u(x);$/;"	f
leading_zeros_u16	$HARELIB/math/uints.ha	/^export fn leading_zeros_u16(x: u16) u8 = 16 - bit_size_u16(x);$/;"	f
leading_zeros_u32	$HARELIB/math/uints.ha	/^export fn leading_zeros_u32(x: u32) u8 = 32 - bit_size_u32(x);$/;"	f
leading_zeros_u64	$HARELIB/math/uints.ha	/^export fn leading_zeros_u64(x: u64) u8 = 64 - bit_size_u64(x);$/;"	f
leading_zeros_u8	$HARELIB/math/uints.ha	/^export fn leading_zeros_u8(x: u8) u8 = 8 - bit_size_u8(x);$/;"	f
legetu16	$HARELIB/endian/little.ha	/^export fn legetu16(buf: []u8) u16 = {$/;"	f
legetu32	$HARELIB/endian/little.ha	/^export fn legetu32(buf: []u8) u32 = {$/;"	f
legetu64	$HARELIB/endian/little.ha	/^export fn legetu64(buf: []u8) u64 = {$/;"	f
len_contextual	$HARELIB/hare/ast/type.ha	/^export type len_contextual = void;$/;"	t
len_expr	$HARELIB/hare/ast/expr.ha	/^export type len_expr = *expr;$/;"	t
len_slice	$HARELIB/hare/ast/type.ha	/^export type len_slice = void;$/;"	t
len_unbounded	$HARELIB/hare/ast/type.ha	/^export type len_unbounded = void;$/;"	t
leputu16	$HARELIB/endian/little.ha	/^export fn leputu16(buf: []u8, in: u16) void = {$/;"	f
leputu32	$HARELIB/endian/little.ha	/^export fn leputu32(buf: []u8, in: u32) void = {$/;"	f
leputu64	$HARELIB/endian/little.ha	/^export fn leputu64(buf: []u8, in: u64) void = {$/;"	f
leu32	$HARELIB/crypto/math/bits.ha	/^export fn leu32(x: u32, y: u32) u32 = notu32(gtu32(x, y));$/;"	f
lex	$HARELIB/hare/lex/lex.ha	/^export fn lex(lex: *lexer) (token | error) = {$/;"	f
lexer	$HARELIB/hare/lex/lex.ha	/^export type lexer = struct {$/;"	t
lfatal	$HARELIB/log/funcs.ha	/^export fn lfatal(log: *logger, fields: fmt::formattable...) never = {$/;"	f
lfatalf	$HARELIB/log/funcs.ha	/^export fn lfatalf($/;"	f
limitreader	$HARELIB/io/limit.ha	/^export fn limitreader(source: handle, limit: size) limitstream = {$/;"	f
limitstream	$HARELIB/io/limit.ha	/^export type limitstream = struct {$/;"	t
limitwriter	$HARELIB/io/limit.ha	/^export fn limitwriter(source: handle, limit: size) limitstream = {$/;"	f
line_file	$HARELIB/debug/dwarf/line.ha	/^export type line_file = struct {$/;"	t
line_flag	$HARELIB/debug/dwarf/line.ha	/^export type line_flag = enum uint {$/;"	t
line_header	$HARELIB/debug/dwarf/line.ha	/^export type line_header = struct {$/;"	t
line_next	$HARELIB/debug/dwarf/line.ha	/^export fn line_next(prog: *line_program) (line_state | io::EOF | io::error) = {$/;"	f
line_program	$HARELIB/debug/dwarf/line.ha	/^export type line_program = struct {$/;"	t
line_program_finish	$HARELIB/debug/dwarf/line.ha	/^export fn line_program_finish(prog: *line_program) void = {$/;"	f
line_state	$HARELIB/debug/dwarf/line.ha	/^export type line_state = struct {$/;"	t
line_step	$HARELIB/debug/dwarf/line.ha	/^export fn line_step($/;"	f
link	$HARELIB/fs/fs.ha	/^export fn link(fs: *fs, old: str, new: str) (void | error) = {$/;"	f
link	$HARELIB/os/os.ha	/^export fn link(old: str, new: str) (void | fs::error) = fs::link(cwd, old, new);$/;"	f
linkat	$HARELIB/rt/+linux/syscalls.ha	/^export fn linkat($/;"	f
linkat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn linkat($/;"	f
linkfunc	$HARELIB/fs/types.ha	/^export type linkfunc = fn(fs: *fs, old: str, new: str) (void | error);$/;"	t
list	$HARELIB/hare/parse/doc/doc.ha	/^export type list = []paragraph;$/;"	t
list_type	$HARELIB/hare/ast/type.ha	/^export type list_type = struct {$/;"	t
listen	$HARELIB/net/tcp/+darwin.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/tcp/+freebsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/tcp/+linux.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/tcp/+openbsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/udp/+darwin.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/udp/+freebsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/udp/+linux.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/udp/+openbsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/unix/+darwin.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/unix/+freebsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/unix/+linux.ha	/^export fn listen($/;"	f
listen	$HARELIB/net/unix/+openbsd.ha	/^export fn listen($/;"	f
listen	$HARELIB/rt/+darwin/syscalls.ha	/^export fn listen(sockfd: int, backlog: u32) (void | errno) = {$/;"	f
listen	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn listen(sockfd: int, backlog: u32) (void | errno) = {$/;"	f
listen	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn listen(sockfd: int, backlog: u32) (int | errno) = {$/;"	f
listen	$HARELIB/rt/+linux/syscalls.ha	/^export fn listen(sockfd: int, backlog: u32) (int | errno) = {$/;"	f
listen	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn listen(sockfd: int, backlog: u32) (void | errno) = {$/;"	f
listen_option	$HARELIB/net/tcp/options.ha	/^export type listen_option = ($/;"	t
listen_option	$HARELIB/net/udp/options.ha	/^export type listen_option = ($/;"	t
listen_option	$HARELIB/net/unix/options.ha	/^export type listen_option = (backlog | net::sockflag);$/;"	t
literal	$HARELIB/strings/template/template.ha	/^export type literal = str;$/;"	t
literal_expr	$HARELIB/hare/ast/expr.ha	/^export type literal_expr = (value | array_literal | number_literal |$/;"	t
load	$HARELIB/unix/resolvconf/load.ha	/^export fn load() []ip::addr = {$/;"	f
load_abbrevs	$HARELIB/debug/dwarf/abbrev.ha	/^export fn load_abbrevs($/;"	f
load_strings	$HARELIB/debug/dwarf/strings.ha	/^export fn load_strings($/;"	f
local	$HARELIB/path/buffer.ha	/^export fn local(path: str) str = {$/;"	f
locality	$HARELIB/time/chrono/timezone.ha	/^export type locality = *timezone;$/;"	t
localnow	$HARELIB/time/date/date.ha	/^export fn localnow() date = {$/;"	f
location	$HARELIB/hare/lex/token.ha	/^export type location = struct {$/;"	t
location	$HARELIB/hare/module/types.ha	/^export type location = (*path::buffer | ast::ident);$/;"	t
location	$HARELIB/hare/parse/doc/doc.ha	/^export fn parse(in: io::handle, start: lex::location) (doc | error) = {$/;"	f
lock	$HARELIB/io/file.ha	/^export fn lock(fd: file, block: bool, op: lockop) (bool | error) = {$/;"	f
lockop	$HARELIB/io/file.ha	/^export type lockop = enum int {$/;"	t
locstr	$HARELIB/hare/module/types.ha	/^export fn locstr(loc: location) str = {$/;"	f
log10f64	$HARELIB/math/math.ha	/^export fn log10f64(x: f64) f64 = {$/;"	f
log1pf64	$HARELIB/math/math.ha	/^export fn log1pf64(x: f64) f64 = {$/;"	f
log2f64	$HARELIB/math/math.ha	/^export fn log2f64(x: f64) f64 = {$/;"	f
logc128	$HARELIB/math/complex/complex.ha	/^export fn logc128(z: c128) c128 = (math::logf64(absc128(z)), argc128(z));$/;"	f
logf64	$HARELIB/math/math.ha	/^export fn logf64(x: f64) f64 = {$/;"	f
logger	$HARELIB/log/logger.ha	/^export type logger = struct {$/;"	t
long	$HARELIB/types/c/arch+aarch64.ha	/^export type long = i64;$/;"	t
long	$HARELIB/types/c/arch+riscv64.ha	/^export type long = i64;$/;"	t
long	$HARELIB/types/c/arch+x86_64.ha	/^export type long = i64;$/;"	t
longjmp	$HARELIB/rt/jmp.ha	/^export fn longjmp(buf: *jmpbuf, n: int) never;$/;"	f
longlong	$HARELIB/types/c/arch+aarch64.ha	/^export type longlong = i64;$/;"	t
longlong	$HARELIB/types/c/arch+riscv64.ha	/^export type longlong = i64;$/;"	t
longlong	$HARELIB/types/c/arch+x86_64.ha	/^export type longlong = i64;$/;"	t
lookup	$HARELIB/hare/types/store.ha	/^export fn lookup($/;"	f
lookup	$HARELIB/os/exec/cmd.ha	/^export fn lookup(name: str) (str | void) = {$/;"	f
lookup	$HARELIB/unix/hosts/hosts.ha	/^export fn lookup(name: const str) ([]ip::addr | error) = {$/;"	f
lookup_builtin	$HARELIB/hare/types/lookup.ha	/^export fn lookup_builtin($/;"	f
lookup_ext	$HARELIB/mime/lookup.ha	/^export fn lookup_ext(ext: str) const nullable *mimetype = {$/;"	f
lookup_mime	$HARELIB/mime/lookup.ha	/^export fn lookup_mime(mime: str) const nullable *mimetype = {$/;"	f
lpad	$HARELIB/strings/pad.ha	/^export fn lpad(s: str, p: rune, maxlen: size) str = {$/;"	f
lprintfln	$HARELIB/log/funcs.ha	/^export fn lprintfln(log: *logger, fmt: str, fields: fmt::field...) void = {$/;"	f
lprintln	$HARELIB/log/funcs.ha	/^export fn lprintln(log: *logger, fields: fmt::formattable...) void = {$/;"	f
lseek	$HARELIB/rt/+darwin/syscalls.ha	/^export fn lseek(fd: int, off: i64, whence: int) (i64 | errno) = {$/;"	f
lseek	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn lseek(fd: int, off: i64, whence: int) (i64 | errno) = {$/;"	f
lseek	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn lseek(fd: int, off: i64, whence: int) (i64 | errno) = {$/;"	f
lseek	$HARELIB/rt/+linux/syscalls.ha	/^export fn lseek(fd: int, off: i64, whence: int) (i64 | errno) = {$/;"	f
lseek	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn lseek(fd: int, off: i64, whence: int) (i64 | errno) = {$/;"	f
lstat	$HARELIB/rt/+linux/stat.ha	/^export fn lstat(path: path, statbuf: *st) (errno | void) =$/;"	f
ltok	$HARELIB/hare/lex/token.ha	/^export type ltok = enum uint {$/;"	t
ltrim	$HARELIB/bytes/trim.ha	/^export fn ltrim(in: []u8, trim: u8...) []u8 = {$/;"	f
ltrim	$HARELIB/strings/trim.ha	/^export fn ltrim(input: str, trim: rune...) str = {$/;"	f
ltu32	$HARELIB/crypto/math/bits.ha	/^export fn ltu32(x: u32, y: u32) u32 = gtu32(y, x);$/;"	f
mac	$HARELIB/crypto/authenc.ha	/^export type mac = [16]u8;$/;"	t
mac	$HARELIB/crypto/mac/mac.ha	/^export type mac = struct {$/;"	t
machine	$HARELIB/os/+darwin/platform_environ.ha	/^export fn machine() const str = {$/;"	f
machine	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn machine() const str = {$/;"	f
machine	$HARELIB/os/+linux/platform_environ.ha	/^export fn machine() const str = {$/;"	f
machine	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn machine() const str = {$/;"	f
main	$HARELIB/hare/parse/+test/expr_test.ha	/^	roundtrip_reparse(`export fn main() void = {$/;"	f
main	$HARELIB/hare/parse/+test/unit_test.ha	/^		"export fn main() void = void;\\n\\n"$/;"	f
main	$HARELIB/test/+test.ha	/^export @symbol("__test_main") fn main() size = {$/;"	f
makeraw	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn makeraw(termios: *termios) (void | errors::error) = {$/;"	f
makeraw	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn makeraw(termios: *termios) (void | errors::error) = {$/;"	f
makeraw	$HARELIB/unix/tty/+linux/termios.ha	/^export fn makeraw(termios: *termios) (void | errors::error) = {$/;"	f
makeraw	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn makeraw(termios: *termios) (void | errors::error) = {$/;"	f
malloc	$HARELIB/rt/malloc+debug.ha	/^export fn malloc(n: size) nullable *opaque = {$/;"	f
malloc	$HARELIB/rt/malloc+libc.ha	/^export fn malloc(n: size) nullable *opaque = {$/;"	f
malloc	$HARELIB/rt/malloc.ha	/^export fn malloc(n: size) nullable *opaque = {$/;"	f
match_case	$HARELIB/hare/ast/expr.ha	/^export type match_case = struct {$/;"	t
match_expr	$HARELIB/hare/ast/expr.ha	/^export type match_expr = struct {$/;"	t
mcl	$HARELIB/os/+linux/memory.ha	/^export type mcl = enum uint {$/;"	t
mcontext	$HARELIB/rt/+darwin/+aarch64.ha	/^export type mcontext = struct {$/;"	t
mcontext	$HARELIB/rt/+darwin/+riscv64.ha	/^export type mcontext = struct {$/;"	t
mcontext	$HARELIB/rt/+darwin/+x86_64.ha	/^export type mcontext = struct {$/;"	t
mcontext	$HARELIB/rt/+freebsd/+aarch64.ha	/^export type mcontext = struct {$/;"	t
mcontext	$HARELIB/rt/+freebsd/+riscv64.ha	/^export type mcontext = struct {$/;"	t
mcontext	$HARELIB/rt/+freebsd/+x86_64.ha	/^export type mcontext = struct {$/;"	t
memcpy	$HARELIB/rt/memcpy.ha	/^export fn memcpy(dest: *opaque, src: *const opaque, n: size) void = {$/;"	f
memfd_create	$HARELIB/rt/+linux/syscalls.ha	/^export fn memfd_create(name: path, flags: uint) (int | errno) = {$/;"	f
memmove	$HARELIB/rt/memmove.ha	/^export fn memmove(dest: *opaque, src: *const opaque, n: size) void = {$/;"	f
memoize	$HARELIB/hash/crc16/crc16.ha	/^export fn memoize(polynomial: u16, buf: *[256]u16) void = {$/;"	f
memoize	$HARELIB/hash/crc32/crc32.ha	/^export fn memoize(polynomial: u32, buf: *[256]u32) void = {$/;"	f
memoize	$HARELIB/hash/crc64/crc64.ha	/^export fn memoize(polynomial: u64, buf: *[256]u64) void = {$/;"	f
memory_heap	$HARELIB/rt/malloc.ha	/^export type memory_heap = struct {$/;"	t
memset	$HARELIB/rt/memset.ha	/^export fn memset(dest: *opaque, val: u8, n: size) void = {$/;"	f
message	$HARELIB/net/dns/types.ha	/^export type message = struct {$/;"	t
message_free	$HARELIB/net/dns/types.ha	/^export fn message_free(msg: *message) void = {$/;"	f
meta	$HARELIB/rt/malloc.ha	/^export type meta = struct {$/;"	t
mflag	$HARELIB/io/+darwin/mmap.ha	/^export type mflag = enum uint {$/;"	t
mflag	$HARELIB/io/+freebsd/mmap.ha	/^export type mflag = enum uint {$/;"	t
mflag	$HARELIB/io/+linux/mmap.ha	/^export type mflag = enum uint {$/;"	t
mflag	$HARELIB/io/+openbsd/mmap.ha	/^export type mflag = enum int {$/;"	t
mimetype	$HARELIB/mime/database.ha	/^export type mimetype = struct {$/;"	t
minute	$HARELIB/time/date/observe.ha	/^export fn minute(d: *date) int = _minute(d);$/;"	f
mkblk	$HARELIB/os/+darwin/fs.ha	/^\/\/ export fn mkblk($/;"	f
mkblk	$HARELIB/os/+freebsd/fs.ha	/^\/\/ export fn mkblk($/;"	f
mkblk	$HARELIB/os/+linux/fs.ha	/^export fn mkblk($/;"	f
mkchr	$HARELIB/os/+darwin/fs.ha	/^\/\/ export fn mkchr($/;"	f
mkchr	$HARELIB/os/+freebsd/fs.ha	/^\/\/ export fn mkchr($/;"	f
mkchr	$HARELIB/os/+linux/fs.ha	/^export fn mkchr($/;"	f
mkdev	$HARELIB/rt/+linux/stat.ha	/^export fn mkdev(major: u32, minor: u32) dev_t =$/;"	f
mkdir	$HARELIB/fs/fs.ha	/^export fn mkdir(fs: *fs, path: str, mode: mode) (void | error) = {$/;"	f
mkdir	$HARELIB/os/os.ha	/^export fn mkdir(path: str, mode: fs::mode) (void | fs::error) = fs::mkdir(cwd, path, mode);$/;"	f
mkdir	$HARELIB/rt/+linux/syscalls.ha	/^export fn mkdir(path: path, mode: uint) (void | errno) = {$/;"	f
mkdirat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn mkdirat(dirfd: int, path: path, mode: uint) (void | errno) = {$/;"	f
mkdirat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn mkdirat(dirfd: int, path: path, mode: uint) (void | errno) = {$/;"	f
mkdirat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn mkdirat(dirfd: int, path: path, mode: uint) (void | errno) = {$/;"	f
mkdirat	$HARELIB/rt/+linux/syscalls.ha	/^export fn mkdirat(dirfd: int, path: path, mode: uint) (void | errno) = {$/;"	f
mkdirat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn mkdirat(dirfd: int, path: path, mode: mode_t) (void | errno) = {$/;"	f
mkdirfunc	$HARELIB/fs/types.ha	/^export type mkdirfunc = fn(fs: *fs, path: str, mode: mode) (void | error);$/;"	t
mkdirs	$HARELIB/fs/fs.ha	/^export fn mkdirs(fs: *fs, path: str, mode: mode) (void | error) = {$/;"	f
mkdirs	$HARELIB/os/os.ha	/^export fn mkdirs(path: str, mode: fs::mode) (void | fs::error) = fs::mkdirs(cwd, path, mode);$/;"	f
mkfifo	$HARELIB/os/+darwin/fs.ha	/^\/\/ export fn mkfifo(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkfifo	$HARELIB/os/+freebsd/fs.ha	/^\/\/ export fn mkfifo(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkfifo	$HARELIB/os/+linux/fs.ha	/^export fn mkfifo(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkfifo	$HARELIB/os/+openbsd/fs.ha	/^export fn mkfifo(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkfile	$HARELIB/os/+darwin/fs.ha	/^\/\/ export fn mkfile($/;"	f
mkfile	$HARELIB/os/+freebsd/fs.ha	/^\/\/ export fn mkfile($/;"	f
mkfile	$HARELIB/os/+linux/fs.ha	/^export fn mkfile(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkfile	$HARELIB/os/+openbsd/fs.ha	/^export fn mkfile(path: str, mode: fs::mode) (void | fs::error) = {$/;"	f
mkloc	$HARELIB/hare/lex/lex.ha	/^export fn mkloc(lex: *lexer) location = {$/;"	f
mknodat	$HARELIB/rt/+linux/syscalls.ha	/^export fn mknodat($/;"	f
mknodat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn mknodat($/;"	f
mkvector	$HARELIB/io/+darwin/vector.ha	/^export fn mkvector(buf: []u8) vector = vector {$/;"	f
mkvector	$HARELIB/io/+freebsd/vector.ha	/^export fn mkvector(buf: []u8) vector = vector {$/;"	f
mkvector	$HARELIB/io/+linux/vector.ha	/^export fn mkvector(buf: []u8) vector = vector {$/;"	f
mkvector	$HARELIB/io/+openbsd/vector.ha	/^export fn mkvector(buf: []u8) vector = vector {$/;"	f
mlock	$HARELIB/os/+linux/memory.ha	/^export fn mlock($/;"	f
mlock2	$HARELIB/rt/+linux/syscalls.ha	/^export fn mlock2(addr: *opaque, length: size, flags: uint) (void | errno) = {$/;"	f
mlockall	$HARELIB/os/+linux/memory.ha	/^export fn mlockall(flags: mcl) (void | errors::error) = {$/;"	f
mlockall	$HARELIB/rt/+linux/syscalls.ha	/^export fn mlockall(flags: uint) (void | errno) = {$/;"	f
mmap	$HARELIB/io/+darwin/mmap.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/io/+freebsd/mmap.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/io/+linux/mmap.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/io/+openbsd/mmap.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/rt/+darwin/syscalls.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn mmap($/;"	f
mmap	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/rt/+linux/syscalls.ha	/^export fn mmap($/;"	f
mmap	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn mmap($/;"	f
mod_ref	$HARELIB/hare/parse/doc/doc.ha	/^export type mod_ref = ast::ident;$/;"	t
mode	$HARELIB/fs/types.ha	/^export type mode = enum uint {$/;"	t
mode	$HARELIB/io/types.ha	/^export type mode = enum u8 {$/;"	t
mode	$HARELIB/unix/+darwin/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t): fs::mode;$/;"	f
mode	$HARELIB/unix/+freebsd/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t)!: fs::mode;$/;"	f
mode	$HARELIB/unix/+linux/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode)!: fs::mode;$/;"	f
mode	$HARELIB/unix/+openbsd/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t)!: fs::mode;$/;"	f
mode_perm	$HARELIB/fs/util.ha	/^export fn mode_perm(m: mode) mode = (m: uint & 0o777u): mode;$/;"	f
mode_str	$HARELIB/fs/util.ha	/^export fn mode_str(m: mode) const str = {$/;"	f
mode_t	$HARELIB/rt/+darwin/types.ha	/^export type mode_t      = u16;$/;"	t
mode_t	$HARELIB/rt/+freebsd/types.ha	/^export type mode_t = u16;$/;"	t
mode_t	$HARELIB/rt/+linux/types.ha	/^export type mode_t = uint;$/;"	t
mode_t	$HARELIB/rt/+openbsd/types.ha	/^export type mode_t = u32;$/;"	t
mode_type	$HARELIB/fs/util.ha	/^export fn mode_type(m: mode) mode = (m: uint & ~0o777u): mode;$/;"	f
modf64	$HARELIB/math/math.ha	/^export fn modf64(x: f64, y: f64) f64 = {$/;"	f
modfracf32	$HARELIB/math/floats.ha	/^export fn modfracf32(n: f32) (f32, f32) = {$/;"	f
modfracf64	$HARELIB/math/floats.ha	/^export fn modfracf64(n: f64) (f64, f64) = {$/;"	f
modpow	$HARELIB/crypto/bigint/arithm.ha	/^export fn modpow($/;"	f
mods	$HARELIB/fmt/iter.ha	/^export type mods = struct {$/;"	t
module	$HARELIB/hare/module/deps.ha	/^export type module = struct {$/;"	t
moment	$HARELIB/time/chrono/chronology.ha	/^export type moment = struct {$/;"	t
moment	$HARELIB/time/date/date.ha	/^export fn from_moment(m: chrono::moment) date = {$/;"	f
month	$HARELIB/time/date/observe.ha	/^export fn month(d: *date) int = _month(d);$/;"	f
montymul	$HARELIB/crypto/bigint/monty.ha	/^export fn montymul($/;"	f
more	$HARELIB/encoding/utf8/types.ha	/^export type more = void;$/;"	t
mount	$HARELIB/rt/+linux/syscalls.ha	/^export fn mount($/;"	f
move	$HARELIB/fs/fs.ha	/^export fn move(fs: *fs, oldpath: str, newpath: str) (void | error) = {$/;"	f
move	$HARELIB/os/os.ha	/^export fn move(oldpath: str, newpath: str) (void | fs::error) =$/;"	f
mprotect	$HARELIB/rt/+linux/syscalls.ha	/^export fn mprotect(addr: *opaque, length: size, prot: uint) (void | errno) = {$/;"	f
mremap	$HARELIB/rt/+linux/syscalls.ha	/^export fn mremap($/;"	f
msghdr	$HARELIB/net/msg.ha	/^export type msghdr = struct {$/;"	t
msghdr	$HARELIB/net/unix/cmsg.ha	/^export fn allocfiles(buf: *net::msghdr, nfile: size) void = {$/;"	f
msghdr	$HARELIB/rt/+darwin/socket.ha	/^export type msghdr = struct {$/;"	t
msghdr	$HARELIB/rt/+freebsd/socket.ha	/^export type msghdr = struct {$/;"	t
msghdr	$HARELIB/rt/+linux/socket.ha	/^export type msghdr = struct {$/;"	t
msghdr	$HARELIB/rt/+openbsd/socket.ha	/^export type msghdr = struct {$/;"	t
mulacc	$HARELIB/crypto/bigint/arithm.ha	/^export fn mulacc(d: []word, a: const []word, b: const []word) void = {$/;"	f
mulc128	$HARELIB/math/complex/complex.ha	/^export fn mulc128(a: c128, b: c128) c128 =$/;"	f
mulc64	$HARELIB/math/complex/complex.ha	/^export fn mulc64(a: c64, b: c64) c64 =$/;"	f
muli16	$HARELIB/math/checked/checked.ha	/^export fn muli16(a: i16, b: i16) (i16, bool) = {$/;"	f
muli32	$HARELIB/math/checked/checked.ha	/^export fn muli32(a: i32, b: i32) (i32, bool) = {$/;"	f
muli64	$HARELIB/math/checked/checked.ha	/^export fn muli64(a: i64, b: i64) (i64, bool) = {$/;"	f
muli8	$HARELIB/math/checked/checked.ha	/^export fn muli8(a: i8, b: i8) (i8, bool) = {$/;"	f
mult	$HARELIB/time/arithm.ha	/^export fn mult(i: instant, f: f64) instant = {$/;"	f
multireplace	$HARELIB/strings/replace.ha	/^export fn multireplace(s: str, repls: (str, str)...) str = {$/;"	f
mulu	$HARELIB/math/uints.ha	/^export fn mulu(x: uint, y: uint) (uint, uint) = {$/;"	f
mulu16	$HARELIB/math/checked/checked.ha	/^export fn mulu16(a: u16, b: u16) (u16, bool) = {$/;"	f
mulu32	$HARELIB/crypto/math/bits.ha	/^export fn mulu32(x: u32, y: u32) u64 = x: u64 * y: u64;$/;"	f
mulu32	$HARELIB/math/checked/checked.ha	/^export fn mulu32(a: u32, b: u32) (u32, bool) = {$/;"	f
mulu32	$HARELIB/math/uints.ha	/^export fn mulu32(x: u32, y: u32) (u32, u32) = {$/;"	f
mulu64	$HARELIB/math/checked/checked.ha	/^export fn mulu64(a: u64, b: u64) (u64, bool) = {$/;"	f
mulu64	$HARELIB/math/uints.ha	/^export fn mulu64(x: u64, y: u64) (u64, u64) = {$/;"	f
mulu8	$HARELIB/math/checked/checked.ha	/^export fn mulu8(a: u8, b: u8) (u8, bool) = {$/;"	f
munlock	$HARELIB/os/+linux/memory.ha	/^export fn munlock(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
munlock	$HARELIB/rt/+linux/syscalls.ha	/^export fn munlock(addr: *opaque, length: size) (void | errno) = {$/;"	f
munlockall	$HARELIB/os/+linux/memory.ha	/^export fn munlockall() (void | errors::error) = {$/;"	f
munlockall	$HARELIB/rt/+linux/syscalls.ha	/^export fn munlockall() (void | errno) = {$/;"	f
munmap	$HARELIB/io/+darwin/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
munmap	$HARELIB/io/+freebsd/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
munmap	$HARELIB/io/+linux/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
munmap	$HARELIB/io/+openbsd/mmap.ha	/^export fn munmap(addr: *opaque, length: size) (void | errors::error) = {$/;"	f
munmap	$HARELIB/rt/+darwin/syscalls.ha	/^export fn munmap(addr: *opaque, length: size) (void | errno) = {$/;"	f
munmap	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn munmap(addr: *opaque, length: size) (void | errno) = {$/;"	f
munmap	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn munmap(addr: *opaque, length: size) (void | errno) = {$/;"	f
munmap	$HARELIB/rt/+linux/syscalls.ha	/^export fn munmap(addr: *opaque, length: size) (void | errno) = {$/;"	f
munmap	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn munmap(addr: *opaque, len_: size) (void | errno) = {$/;"	f
muxu32	$HARELIB/crypto/math/bits.ha	/^export fn muxu32(ctl: u32, x: u32, y: u32) u32 = y ^ ((-(ctl: i32)): u32 & (x ^ y));$/;"	f
my_stream	$HARELIB/io/stream.ha	/^\/\/	export type my_stream = struct {$/;"	t
name_error	$HARELIB/net/dns/error.ha	/^export type name_error = !void;$/;"	t
name_exists	$HARELIB/net/dns/error.ha	/^export type name_exists = !void;$/;"	t
named	$HARELIB/temp/+darwin.ha	/^export fn named($/;"	f
named	$HARELIB/temp/+freebsd.ha	/^export fn named($/;"	f
named	$HARELIB/temp/+linux.ha	/^export fn named($/;"	f
nanosecond	$HARELIB/time/date/observe.ha	/^export fn nanosecond(d: *date) int = _nanosecond(d);$/;"	f
nanosleep	$HARELIB/rt/+darwin/syscalls.ha	/^export fn nanosleep(req: *const timespec, rem: nullable *timespec) (void | errno) = {$/;"	f
nanosleep	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn nanosleep(req: *const timespec, rem: nullable *timespec) (void | errno) = {$/;"	f
nanosleep	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn nanosleep(req: *const timespec, rem: *timespec) (void | errno) = {$/;"	f
nanosleep	$HARELIB/rt/+linux/syscalls.ha	/^export fn nanosleep(req: *const timespec, rem: *timespec) (void | errno) = {$/;"	f
nanosleep	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn nanosleep($/;"	f
native_addrlen	$HARELIB/net/ip/+darwin.ha	/^export fn native_addrlen(a: addr) u32 = {$/;"	f
native_addrlen	$HARELIB/net/ip/+freebsd.ha	/^export fn native_addrlen(a: addr) u32 = {$/;"	f
native_addrlen	$HARELIB/net/ip/+openbsd.ha	/^export fn native_addrlen(a: addr) u32 = {$/;"	f
neg	$HARELIB/fmt/iter.ha	/^export type neg = enum {$/;"	t
neg	$HARELIB/time/date/period.ha	/^export fn neg(p: period) period = period {$/;"	f
negc128	$HARELIB/math/complex/complex.ha	/^export fn negc128(z: c128) c128 = (-z.0, -z.1);$/;"	f
negc64	$HARELIB/math/complex/complex.ha	/^export fn negc64(z: c64) c64 = (-z.0, -z.1);$/;"	f
nequ32	$HARELIB/crypto/math/bits.ha	/^export fn nequ32(x: u32, y: u32) u32 = {$/;"	f
new	$HARELIB/crypto/blowfish/blowfish.ha	/^export fn new() state = {$/;"	f
new	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export fn new($/;"	f
new	$HARELIB/log/logger.ha	/^export fn new(sink: io::handle) stdlogger = {$/;"	f
new	$HARELIB/time/chrono/chronology.ha	/^export fn new(loc: locality, i: time::instant) moment = {$/;"	f
new	$HARELIB/time/date/date.ha	/^export fn new($/;"	f
new_flag	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type new_flag = enum int {$/;"	t
newalias	$HARELIB/hare/types/store.ha	/^export fn newalias($/;"	f
newdecoder	$HARELIB/encoding/base32/base32.ha	/^export fn newdecoder($/;"	f
newdecoder	$HARELIB/encoding/base64/base64.ha	/^export fn newdecoder($/;"	f
newdecoder	$HARELIB/encoding/hex/hex.ha	/^export fn newdecoder(in: io::handle) decoder = {$/;"	f
newdecoder	$HARELIB/encoding/pem/pem.ha	/^export fn newdecoder(in: io::handle) decoder = {$/;"	f
newencoder	$HARELIB/encoding/base32/base32.ha	/^export fn newencoder($/;"	f
newencoder	$HARELIB/encoding/base64/base64.ha	/^export fn newencoder($/;"	f
newencoder	$HARELIB/encoding/hex/hex.ha	/^export fn newencoder(out: io::handle) encoder = {$/;"	f
newencoder	$HARELIB/encoding/pem/pem.ha	/^export fn newencoder(label: str, s: io::handle) (pemencoder | io::error) = {$/;"	f
newheap	$HARELIB/rt/malloc.ha	/^export fn newheap() memory_heap = {$/;"	f
newkey	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn newkey(priv: *privkey, rand: io::handle) (void | io::error) =$/;"	f
newkey	$HARELIB/crypto/keystore/impl+linux.ha	/^export fn newkey(buf: []u8, name: str) (key | errors::error) = {$/;"	f
newkey	$HARELIB/crypto/keystore/impl.ha	/^export fn newkey(buf: []u8, name: str) (key | errors::error) = {$/;"	f
newkey	$HARELIB/crypto/x25519/x25519.ha	/^export fn newkey(priv: []u8, seed: []u8) void = {$/;"	f
newmsg	$HARELIB/net/msg.ha	/^export fn newmsg() msghdr = msghdr { ... };$/;"	f
newscanner	$HARELIB/bufio/scanner.ha	/^export fn newscanner(src: io::handle, maxread: size) scanner = {$/;"	f
newscanner_static	$HARELIB/bufio/scanner.ha	/^export fn newscanner_static(src: io::handle, buffer: []u8) scanner = {$/;"	f
newsigset	$HARELIB/unix/signal/+darwin.ha	/^export fn newsigset(items: sig...) sigset = {$/;"	f
newsigset	$HARELIB/unix/signal/+freebsd.ha	/^export fn newsigset(items: sig...) sigset = {$/;"	f
newsigset	$HARELIB/unix/signal/+linux.ha	/^export fn newsigset(items: sig...) sigset = {$/;"	f
newsigset	$HARELIB/unix/signal/+openbsd.ha	/^export fn newsigset(items: sig...) sigset = {$/;"	f
newvirtual	$HARELIB/time/date/virtual.ha	/^export fn newvirtual() virtual = virtual {$/;"	f
next	$HARELIB/debug/+aarch64/walk.ha	/^export fn next(frame: stackframe) (stackframe | void) = {$/;"	f
next	$HARELIB/debug/+riscv64/walk.ha	/^export fn next(frame: stackframe) (stackframe | void) = {$/;"	f
next	$HARELIB/debug/+x86_64/walk.ha	/^export fn next(frame: stackframe) (stackframe | void) = {$/;"	f
next	$HARELIB/encoding/pem/pem.ha	/^export fn next(dec: *decoder) ((str, pemdecoder) | io::EOF | io::error) = {$/;"	f
next	$HARELIB/encoding/utf8/decode.ha	/^export fn next(d: *decoder) (rune | void | more | invalid) = {$/;"	f
next	$HARELIB/format/ini/scan.ha	/^export fn next(sc: *scanner) (entry | io::EOF | error) = {$/;"	f
next	$HARELIB/format/tar/reader.ha	/^export fn next(rd: *reader) (entry | error | io::EOF) = {$/;"	f
next	$HARELIB/fs/fs.ha	/^export fn next(iter: *iterator) (dirent | void | error) = iter.next(iter);$/;"	f
next	$HARELIB/glob/glob.ha	/^export fn next(gen: *generator) (str | void | failure) = {$/;"	f
next	$HARELIB/hare/module/util.ha	/^export fn next(it: *fs::iterator) (fs::dirent | void | fs::error) = {$/;"	f
next	$HARELIB/math/random/random.ha	/^export fn next(r: *random) u64 = {$/;"	f
next	$HARELIB/strings/iter.ha	/^export fn next(iter: *iterator) (rune | void) = move(!iter.reverse, iter);$/;"	f
next	$HARELIB/unix/hosts/hosts.ha	/^export fn next(it: *iterator) (host | void | error) = for (true) {$/;"	f
next_param	$HARELIB/mime/parse.ha	/^export fn next_param(in: *type_params) ((str, str) | void | errors::invalid) = {$/;"	f
next_token	$HARELIB/bytes/tokenize.ha	/^export fn next_token(s: *tokenizer) ([]u8 | void) = match (peek_token(s)) {$/;"	f
next_token	$HARELIB/strings/tokenize.ha	/^export fn next_token(s: *tokenizer) (str | void) = {$/;"	f
nextafterf32	$HARELIB/math/floats.ha	/^export fn nextafterf32(x: f32, y: f32) f32 = {$/;"	f
nextafterf64	$HARELIB/math/floats.ha	/^export fn nextafterf64(x: f64, y: f64) f64 = {$/;"	f
nextfunc	$HARELIB/fs/types.ha	/^export type nextfunc = fn(iter: *iterator) (dirent | void | error);$/;"	t
nextgr	$HARELIB/unix/passwd/group.ha	/^export fn nextgr(in: io::handle) (grent | io::EOF | io::error | invalid) = {$/;"	f
nextiter	$HARELIB/path/iter.ha	/^export fn nextiter(it: *iterator) (str | void) = {$/;"	f
nextpw	$HARELIB/unix/passwd/passwd.ha	/^export fn nextpw(in: io::handle) (pwent | io::EOF | io::error | invalid) = {$/;"	f
nfds_t	$HARELIB/rt/+darwin/types.ha	/^export type nfds_t      = uint;$/;"	t
nfds_t	$HARELIB/rt/+freebsd/types.ha	/^export type nfds_t = uint;$/;"	t
nfds_t	$HARELIB/rt/+linux/types.ha	/^export type nfds_t = u64;$/;"	t
nfds_t	$HARELIB/rt/+openbsd/types.ha	/^export type nfds_t = uint;$/;"	t
nice	$HARELIB/unix/+darwin/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
nice	$HARELIB/unix/+freebsd/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
nice	$HARELIB/unix/+linux/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
nice	$HARELIB/unix/+openbsd/nice.ha	/^export fn nice(inc: int) (void | errors::error) = {$/;"	f
ninv	$HARELIB/crypto/bigint/arithm.ha	/^export fn ninv(m0: word) word = ninv31(m0);$/;"	f
nlink_t	$HARELIB/rt/+darwin/types.ha	/^export type nlink_t     = u16;$/;"	t
nlink_t	$HARELIB/rt/+freebsd/types.ha	/^export type nlink_t = u64;$/;"	t
nlink_t	$HARELIB/rt/+linux/types.ha	/^export type nlink_t = u64;$/;"	t
nlink_t	$HARELIB/rt/+openbsd/types.ha	/^export type nlink_t = u32;$/;"	t
noaccess	$HARELIB/errors/common.ha	/^export type noaccess = !void;$/;"	t
noaccess	$HARELIB/unix/+darwin/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
noaccess	$HARELIB/unix/+freebsd/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
noaccess	$HARELIB/unix/+linux/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
noaccess	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpsid(pid: pid) (pid | errors::noentry | errors::noaccess) = {$/;"	f
noecho	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn noecho(termios: *termios) (void | errors::error) = {$/;"	f
noecho	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn noecho(termios: *termios) (void | errors::error) = {$/;"	f
noecho	$HARELIB/unix/tty/+linux/termios.ha	/^export fn noecho(termios: *termios) (void | errors::error) = {$/;"	f
noecho	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn noecho(termios: *termios) (void | errors::error) = {$/;"	f
noentry	$HARELIB/errors/common.ha	/^export type noentry = !void;$/;"	t
noentry	$HARELIB/unix/+linux/creds.ha	/^export fn getpgid(pid: pid) (pid | errors::noentry) = {$/;"	f
noentry	$HARELIB/unix/+openbsd/creds.ha	/^export fn getpgid(pid: pid) (pid | errors::noentry) = {$/;"	f
nokey	$HARELIB/linux/keyctl/+linux/types.ha	/^export type nokey = !void;$/;"	t
nomem	$HARELIB/errors/common.ha	/^export type nomem = !void;$/;"	t
noncanonical	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn noncanonical(termios: *termios) (void | errors::error) = {$/;"	f
noncanonical	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn noncanonical(termios: *termios) (void | errors::error) = {$/;"	f
noncanonical	$HARELIB/unix/tty/+linux/termios.ha	/^export fn noncanonical(termios: *termios) (void | errors::error) = {$/;"	f
nonce	$HARELIB/crypto/authenc.ha	/^export type nonce = [24]u8;$/;"	t
noresolver	$HARELIB/hare/types/store.ha	/^export type noresolver = !void;$/;"	t
normalizef32	$HARELIB/math/floats.ha	/^export fn normalizef32(n: f32) (f32, i64) = {$/;"	f
normalizef64	$HARELIB/math/floats.ha	/^export fn normalizef64(n: f64) (f64, i64) = {$/;"	f
not_auth	$HARELIB/net/dns/error.ha	/^export type not_auth = !void;$/;"	t
not_found	$HARELIB/hare/module/types.ha	/^export type not_found = !void;$/;"	t
not_implemented	$HARELIB/net/dns/error.ha	/^export type not_implemented = !void;$/;"	t
not_prefix	$HARELIB/path/error.ha	/^export type not_prefix = !void;$/;"	t
not_zone	$HARELIB/net/dns/error.ha	/^export type not_zone = !void;$/;"	t
notu32	$HARELIB/crypto/math/bits.ha	/^export fn notu32(x: u32) u32 = x ^ 1;$/;"	f
now	$HARELIB/time/+darwin/functions.ha	/^export fn now(clock: clock) instant = {$/;"	f
now	$HARELIB/time/+freebsd/functions.ha	/^export fn now(clock: clock) instant = {$/;"	f
now	$HARELIB/time/+linux/functions.ha	/^export fn now(clock: clock) instant = {$/;"	f
now	$HARELIB/time/+openbsd/functions.ha	/^export fn now(clock: clock) instant = {$/;"	f
now	$HARELIB/time/date/date.ha	/^export fn now() date = {$/;"	f
nparallel	$HARELIB/crypto/cipher/block.ha	/^export fn nparallel(b: *block) size = b.nparallel;$/;"	f
nsec	$HARELIB/net/dns/types.ha	/^export type nsec = struct {$/;"	t
ntohu16	$HARELIB/endian/network.ha	/^export fn ntohu16(in: u16) u16 = htonu16(in);$/;"	f
ntohu32	$HARELIB/endian/network.ha	/^export fn ntohu32(in: u32) u32 = htonu32(in);$/;"	f
ntohu64	$HARELIB/endian/network.ha	/^export fn ntohu64(in: u64) u64 = htonu64(in);$/;"	f
nullfd	$HARELIB/os/exec/types.ha	/^export type nullfd = void;$/;"	t
nullpromise	$HARELIB/rt/+openbsd/types.ha	/^export type nullpromise = void;$/;"	t
nullstd	$HARELIB/os/exec/cmd.ha	/^export fn nullstd(cmd: *command) void = {$/;"	f
nulstr	$HARELIB/types/c/strings.ha	/^export fn nulstr(s: const str) *const char = {$/;"	f
number_literal	$HARELIB/hare/ast/expr.ha	/^export type number_literal = struct {$/;"	t
numeric	$HARELIB/strconv/numeric.ha	/^export fn numerictosb(n: types::numeric, b: base) const str = {$/;"	f
numeric	$HARELIB/types/classes.ha	/^export type numeric = (...integer | ...floating);$/;"	t
numerictos	$HARELIB/strconv/numeric.ha	/^export fn numerictos(n: types::numeric) const str = numerictosb(n, base::DEC);$/;"	f
numerictosb	$HARELIB/strconv/numeric.ha	/^export fn numerictosb(n: types::numeric, b: base) const str = {$/;"	f
object	$HARELIB/hare/unit/scope.ha	/^export type object = struct {$/;"	t
object_kind	$HARELIB/hare/unit/scope.ha	/^export type object_kind = enum {$/;"	t
octetstrreader	$HARELIB/encoding/asn1/decoder.ha	/^export fn octetstrreader(d: *decoder) (bytestream | error) = {$/;"	f
octetstrwriter	$HARELIB/encoding/asn1/encoder.ha	/^export fn octetstrwriter(e: *encoder) (bytewstream | overflow) = {$/;"	f
off	$HARELIB/io/arch+aarch64.ha	/^export type off = i64;$/;"	t
off	$HARELIB/io/arch+riscv64.ha	/^export type off = i64;$/;"	t
off	$HARELIB/io/arch+x86_64.ha	/^export type off = i64;$/;"	t
off_t	$HARELIB/rt/+darwin/types.ha	/^export type off_t       = i64;$/;"	t
off_t	$HARELIB/rt/+freebsd/types.ha	/^export type off_t = i64;$/;"	t
off_t	$HARELIB/rt/+linux/types.ha	/^export type off_t = i64;$/;"	t
off_t	$HARELIB/rt/+openbsd/types.ha	/^export type off_t = i64;$/;"	t
offset_expr	$HARELIB/hare/ast/expr.ha	/^export type offset_expr = *expr;$/;"	t
oid	$HARELIB/encoding/asn1/oid.ha	/^export type oid = u32;$/;"	t
oid_from_der	$HARELIB/encoding/asn1/oid.ha	/^export fn oid_from_der(db: *oiddb, raw: []u8) (void | oid) = {$/;"	f
oid_to_der	$HARELIB/encoding/asn1/oid.ha	/^export fn oid_to_der(db: *oiddb, o: oid) []u8 = {$/;"	f
oiddb	$HARELIB/encoding/asn1/oid.ha	/^export type oiddb = struct {$/;"	t
onabort	$HARELIB/rt/abort+test.ha	/^export fn onabort(handler: *abort_handler) void = {$/;"	f
onabort	$HARELIB/rt/abort.ha	/^export fn onabort(handler: *abort_handler) void = {$/;"	f
oneshot	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type oneshot = time::duration;$/;"	t
opaque_	$HARELIB/errors/opaque.ha	/^export type opaque_ = !struct {$/;"	t
opaque_data	$HARELIB/errors/opaque.ha	/^export type opaque_data = [24]u8;$/;"	t
opcode	$HARELIB/net/dns/types.ha	/^export type opcode = enum u8 {$/;"	t
open	$HARELIB/debug/image/open.ha	/^export fn open($/;"	f
open	$HARELIB/fs/fs.ha	/^export fn open(fs: *fs, path: str, flags: flag...) (io::handle | error) = {$/;"	f
open	$HARELIB/io/stream.ha	/^\/\/	export fn open(path: str) my_stream = {$/;"	f
open	$HARELIB/os/os.ha	/^export fn open(path: str, flags: fs::flag...) (io::file | fs::error) =$/;"	f
open	$HARELIB/rt/+darwin/syscalls.ha	/^export fn open(path: str, flags: int, mode: uint) (int | errno) = {$/;"	f
open	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn open(path: str, flags: int, mode: uint) (int | errno) = {$/;"	f
open	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn open(path: str, flags: int, mode: uint) (int | errno) = {$/;"	f
open	$HARELIB/rt/+linux/syscalls.ha	/^export fn open(path: path, flags: int, mode: uint) (int | errno) = {$/;"	f
open	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn open(path: path, flags: int, mode: int) (int | errno) = {$/;"	f
open	$HARELIB/unix/tty/+darwin/open.ha	/^export fn open() (io::file | error) = {$/;"	f
open	$HARELIB/unix/tty/+freebsd/open.ha	/^export fn open() (io::file | error) = {$/;"	f
open	$HARELIB/unix/tty/+linux/open.ha	/^export fn open() (io::file | error) = {$/;"	f
open	$HARELIB/unix/tty/+openbsd/open.ha	/^export fn open() (io::file | error) = {$/;"	f
open_explicit	$HARELIB/encoding/asn1/decoder.ha	/^export fn open_explicit(d: *decoder, c: class, tag: u32) (void | error) =$/;"	f
open_file	$HARELIB/fs/fs.ha	/^export fn open_file(fs: *fs, path: str, flags: flag...) (io::file | error) = {$/;"	f
open_how	$HARELIB/rt/+linux/types.ha	/^export type open_how = struct {$/;"	t
open_seq	$HARELIB/encoding/asn1/decoder.ha	/^export fn open_seq(d: *decoder) (void | error) =$/;"	f
open_set	$HARELIB/encoding/asn1/decoder.ha	/^export fn open_set(d: *decoder) (void | error) =$/;"	f
openat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn openat($/;"	f
openat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn openat($/;"	f
openat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn openat($/;"	f
openat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn openat($/;"	f
openat2	$HARELIB/rt/+linux/syscalls.ha	/^export fn openat2($/;"	f
openfilefunc	$HARELIB/fs/types.ha	/^export type openfilefunc = fn($/;"	t
openfunc	$HARELIB/fs/types.ha	/^export type openfunc = fn($/;"	t
openpty	$HARELIB/unix/tty/+darwin/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
openpty	$HARELIB/unix/tty/+freebsd/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
openpty	$HARELIB/unix/tty/+linux/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
openpty	$HARELIB/unix/tty/+openbsd/pty.ha	/^export fn openpty() ((io::file, io::file) | fs::error) = {$/;"	f
opt	$HARELIB/net/dns/types.ha	/^export type opt = struct {$/;"	t
outdated	$HARELIB/hare/module/util.ha	/^export fn outdated(target: str, deps: []str, mtime: time::instant) bool = {$/;"	f
overflow	$HARELIB/encoding/asn1/errors.ha	/^export type overflow = !void;$/;"	t
overflow	$HARELIB/errors/common.ha	/^export type overflow = !void;$/;"	t
overflow	$HARELIB/strconv/types.ha	/^export type overflow = !void;$/;"	t
ozone	$HARELIB/time/chrono/chronology.ha	/^export fn ozone(m: *moment) zone = {$/;"	f
p256	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn p256() p256key = p256key {$/;"	f
p256key	$HARELIB/crypto/ecdh/ecdh.ha	/^export type p256key = struct {$/;"	t
p384	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn p384() p384key = p384key {$/;"	f
p384key	$HARELIB/crypto/ecdh/ecdh.ha	/^export type p384key = struct {$/;"	t
p521	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn p521() p521key = p521key {$/;"	f
p521key	$HARELIB/crypto/ecdh/ecdh.ha	/^export type p521key = struct {$/;"	t
paragraph	$HARELIB/hare/parse/doc/doc.ha	/^export type paragraph = [](str | decl_ref | mod_ref);$/;"	t
param	$HARELIB/strings/template/template.ha	/^export type param = (str, fmt::formattable);$/;"	t
parameter_help	$HARELIB/getopt/getopts.ha	/^export type parameter_help = (rune, str, str);$/;"	t
parent	$HARELIB/path/stack.ha	/^export fn parent(buf: *const buffer) (str | error) = {$/;"	f
parse	$HARELIB/getopt/getopts.ha	/^export fn parse(args: []str, help: help...) command = {$/;"	f
parse	$HARELIB/hare/parse/doc/doc.ha	/^export fn parse(in: io::handle, start: lex::location) (doc | error) = {$/;"	f
parse	$HARELIB/mime/parse.ha	/^export fn parse(in: str) ((str, type_params) | errors::invalid) = {$/;"	f
parse	$HARELIB/net/ip/ip.ha	/^export fn parse(s: str) (addr | invalid) = {$/;"	f
parse	$HARELIB/net/uri/parse.ha	/^export fn parse(in: str) (uri | invalid) = {$/;"	f
parse	$HARELIB/time/date/parse.ha	/^export fn parse(v: *virtual, layout: str, s: str) (void | parsefail) = {$/;"	f
parse_deps	$HARELIB/hare/module/deps.ha	/^export fn parse_deps(files: str...) ([]ast::ident | error) = {$/;"	f
parse_domain	$HARELIB/net/dns/strdomain.ha	/^export fn parse_domain(in: str) []str = strings::split(in, ".");$/;"	f
parse_tags	$HARELIB/hare/module/srcs.ha	/^export fn parse_tags(s: str) ([]tag | error) = {$/;"	f
parsecidr	$HARELIB/net/ip/ip.ha	/^export fn parsecidr(st: str) (subnet | invalid) = {$/;"	f
parsefail	$HARELIB/time/date/parse.ha	/^export type parsefail = !(size, rune);$/;"	t
parsev4	$HARELIB/net/ip/ip.ha	/^export fn parsev4(st: str) (addr4 | invalid) = {$/;"	f
parsev6	$HARELIB/net/ip/ip.ha	/^export fn parsev6(st: str) (addr6 | invalid) = {$/;"	f
path	$HARELIB/rt/+darwin/syscalls.ha	/^export type path = (str | []u8 | *const u8);$/;"	t
path	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export type path = (str | []u8 | *const char);$/;"	t
path	$HARELIB/rt/+freebsd/syscalls.ha	/^export type path = (str | []u8 | *const u8);$/;"	t
path	$HARELIB/rt/+linux/syscalls.ha	/^export type path = (str | []u8 | *const u8);$/;"	t
path	$HARELIB/rt/+openbsd/syscalls.ha	/^export type path = (str | []u8 | *const u8);$/;"	t
pattern	$HARELIB/glob/glob.ha	/^export type pattern = struct {$/;"	t
pdiff	$HARELIB/time/date/parithm.ha	/^export fn pdiff(a: date, b: date) period = {$/;"	f
peek	$HARELIB/encoding/asn1/decoder.ha	/^export fn peek(d: *decoder) (head | error) = {$/;"	f
peek	$HARELIB/os/exec/+darwin/process.ha	/^export fn peek(proc: *process) (status | void | error) = {$/;"	f
peek	$HARELIB/os/exec/+freebsd/process.ha	/^export fn peek(proc: *process) (status | void | error) = {$/;"	f
peek	$HARELIB/os/exec/+linux/process.ha	/^export fn peek(proc: *process) (status | void | error) = {$/;"	f
peek	$HARELIB/os/exec/+openbsd/process.ha	/^export fn peek(proc: *process) (status | void | error) = {$/;"	f
peek	$HARELIB/path/stack.ha	/^export fn peek(buf: *const buffer) (str | void) = split(buf).1;$/;"	f
peek_ext	$HARELIB/path/ext_stack.ha	/^export fn peek_ext(buf: *buffer) (str | void) = split_ext(buf).1;$/;"	f
peek_exts	$HARELIB/path/ext_stack.ha	/^export fn peek_exts(buf: *buffer) (str | void) = split_exts(buf).1;$/;"	f
peek_token	$HARELIB/bytes/tokenize.ha	/^export fn peek_token(s: *tokenizer) ([]u8 | void) = {$/;"	f
peek_token	$HARELIB/strings/tokenize.ha	/^export fn peek_token(s: *tokenizer) (str | void) = {$/;"	f
peekany	$HARELIB/os/exec/+darwin/process.ha	/^export fn peekany() ((process, status) | void | error) = {$/;"	f
peekany	$HARELIB/os/exec/+freebsd/process.ha	/^export fn peekany() ((process, status) | void | error) = {$/;"	f
peekany	$HARELIB/os/exec/+linux/process.ha	/^export fn peekany() ((process, status) | void | error) = {$/;"	f
peekany	$HARELIB/os/exec/+openbsd/process.ha	/^export fn peekany() ((process, status) | void | error) = {$/;"	f
peekiter	$HARELIB/path/iter.ha	/^export fn peekiter(it: *iterator) (str | void) = {$/;"	f
peeraddr	$HARELIB/net/tcp/+darwin.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
peeraddr	$HARELIB/net/tcp/+freebsd.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
peeraddr	$HARELIB/net/tcp/+linux.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
peeraddr	$HARELIB/net/tcp/+openbsd.ha	/^export fn peeraddr(peer: net::socket) ((ip::addr, u16) | void) = {$/;"	f
pemdecoder	$HARELIB/encoding/pem/pem.ha	/^export type pemdecoder = struct {$/;"	t
pemencoder	$HARELIB/encoding/pem/pem.ha	/^export type pemencoder = struct {$/;"	t
peq	$HARELIB/time/date/period.ha	/^export fn peq(pa: period, pb: period) bool = {$/;"	f
period	$HARELIB/time/date/period.ha	/^export type period = struct {$/;"	t
perm	$HARELIB/linux/keyctl/+linux/types.ha	/^export type perm = enum u32 {$/;"	t
phdr64	$HARELIB/format/elf/types.ha	/^export type phdr64 = struct {$/;"	t
pid	$HARELIB/unix/+darwin/creds.ha	/^export type pid = rt::pid_t;$/;"	t
pid	$HARELIB/unix/+freebsd/creds.ha	/^export type pid = rt::pid_t;$/;"	t
pid	$HARELIB/unix/+linux/creds.ha	/^export type pid = rt::pid_t;$/;"	t
pid	$HARELIB/unix/+openbsd/creds.ha	/^export type pid = rt::pid_t;$/;"	t
pid_t	$HARELIB/rt/+darwin/types.ha	/^export type pid_t       = uint;$/;"	t
pid_t	$HARELIB/rt/+freebsd/types.ha	/^export type pid_t = uint;$/;"	t
pid_t	$HARELIB/rt/+linux/types.ha	/^export type pid_t = int;$/;"	t
pid_t	$HARELIB/rt/+openbsd/types.ha	/^export type pid_t = i32;$/;"	t
pipe	$HARELIB/os/exec/+darwin/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
pipe	$HARELIB/os/exec/+freebsd/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
pipe	$HARELIB/os/exec/+linux/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
pipe	$HARELIB/os/exec/+openbsd/exec.ha	/^export fn pipe() (io::file, io::file) = {$/;"	f
pipe	$HARELIB/unix/+darwin/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
pipe	$HARELIB/unix/+freebsd/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
pipe	$HARELIB/unix/+linux/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
pipe	$HARELIB/unix/+openbsd/pipe.ha	/^export fn pipe(flags: pipe_flag...) ((io::file, io::file) | errors::error) = {$/;"	f
pipe2	$HARELIB/rt/+darwin/syscalls.ha	/^export fn pipe2(pipefd: *[2]int, flags: int) (void | errno) = {$/;"	f
pipe2	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn pipe2(pipefd: *[2]int, flags: int) (void | errno) = {$/;"	f
pipe2	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn pipe2(pipefd: *[2]int, flags: int) (void | errno) = {$/;"	f
pipe2	$HARELIB/rt/+linux/syscalls.ha	/^export fn pipe2(pipefd: *[2]int, flags: int) (void | errno) = {$/;"	f
pipe2	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn pipe2(pipefd: *[2]int, flags: int) (void | errno) = {$/;"	f
pipe_flag	$HARELIB/unix/+darwin/pipe.ha	/^export type pipe_flag = enum {$/;"	t
pipe_flag	$HARELIB/unix/+freebsd/pipe.ha	/^export type pipe_flag = enum {$/;"	t
pipe_flag	$HARELIB/unix/+linux/pipe.ha	/^export type pipe_flag = enum {$/;"	t
pipe_flag	$HARELIB/unix/+openbsd/pipe.ha	/^export type pipe_flag = enum {$/;"	t
pkcs1_hashalgo	$HARELIB/crypto/rsa/pkcs1.ha	/^export type pkcs1_hashalgo = enum {$/;"	t
pkcs1_sign	$HARELIB/crypto/rsa/pkcs1.ha	/^export fn pkcs1_sign($/;"	f
pkcs1_verify	$HARELIB/crypto/rsa/pkcs1.ha	/^export fn pkcs1_verify($/;"	f
pkey_params	$HARELIB/linux/keyctl/+linux/types.ha	/^export type pkey_params = struct {$/;"	t
pkey_query	$HARELIB/linux/keyctl/+linux/types.ha	/^export type pkey_query = struct {$/;"	t
pledge	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn pledge($/;"	f
pointer	$HARELIB/hare/types/types.ha	/^export type pointer = struct {$/;"	t
pointer_flag	$HARELIB/hare/ast/type.ha	/^export type pointer_flag = enum uint {$/;"	t
pointer_flag	$HARELIB/hare/types/types.ha	/^export type pointer_flag = enum u8 {$/;"	t
pointer_type	$HARELIB/hare/ast/type.ha	/^export type pointer_type = struct {$/;"	t
polarc128	$HARELIB/math/complex/complex.ha	/^export fn polarc128(z: c128) (f64, f64) = (absc128(z), argc128(z));$/;"	f
poll	$HARELIB/rt/+darwin/syscalls.ha	/^export fn poll(fds: *[*]pollfd, nfds: nfds_t, timeout: int) (int | errno) = {$/;"	f
poll	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn poll(fds: *[*]pollfd, nfds: nfds_t, timeout: int) (int | errno) = {$/;"	f
poll	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn poll(fds: *[*]pollfd, nfds: nfds_t, timeout: int) (int | errno) = {$/;"	f
poll	$HARELIB/rt/+linux/syscalls.ha	/^export fn poll(fds: *[*]pollfd, nfds: nfds_t, timeout: int) (int | errno) = {$/;"	f
poll	$HARELIB/unix/poll/+darwin.ha	/^export fn poll($/;"	f
poll	$HARELIB/unix/poll/+freebsd.ha	/^export fn poll($/;"	f
poll	$HARELIB/unix/poll/+linux.ha	/^export fn poll($/;"	f
poll	$HARELIB/unix/poll/+openbsd.ha	/^export fn poll($/;"	f
pollfd	$HARELIB/rt/+darwin/types.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/rt/+freebsd/types.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/rt/+linux/types.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/rt/+openbsd/types.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/unix/poll/+darwin.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/unix/poll/+freebsd.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/unix/poll/+linux.ha	/^export type pollfd = struct {$/;"	t
pollfd	$HARELIB/unix/poll/+openbsd.ha	/^export type pollfd = struct {$/;"	t
poly1305	$HARELIB/crypto/poly1305/poly1305.ha	/^export fn poly1305() state = {$/;"	f
pop	$HARELIB/path/stack.ha	/^export fn pop(buf: *buffer) (str | void) = {$/;"	f
pop_ext	$HARELIB/path/ext_stack.ha	/^export fn pop_ext(buf: *buffer) (str | void) = {$/;"	f
pop_exts	$HARELIB/path/ext_stack.ha	/^export fn pop_exts(buf: *buffer) (str | void) = {$/;"	f
popcount	$HARELIB/math/uints.ha	/^export fn popcount(x: u64) u8 = {$/;"	f
popprefix	$HARELIB/path/prefix.ha	/^export fn popprefix(buf: *buffer, prefix: str) (str | error) = {$/;"	f
portassignment	$HARELIB/net/tcp/options.ha	/^export type portassignment = *u16;$/;"	t
portassignment	$HARELIB/net/udp/options.ha	/^export type portassignment = *u16;$/;"	t
posix_fallocate	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn posix_fallocate(fd: int, off: i64, ln: i64) (void | errno) = {$/;"	f
posix_fallocate	$HARELIB/rt/+linux/syscalls.ha	/^export fn posix_fallocate(fd: int, off: i64, ln: i64) (void | errno) = {$/;"	f
posix_openpt	$HARELIB/rt/+darwin/syscalls.ha	/^export fn posix_openpt(flags: int) (int | errno) = {$/;"	f
posix_openpt	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn posix_openpt(flags: int) (int | errno) = {$/;"	f
posix_openpt	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn posix_openpt(flags: int) (int | errno) = {$/;"	f
posix_openpt	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn posix_openpt(flags: int) (int | errno) = {$/;"	f
powc128	$HARELIB/math/complex/complex.ha	/^export fn powc128(a: c128, b: c128) c128 = {$/;"	f
powf64	$HARELIB/math/math.ha	/^export fn powf64(x: f64, p: f64) f64 = {$/;"	f
ppoll	$HARELIB/rt/+darwin/syscalls.ha	/^\/\/ export fn ppoll($/;"	f
ppoll	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn ppoll($/;"	f
ppoll	$HARELIB/rt/+linux/syscalls.ha	/^export fn ppoll($/;"	f
ppoll	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn ppoll($/;"	f
prctl	$HARELIB/rt/+linux/syscalls.ha	/^export fn prctl($/;"	f
prctl_mm_map	$HARELIB/rt/+linux/prctl.ha	/^export type prctl_mm_map = struct {$/;"	t
prepend	$HARELIB/path/prefix.ha	/^export fn prepend(buf: *buffer, prefix: str...) (str | error) = {$/;"	f
prev	$HARELIB/encoding/utf8/decode.ha	/^export fn prev(d: *decoder) (rune | void | more | invalid) = {$/;"	f
prev	$HARELIB/strings/iter.ha	/^export fn prev(iter: *iterator) (rune | void) = move(iter.reverse, iter);$/;"	f
prevloc	$HARELIB/hare/lex/lex.ha	/^export fn prevloc(lex: *lexer) location = {$/;"	f
print	$HARELIB/fmt/wrappers.ha	/^export fn print(args: formattable...) (io::error | size) =$/;"	f
printf	$HARELIB/fmt/wrappers.ha	/^export fn printf(fmt: str, args: field...) (io::error | size) =$/;"	f
printfln	$HARELIB/fmt/wrappers.ha	/^export fn printfln(fmt: str, args: field...) (io::error | size) =$/;"	f
printfln	$HARELIB/log/funcs.ha	/^export fn printfln(fmt: str, fields: fmt::field...) void = {$/;"	f
printhelp	$HARELIB/getopt/getopts.ha	/^export fn printhelp($/;"	f
println	$HARELIB/fmt/wrappers.ha	/^export fn println(args: formattable...) (io::error | size) =$/;"	f
println	$HARELIB/log/funcs.ha	/^export fn println(fields: fmt::formattable...) void = {$/;"	f
printusage	$HARELIB/getopt/getopts.ha	/^export fn printusage($/;"	f
privkey	$HARELIB/crypto/ecdh/ecdh.ha	/^export type privkey = struct {$/;"	t
privkey	$HARELIB/crypto/ed25519/ed25519.ha	/^export type privkey = [PRIVKEYSZ]u8;$/;"	t
privkey_getpubkey	$HARELIB/crypto/ed25519/ed25519.ha	/^export fn privkey_getpubkey(priv: []u8) pubkey = {$/;"	f
privkey_init	$HARELIB/crypto/ed25519/ed25519.ha	/^export fn privkey_init(priv: []u8, seed: []u8) void = {$/;"	f
privkey_init	$HARELIB/crypto/rsa/keys.ha	/^export fn privkey_init(privkey: []u8, x: privparams, n: []u8...) (size | error) = {$/;"	f
privkey_initd	$HARELIB/crypto/rsa/keys.ha	/^export fn privkey_initd($/;"	f
privkey_nbitlen	$HARELIB/crypto/rsa/keys.ha	/^export fn privkey_nbitlen(privkey: []u8) size = {$/;"	f
privkey_nsize	$HARELIB/crypto/rsa/keys.ha	/^export fn privkey_nsize(privkey: []u8) size = {$/;"	f
privkey_params	$HARELIB/crypto/rsa/keys.ha	/^export fn privkey_params(privkey: []u8) privparams = {$/;"	f
privparams	$HARELIB/crypto/rsa/keys.ha	/^export type privparams = struct {$/;"	t
process	$HARELIB/os/exec/+darwin/process.ha	/^export type process = unix::pid;$/;"	t
process	$HARELIB/os/exec/+freebsd/process.ha	/^export type process = unix::pid;$/;"	t
process	$HARELIB/os/exec/+linux/process.ha	/^export type process = unix::pid;$/;"	t
process	$HARELIB/os/exec/+openbsd/process.ha	/^export type process = unix::pid;$/;"	t
projc128	$HARELIB/math/complex/complex.ha	/^export fn projc128(z: c128) c128 =$/;"	f
projc64	$HARELIB/math/complex/complex.ha	/^export fn projc64(z: c64) c64 =$/;"	f
propagate_expr	$HARELIB/hare/ast/expr.ha	/^export type propagate_expr = *expr;$/;"	t
prot	$HARELIB/io/+darwin/mmap.ha	/^export type prot = enum uint {$/;"	t
prot	$HARELIB/io/+freebsd/mmap.ha	/^export type prot = enum uint {$/;"	t
prot	$HARELIB/io/+linux/mmap.ha	/^export type prot = enum uint {$/;"	t
prot	$HARELIB/io/+openbsd/mmap.ha	/^export type prot = enum int {$/;"	t
ptmget	$HARELIB/rt/+openbsd/types.ha	/^export type ptmget = struct {$/;"	t
ptr	$HARELIB/net/dns/types.ha	/^export type ptr = struct {$/;"	t
ptrace	$HARELIB/rt/+linux/syscalls.ha	/^export fn ptrace($/;"	f
ptrace_peeksiginfo_args	$HARELIB/rt/+linux/types.ha	/^export type ptrace_peeksiginfo_args = struct {$/;"	t
ptrace_syscall_info	$HARELIB/rt/+linux/types.ha	/^export type ptrace_syscall_info = struct {$/;"	t
ptrdiff	$HARELIB/types/c/arch+aarch64.ha	/^export type ptrdiff = i64;$/;"	t
ptrdiff	$HARELIB/types/c/arch+riscv64.ha	/^export type ptrdiff = i64;$/;"	t
ptrdiff	$HARELIB/types/c/arch+x86_64.ha	/^export type ptrdiff = i64;$/;"	t
ptsname	$HARELIB/rt/+openbsd/libc.ha	/^export fn ptsname(flides: int) (*u8 | errno) = {$/;"	f
ptsname	$HARELIB/unix/tty/+darwin/pty.ha	/^export fn ptsname(master: io::file) (str | error) = {$/;"	f
ptsname	$HARELIB/unix/tty/+freebsd/pty.ha	/^export fn ptsname(master: io::file) (str | error) = {$/;"	f
ptsname	$HARELIB/unix/tty/+linux/pty.ha	/^export fn ptsname(master: io::file) (str | error) = {$/;"	f
ptsname	$HARELIB/unix/tty/+openbsd/pty.ha	/^export fn ptsname(master: io::file) (str | error) = {$/;"	f
ptsname_r	$HARELIB/rt/+darwin/syscalls.ha	/^export fn ptsname_r(fd: int, pathbuf: []u8) (void | errno) = {$/;"	f
ptsname_r	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn ptsname_r(fd: int, pathbuf: []u8) (void | errno) = {$/;"	f
pubkey	$HARELIB/crypto/ecdh/ecdh.ha	/^export fn pubkey(pub: []u8, priv: *privkey) size =$/;"	f
pubkey	$HARELIB/crypto/ed25519/ed25519.ha	/^export type pubkey = [PUBKEYSZ]u8;$/;"	t
pubkey	$HARELIB/crypto/x25519/x25519.ha	/^export fn pubkey(pub: []u8, priv: const []u8) void = {$/;"	f
pubkey_init	$HARELIB/crypto/rsa/keys.ha	/^export fn pubkey_init(pubkey: []u8, x: pubparams) (size | error) = {$/;"	f
pubkey_nbitlen	$HARELIB/crypto/rsa/keys.ha	/^export fn pubkey_nbitlen(pubkey: []u8) size = {$/;"	f
pubkey_params	$HARELIB/crypto/rsa/keys.ha	/^export fn pubkey_params(pubkey: []u8) pubparams = {$/;"	f
pubparams	$HARELIB/crypto/rsa/keys.ha	/^export type pubparams = struct {$/;"	t
push	$HARELIB/path/stack.ha	/^export fn push(buf: *buffer, items: str...) (str | error) = {$/;"	f
push_ext	$HARELIB/path/ext_stack.ha	/^export fn push_ext(buf: *buffer, ext: str...) (str | error) = {$/;"	f
pwent	$HARELIB/unix/passwd/passwd.ha	/^export type pwent = struct {$/;"	t
pwent_finish	$HARELIB/unix/passwd/passwd.ha	/^export fn pwent_finish(ent: *pwent) void = {$/;"	f
q_ext_state	$HARELIB/rt/+linux/+riscv64.ha	/^export type q_ext_state = struct {$/;"	t
qclass	$HARELIB/net/dns/types.ha	/^export type qclass = enum u16 {$/;"	t
qtype	$HARELIB/net/dns/types.ha	/^export type qtype = enum u16 {$/;"	t
query	$HARELIB/net/dns/query.ha	/^export fn query(query: *message, servers: ip::addr...) (*message | error) = {$/;"	f
query_decoder	$HARELIB/net/uri/query.ha	/^export type query_decoder = struct {$/;"	t
query_finish	$HARELIB/net/uri/query.ha	/^export fn query_finish(dec: *query_decoder) void = {$/;"	f
query_next	$HARELIB/net/uri/query.ha	/^export fn query_next(dec: *query_decoder) ((str, str) | invalid | void) = {$/;"	f
question	$HARELIB/net/dns/types.ha	/^export type question = struct {$/;"	t
quote	$HARELIB/shlex/escape.ha	/^export fn quote(sink: io::handle, s: str) (size | io::error) = {$/;"	f
quotestr	$HARELIB/shlex/escape.ha	/^export fn quotestr(s: str) str = {$/;"	f
r64_info	$HARELIB/format/elf/types.ha	/^export fn r64_info(sym: u64, stype: u64) u64 = sym << 32 | stype & 0xFFFFFFFF;$/;"	f
r64_sym	$HARELIB/format/elf/types.ha	/^export fn r64_sym(info: u64) u64 = info >> 32;$/;"	f
r64_type	$HARELIB/format/elf/types.ha	/^export fn r64_type(info: u64) u64 = info & 0xFFFFFFFF;$/;"	f
raiseexcept	$HARELIB/math/fenv_func.ha	/^export fn raiseexcept(ex: fexcept) void = rt::feraiseexcept(ex: uint);$/;"	f
random	$HARELIB/math/random/random.ha	/^export type random = u64;$/;"	t
rawreplace	$HARELIB/regex/regex.ha	/^export fn rawreplace(re: *regex, string: str, targetstr: str) str = {$/;"	f
rawreplacen	$HARELIB/regex/regex.ha	/^export fn rawreplacen(re: *regex, string: str, targetstr: str, n: size) str = {$/;"	f
rbisect	$HARELIB/sort/bisect.ha	/^export fn rbisect($/;"	f
rbyteindex	$HARELIB/strings/index.ha	/^export fn rbyteindex(haystack: str, needle: (str | rune)) (size | void) = {$/;"	f
rcode	$HARELIB/net/dns/types.ha	/^export type rcode = enum u8 {$/;"	t
rconcat	$HARELIB/memio/ops.ha	/^export fn rconcat(out: io::handle, strs: str...) (size | io::error) =$/;"	f
rcut	$HARELIB/bytes/tokenize.ha	/^export fn rcut(in: []u8, delim: ([]u8 | u8)) ([]u8, []u8) = {$/;"	f
rcut	$HARELIB/strings/tokenize.ha	/^export fn rcut(in: str, delim: str) (str, str) = {$/;"	f
rdata	$HARELIB/net/dns/types.ha	/^export type rdata = (a | aaaa | caa | cname | dnskey | mx | ns | nsec | opt$/;"	t
read	$HARELIB/crypto/keystore/impl+linux.ha	/^export fn read(key: key, buf: []u8) size = {$/;"	f
read	$HARELIB/crypto/keystore/impl.ha	/^export fn read(key: key, buf: []u8) size = {$/;"	f
read	$HARELIB/format/tar/reader.ha	/^export fn read(src: io::handle) reader = {$/;"	f
read	$HARELIB/io/handle.ha	/^export fn read(h: handle, buf: []u8) (size | EOF | error) = {$/;"	f
read	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn read(id: serial, buf: []u8) (size | error) = {$/;"	f
read	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export fn read($/;"	f
read	$HARELIB/rt/+darwin/syscalls.ha	/^export fn read(fd: int, buf: *opaque, count: size) (size | errno) = {$/;"	f
read	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn read(fd: int, buf: *opaque, count: size) (size | errno) = {$/;"	f
read	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn read(fd: int, buf: *opaque, count: size) (size | errno) = {$/;"	f
read	$HARELIB/rt/+linux/syscalls.ha	/^export fn read(fd: int, buf: *opaque, count: size) (size | errno) = {$/;"	f
read	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn read(fd: int, buf: *opaque, count: size) (size | errno) = {$/;"	f
read	$HARELIB/unix/signal/+linux.ha	/^export fn read(fd: io::file) (siginfo | errors::error) = {$/;"	f
read_bitstr	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_bitstr(d: *decoder, buf: []u8) (([]u8, u8) | error) = {$/;"	f
read_bool	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_bool(d: *decoder) (bool | error) = {$/;"	f
read_byte	$HARELIB/bufio/scanner.ha	/^export fn read_byte(file: io::handle) (u8 | io::EOF | io::error) = {$/;"	f
read_debug_info	$HARELIB/debug/dwarf/info.ha	/^export fn read_debug_info($/;"	f
read_gtime	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_gtime(d: *decoder) (date::date | error) = {$/;"	f
read_int	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_int(d: *decoder, buf: []u8) (size | error) = {$/;"	f
read_line	$HARELIB/bufio/scanner.ha	/^export fn read_line(file: io::handle) ([]u8 | io::EOF | io::error) =$/;"	f
read_null	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_null(d: *decoder) (void | error) = {$/;"	f
read_octetstr	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_octetstr(d: *decoder, buf: []u8) (size | error) = {$/;"	f
read_oid	$HARELIB/encoding/asn1/oid.ha	/^export fn read_oid(d: *decoder, db: *oiddb) (oid | error) = {$/;"	f
read_printstr	$HARELIB/encoding/asn1/strings.ha	/^export fn read_printstr(d: *decoder, buf: []u8) (size | error) = {$/;"	f
read_rawoid	$HARELIB/encoding/asn1/oid.ha	/^export fn read_rawoid(d: *decoder) ([]u8 | error) = {$/;"	f
read_rune	$HARELIB/bufio/scanner.ha	/^export fn read_rune($/;"	f
read_tok	$HARELIB/bufio/scanner.ha	/^export fn read_tok(file: io::handle, delim: u8...) ([]u8 | io::EOF | io::error) = {$/;"	f
read_u16	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_u16(d: *decoder) (u16 | error) = read_ux(d, 2)?: u16;$/;"	f
read_u32	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_u32(d: *decoder) (u32 | error) = read_ux(d, 4)?: u32;$/;"	f
read_u64	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_u64(d: *decoder) (u64 | error) = read_ux(d, 8)?;$/;"	f
read_u8	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_u8(d: *decoder) (u8 | error) = read_ux(d, 1)?: u8;$/;"	f
read_uint	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_uint(d: *decoder, buf: []u8) (size | error) = {$/;"	f
read_utctime	$HARELIB/encoding/asn1/decoder.ha	/^export fn read_utctime(d: *decoder, maxyear: u16) (date::date | error) = {$/;"	f
read_utf8str	$HARELIB/encoding/asn1/strings.ha	/^export fn read_utf8str(d: *decoder, buf: []u8) (str | error) = {$/;"	f
readall	$HARELIB/io/util.ha	/^export fn readall(in: handle, buf: []u8) (size | EOF | error) = {$/;"	f
readdir	$HARELIB/fs/util.ha	/^export fn readdir(fs: *fs, path: str) ([]dirent | error) = {$/;"	f
readdir	$HARELIB/os/os.ha	/^export fn readdir(path: str) ([]fs::dirent | fs::error) = fs::readdir(cwd, path);$/;"	f
reader	$HARELIB/format/tar/reader.ha	/^export type reader = struct {$/;"	t
reader	$HARELIB/io/types.ha	/^export type reader = fn(s: *stream, buf: []u8) (size | EOF | error);$/;"	t
readlink	$HARELIB/fs/fs.ha	/^export fn readlink(fs: *fs, path: str) (str | error) = {$/;"	f
readlink	$HARELIB/os/os.ha	/^export fn readlink(path: str) (str | fs::error) = fs::readlink(cwd, path);$/;"	f
readlinkat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn readlinkat($/;"	f
readlinkat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn readlinkat($/;"	f
readlinkat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn readlinkat($/;"	f
readlinkat	$HARELIB/rt/+linux/syscalls.ha	/^export fn readlinkat($/;"	f
readlinkat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn readlinkat($/;"	f
readlinkfunc	$HARELIB/fs/types.ha	/^export type readlinkfunc = fn(fs: *fs, path: str) (str | error);$/;"	t
readv	$HARELIB/io/+darwin/vector.ha	/^export fn readv(fd: file, vectors: vector...) (size | EOF | error) = {$/;"	f
readv	$HARELIB/io/+freebsd/vector.ha	/^export fn readv(fd: file, vectors: vector...) (size | EOF | error) = {$/;"	f
readv	$HARELIB/io/+linux/vector.ha	/^export fn readv(fd: file, vectors: vector...) (size | EOF | error) = {$/;"	f
readv	$HARELIB/io/+openbsd/vector.ha	/^export fn readv(fd: file, vectors: vector...) (size | EOF | error) = {$/;"	f
readv	$HARELIB/rt/+darwin/syscalls.ha	/^export fn readv(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
readv	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn readv(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
readv	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn readv(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
readv	$HARELIB/rt/+linux/syscalls.ha	/^export fn readv(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
readv	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn readv(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
realize	$HARELIB/time/date/virtual.ha	/^export fn realize($/;"	f
realloc	$HARELIB/rt/malloc+debug.ha	/^export fn realloc(user: nullable *opaque, n: size) nullable *opaque = {$/;"	f
realloc	$HARELIB/rt/malloc+libc.ha	/^export fn realloc(p: nullable *opaque, n: size) nullable *opaque = {$/;"	f
realloc	$HARELIB/rt/malloc.ha	/^export fn realloc(p: nullable *opaque, n: size) nullable *opaque = {$/;"	f
realpath	$HARELIB/fs/util.ha	/^export fn realpath(fs: *fs, path: str) (str | error) = {$/;"	f
realpath	$HARELIB/os/os.ha	/^export fn realpath(path: str) (str | fs::error) = fs::realpath(cwd, path);$/;"	f
reckon	$HARELIB/time/date/reckon.ha	/^export fn reckon(d: date, calc: calculus, ps: period...) date = {$/;"	f
rectc128	$HARELIB/math/complex/complex.ha	/^export fn rectc128(r: f64, theta: f64) c128 =$/;"	f
recv	$HARELIB/net/udp/+darwin.ha	/^export fn recv($/;"	f
recv	$HARELIB/net/udp/+freebsd.ha	/^export fn recv($/;"	f
recv	$HARELIB/net/udp/+linux.ha	/^export fn recv($/;"	f
recv	$HARELIB/net/udp/+openbsd.ha	/^export fn recv($/;"	f
recv	$HARELIB/rt/+darwin/syscalls.ha	/^export fn recv(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
recv	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn recv(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
recv	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn recv(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
recv	$HARELIB/rt/+linux/syscalls.ha	/^export fn recv(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
recvfiles	$HARELIB/net/unix/cmsg.ha	/^export fn recvfiles(buf: *net::msghdr, nfile: size) []io::file = {$/;"	f
recvfrom	$HARELIB/net/udp/+darwin.ha	/^export fn recvfrom($/;"	f
recvfrom	$HARELIB/net/udp/+freebsd.ha	/^export fn recvfrom($/;"	f
recvfrom	$HARELIB/net/udp/+linux.ha	/^export fn recvfrom($/;"	f
recvfrom	$HARELIB/net/udp/+openbsd.ha	/^export fn recvfrom($/;"	f
recvfrom	$HARELIB/rt/+darwin/syscalls.ha	/^export fn recvfrom(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
recvfrom	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn recvfrom(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
recvfrom	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn recvfrom(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
recvfrom	$HARELIB/rt/+linux/syscalls.ha	/^export fn recvfrom(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
recvfrom	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn recvfrom($/;"	f
recvmsg	$HARELIB/net/+darwin.ha	/^export fn recvmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
recvmsg	$HARELIB/net/+freebsd.ha	/^export fn recvmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
recvmsg	$HARELIB/net/+linux.ha	/^export fn recvmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
recvmsg	$HARELIB/net/+openbsd.ha	/^export fn recvmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
recvmsg	$HARELIB/rt/+darwin/syscalls.ha	/^export fn recvmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
recvmsg	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn recvmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
recvmsg	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn recvmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
recvmsg	$HARELIB/rt/+linux/syscalls.ha	/^export fn recvmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
recvmsg	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn recvmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
reduce	$HARELIB/crypto/bigint/arithm.ha	/^export fn reduce(x: []word, a: const []word, m: const []word) void = {$/;"	f
refused	$HARELIB/errors/common.ha	/^export type refused = !void;$/;"	t
refused	$HARELIB/net/dns/error.ha	/^export type refused = !void;$/;"	t
regex	$HARELIB/regex/regex.ha	/^export type regex = struct {$/;"	t
register	$HARELIB/mime/database.ha	/^export fn register(mime: *mimetype...) void = {$/;"	f
registerproto	$HARELIB/net/dial/registry.ha	/^export fn registerproto(name: str, dial: *dialer) void = {$/;"	f
registersvc	$HARELIB/net/dial/registry.ha	/^export fn registersvc($/;"	f
rel64	$HARELIB/format/elf/types.ha	/^export type rel64 = struct {$/;"	t
rela64	$HARELIB/format/elf/types.ha	/^export type rela64 = struct {$/;"	t
release	$HARELIB/os/+darwin/platform_environ.ha	/^export fn release() const str = {$/;"	f
release	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn release() const str = {$/;"	f
release	$HARELIB/os/+linux/platform_environ.ha	/^export fn release() const str = {$/;"	f
remaining_tokens	$HARELIB/bytes/tokenize.ha	/^export fn remaining_tokens(s: *tokenizer) []u8 = {$/;"	f
remaining_tokens	$HARELIB/strings/tokenize.ha	/^export fn remaining_tokens(s: *tokenizer) str = {$/;"	f
remove	$HARELIB/fs/fs.ha	/^export fn remove(fs: *fs, path: str) (void | error) = {$/;"	f
remove	$HARELIB/os/os.ha	/^export fn remove(path: str) (void | fs::error) = fs::remove(cwd, path);$/;"	f
removefunc	$HARELIB/fs/types.ha	/^export type removefunc = fn(fs: *fs, path: str) (void | error);$/;"	t
remu	$HARELIB/math/uints.ha	/^export fn remu(hi: uint, lo: uint, y: uint) uint = {$/;"	f
remu32	$HARELIB/math/uints.ha	/^export fn remu32(hi: u32, lo: u32, y: u32) u32 = {$/;"	f
remu64	$HARELIB/math/uints.ha	/^export fn remu64(hi: u64, lo: u64, y: u64) u64 = {$/;"	f
rename	$HARELIB/fs/fs.ha	/^export fn rename(fs: *fs, oldpath: str, newpath: str) (void | error) = {$/;"	f
rename	$HARELIB/os/os.ha	/^export fn rename(oldpath: str, newpath: str) (void | fs::error) =$/;"	f
renameat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn renameat($/;"	f
renameat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn renameat($/;"	f
renameat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn renameat($/;"	f
renameat	$HARELIB/rt/+linux/syscalls.ha	/^export fn renameat($/;"	f
renameat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn renameat($/;"	f
renamefunc	$HARELIB/fs/types.ha	/^export type renamefunc = fn(fs: *fs, oldpath: str, newpath: str) (void | error);$/;"	t
replace	$HARELIB/regex/regex.ha	/^export fn replace(re: *regex, string: str, targetstr: str) (str | error) = {$/;"	f
replace	$HARELIB/strings/replace.ha	/^export fn replace(s: str, needle: str, target: str) str = {$/;"	f
replacen	$HARELIB/regex/regex.ha	/^export fn replacen($/;"	f
reqkey	$HARELIB/linux/keyctl/+linux/types.ha	/^export type reqkey = enum int {$/;"	t
require	$HARELIB/test/util+test.ha	/^export fn require(keywords: str...) void = {$/;"	f
require	$HARELIB/test/util.ha	/^export fn require(keyword: str) void = {$/;"	f
requires_arg	$HARELIB/getopt/getopts.ha	/^export type requires_arg = rune;$/;"	t
reset	$HARELIB/hash/hash.ha	/^export fn reset(h: *hash) void = match (h.reset) {$/;"	f
reset	$HARELIB/memio/stream.ha	/^export fn reset(in: *stream) void = {$/;"	f
reset	$HARELIB/net/msg.ha	/^export fn reset(msg: *msghdr) void = {$/;"	f
reset	$HARELIB/unix/signal/+darwin.ha	/^export fn reset(signum: sig) void = {$/;"	f
reset	$HARELIB/unix/signal/+freebsd.ha	/^export fn reset(signum: sig) void = {$/;"	f
reset	$HARELIB/unix/signal/+linux.ha	/^export fn reset(signum: sig) void = {$/;"	f
reset	$HARELIB/unix/signal/+openbsd.ha	/^export fn reset(signum: sig) void = {$/;"	f
resetall	$HARELIB/unix/signal/+darwin.ha	/^export fn resetall() void = {$/;"	f
resetall	$HARELIB/unix/signal/+freebsd.ha	/^export fn resetall() void = {$/;"	f
resetall	$HARELIB/unix/signal/+linux.ha	/^export fn resetall() void = {$/;"	f
resetall	$HARELIB/unix/signal/+openbsd.ha	/^export fn resetall() void = {$/;"	f
resolve	$HARELIB/fs/fs.ha	/^export fn resolve(fs: *fs, path: str) str = {$/;"	f
resolve	$HARELIB/net/dial/resolve.ha	/^export fn resolve($/;"	f
resolve	$HARELIB/os/os.ha	/^export fn resolve(path: str) str = fs::resolve(cwd, path);$/;"	f
resolve_flag	$HARELIB/os/+linux/dirfdfs.ha	/^export type resolve_flag = enum {$/;"	t
resolvefunc	$HARELIB/fs/types.ha	/^export type resolvefunc = fn(fs: *fs, path: str) str;$/;"	t
resolver	$HARELIB/hare/types/store.ha	/^export type resolver = fn($/;"	t
restore	$HARELIB/unix/signal/+darwin.ha	/^export fn restore(signum: sig, action: *sigaction) void = {$/;"	f
restore	$HARELIB/unix/signal/+freebsd.ha	/^export fn restore(signum: sig, action: *sigaction) void = {$/;"	f
restore	$HARELIB/unix/signal/+linux.ha	/^export fn restore(signum: sig, action: *sigaction) void = {$/;"	f
restore	$HARELIB/unix/signal/+openbsd.ha	/^export fn restore(signum: sig, action: *sigaction) void = {$/;"	f
result	$HARELIB/regex/regex.ha	/^export type result = []capture;$/;"	t
result_free	$HARELIB/regex/regex.ha	/^export fn result_free(s: result) void = {$/;"	f
result_freeall	$HARELIB/regex/regex.ha	/^export fn result_freeall(s: []result) void = {$/;"	f
return_expr	$HARELIB/hare/ast/expr.ha	/^export type return_expr = nullable *expr;$/;"	t
reuseaddr	$HARELIB/net/tcp/options.ha	/^export type reuseaddr = void;$/;"	t
reuseaddr	$HARELIB/net/udp/options.ha	/^export type reuseaddr = void;$/;"	t
reuseport	$HARELIB/net/tcp/options.ha	/^export type reuseport = void;$/;"	t
reuseport	$HARELIB/net/udp/options.ha	/^export type reuseport = void;$/;"	t
reverse	$HARELIB/bytes/reverse.ha	/^export fn reverse(b: []u8) void = {$/;"	f
revoke	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn revoke(id: serial) (void | error) = {$/;"	f
rindex	$HARELIB/bytes/index.ha	/^export fn rindex(haystack: []u8, needle: (u8 | []u8)) (size | void) = {$/;"	f
rindex	$HARELIB/strings/index.ha	/^export fn rindex(haystack: str, needle: (str | rune)) (size | void) = {$/;"	f
riter	$HARELIB/path/iter.ha	/^export fn riter(buf: *buffer) iterator = iterator {$/;"	f
riter	$HARELIB/strings/iter.ha	/^export fn riter(src: str) iterator = {$/;"	f
rjoin	$HARELIB/memio/ops.ha	/^export fn rjoin(out: io::handle, delim: str, strs: str...) (size | io::error) = {$/;"	f
rlim_t	$HARELIB/rt/+darwin/types.ha	/^export type rlim_t      = u64;$/;"	t
rlim_t	$HARELIB/rt/+freebsd/types.ha	/^export type rlim_t = u64;$/;"	t
rlim_t	$HARELIB/rt/+linux/types.ha	/^export type rlim_t = u64;$/;"	t
rlimit	$HARELIB/rt/+darwin/types.ha	/^export type rlimit = struct {$/;"	t
rlimit	$HARELIB/rt/+freebsd/types.ha	/^export type rlimit = struct {$/;"	t
rlimit	$HARELIB/rt/+linux/types.ha	/^export type rlimit = struct {$/;"	t
rmdir	$HARELIB/fs/fs.ha	/^export fn rmdir(fs: *fs, path: str) (void | error) = {$/;"	f
rmdir	$HARELIB/os/os.ha	/^export fn rmdir(path: str) (void | fs::error) = fs::rmdir(cwd, path);$/;"	f
rmdirall	$HARELIB/fs/util.ha	/^export fn rmdirall(fs: *fs, path: str) (void | error) = {$/;"	f
rmdirall	$HARELIB/os/os.ha	/^export fn rmdirall(path: str) (void | fs::error) = fs::rmdirall(cwd, path);$/;"	f
rmdirfunc	$HARELIB/fs/types.ha	/^export type rmdirfunc = fn(fs: *fs, path: str) (void | error);$/;"	t
rotl32	$HARELIB/crypto/math/bits.ha	/^export fn rotl32(x: u32, k: int) u32 = {$/;"	f
rotl64	$HARELIB/crypto/math/bits.ha	/^export fn rotl64(x: u64, k: int) u64 = {$/;"	f
rotr32	$HARELIB/crypto/math/bits.ha	/^export fn rotr32(x: u32, k: int) u32 = rotl32(x, -k);$/;"	f
rotr64	$HARELIB/crypto/math/bits.ha	/^export fn rotr64(x: u64, k: int) u64 = rotl64(x, -k);$/;"	f
roundf64	$HARELIB/math/math.ha	/^export fn roundf64(x: f64) f64 = {$/;"	f
rpad	$HARELIB/strings/pad.ha	/^export fn rpad(s: str, p: rune, maxlen: size) str = {$/;"	f
rrecord	$HARELIB/net/dns/types.ha	/^export type rrecord = struct {$/;"	t
rrset_error	$HARELIB/net/dns/error.ha	/^export type rrset_error = !void;$/;"	t
rrset_exists	$HARELIB/net/dns/error.ha	/^export type rrset_exists = !void;$/;"	t
rrsig	$HARELIB/net/dns/types.ha	/^export type rrsig = struct {$/;"	t
rshift	$HARELIB/crypto/bigint/arithm.ha	/^export fn rshift(x: []word, count: word) void = {$/;"	f
rsplitn	$HARELIB/strings/tokenize.ha	/^export fn rsplitn(in: str, delim: str, n: size) []str = {$/;"	f
rtokenize	$HARELIB/bytes/tokenize.ha	/^export fn rtokenize(s: []u8, delim: []u8) tokenizer = {$/;"	f
rtokenize	$HARELIB/strings/tokenize.ha	/^export fn rtokenize(s: str, delim: str) tokenizer =$/;"	f
rtrim	$HARELIB/bytes/trim.ha	/^export fn rtrim(in: []u8, trim: u8...) []u8 = {$/;"	f
rtrim	$HARELIB/strings/trim.ha	/^export fn rtrim(input: str, trim: rune...) str = {$/;"	f
rtype	$HARELIB/net/dns/types.ha	/^export type rtype = enum u16 {$/;"	t
runesz	$HARELIB/encoding/utf8/rune.ha	/^export fn runesz(r: rune) size = {$/;"	f
runtime	$HARELIB/dirs/xdg.ha	/^export fn runtime() (str | fs::error) = {$/;"	f
rusage	$HARELIB/rt/+darwin/types.ha	/^export type rusage = struct {$/;"	t
rusage	$HARELIB/rt/+freebsd/types.ha	/^export type rusage = struct {$/;"	t
rusage	$HARELIB/rt/+linux/types.ha	/^export type rusage = struct {$/;"	t
rusage	$HARELIB/rt/+openbsd/types.ha	/^export type rusage = struct {$/;"	t
sa_family_t	$HARELIB/rt/+darwin/socket.ha	/^export type sa_family_t = u8;$/;"	t
sa_family_t	$HARELIB/rt/+freebsd/socket.ha	/^export type sa_family_t = u8;$/;"	t
sa_family_t	$HARELIB/rt/+linux/socket.ha	/^export type sa_family_t = u16;$/;"	t
sa_family_t	$HARELIB/rt/+openbsd/socket.ha	/^export type sa_family_t = u8;$/;"	t
salsa20	$HARELIB/crypto/salsa/salsa20.ha	/^export fn salsa20() stream = {$/;"	f
salsa20_init	$HARELIB/crypto/salsa/salsa20.ha	/^export fn salsa20_init($/;"	f
scalarmult	$HARELIB/crypto/curve25519/curve25519.ha	/^export fn scalarmult($/;"	f
scalarmult_base	$HARELIB/crypto/curve25519/curve25519.ha	/^export fn scalarmult_base($/;"	f
scan	$HARELIB/format/ini/scan.ha	/^export fn scan(in: io::handle) scanner = scanner {$/;"	f
scan_buffer	$HARELIB/bufio/scanner.ha	/^export fn scan_buffer(scan: *scanner) []u8 = {$/;"	f
scan_byte	$HARELIB/bufio/scanner.ha	/^export fn scan_byte(scan: *scanner) (u8 | io::EOF | io::error) = {$/;"	f
scan_bytes	$HARELIB/bufio/scanner.ha	/^export fn scan_bytes($/;"	f
scan_line	$HARELIB/bufio/scanner.ha	/^export fn scan_line($/;"	f
scan_rune	$HARELIB/bufio/scanner.ha	/^export fn scan_rune($/;"	f
scan_string	$HARELIB/bufio/scanner.ha	/^export fn scan_string($/;"	f
scanner	$HARELIB/bufio/scanner.ha	/^export type scanner = struct {$/;"	t
scanner	$HARELIB/format/ini/scan.ha	/^export type scanner = struct {$/;"	t
scanner	$HARELIB/hare/lex/lex.ha	/^export fn init(in: *bufio::scanner, path: str, flags: flag...) lexer = {$/;"	f
schar	$HARELIB/types/c/types.ha	/^export type schar = i8;$/;"	t
sched_getaffinity	$HARELIB/rt/+linux/syscalls.ha	/^export fn sched_getaffinity($/;"	f
sched_setaffinity	$HARELIB/rt/+linux/syscalls.ha	/^export fn sched_setaffinity($/;"	f
scope	$HARELIB/hare/unit/scope.ha	/^export type scope = struct {$/;"	t
scope_class	$HARELIB/hare/unit/scope.ha	/^export type scope_class = enum {$/;"	t
seal	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn seal(s: *stream, tag: []u8) void = writemac(s, tag);$/;"	f
search	$HARELIB/sort/search.ha	/^export fn search($/;"	f
second	$HARELIB/time/date/observe.ha	/^export fn second(d: *date) int = _second(d);$/;"	f
section64	$HARELIB/debug/image/sections.ha	/^export fn section_data(image: *image, sec: *elf::section64) []u8 = {$/;"	f
section64	$HARELIB/format/elf/types.ha	/^export type section64 = struct {$/;"	t
section_byname	$HARELIB/debug/image/sections.ha	/^export fn section_byname($/;"	f
section_data	$HARELIB/debug/image/sections.ha	/^export fn section_data(image: *image, sec: *elf::section64) []u8 = {$/;"	f
section_name	$HARELIB/debug/image/sections.ha	/^export fn section_name($/;"	f
section_reader	$HARELIB/debug/image/sections.ha	/^export fn section_reader(image: *image, sec: *elf::section64) memio::stream = {$/;"	f
seed	$HARELIB/crypto/ed25519/ed25519.ha	/^export type seed = [SEEDSZ]u8;$/;"	t
seek	$HARELIB/io/handle.ha	/^export fn seek(h: handle, off: off, w: whence) (off | error) = {$/;"	f
seeker	$HARELIB/io/types.ha	/^export type seeker = fn(s: *stream, off: off, w: whence) (off | error);$/;"	t
self	$HARELIB/debug/image/self+darwin.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
self	$HARELIB/debug/image/self+freebsd.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
self	$HARELIB/debug/image/self+linux.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
self	$HARELIB/debug/image/self+openbsd.ha	/^export fn self() (image | io::error | fs::error) = {$/;"	f
self	$HARELIB/os/exec/+darwin/process.ha	/^export fn self() process = {$/;"	f
self	$HARELIB/os/exec/+freebsd/process.ha	/^export fn self() process = {$/;"	f
self	$HARELIB/os/exec/+linux/process.ha	/^export fn self() process = {$/;"	f
self	$HARELIB/os/exec/+openbsd/process.ha	/^export fn self() process = {$/;"	f
send	$HARELIB/net/udp/+darwin.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
send	$HARELIB/net/udp/+freebsd.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
send	$HARELIB/net/udp/+linux.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
send	$HARELIB/net/udp/+openbsd.ha	/^export fn send(sock: net::socket, buf: []u8) (size | net::error) = {$/;"	f
send	$HARELIB/rt/+darwin/syscalls.ha	/^export fn send(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
send	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn send(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
send	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn send(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
send	$HARELIB/rt/+linux/syscalls.ha	/^export fn send(sockfd: int, buf: *opaque, len_: size, flags: int) (size | errno) = {$/;"	f
sendfile	$HARELIB/rt/+linux/syscalls.ha	/^export fn sendfile($/;"	f
sendmsg	$HARELIB/net/+darwin.ha	/^export fn sendmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
sendmsg	$HARELIB/net/+freebsd.ha	/^export fn sendmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
sendmsg	$HARELIB/net/+linux.ha	/^export fn sendmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
sendmsg	$HARELIB/net/+openbsd.ha	/^export fn sendmsg(sock: socket, msg: *msghdr) (size | error) = {$/;"	f
sendmsg	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sendmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
sendmsg	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn sendmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
sendmsg	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sendmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
sendmsg	$HARELIB/rt/+linux/syscalls.ha	/^export fn sendmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
sendmsg	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sendmsg(fd: int, msg: *const msghdr, flags: int) (int | errno) = {$/;"	f
sendto	$HARELIB/net/udp/+darwin.ha	/^export fn sendto($/;"	f
sendto	$HARELIB/net/udp/+freebsd.ha	/^export fn sendto($/;"	f
sendto	$HARELIB/net/udp/+linux.ha	/^export fn sendto($/;"	f
sendto	$HARELIB/net/udp/+openbsd.ha	/^export fn sendto($/;"	f
sendto	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sendto(sockfd: int, buf: *const opaque, len_: size, flags: int,$/;"	f
sendto	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn sendto(sockfd: int, buf: *const opaque, len_: size, flags: int,$/;"	f
sendto	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sendto(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
sendto	$HARELIB/rt/+linux/syscalls.ha	/^export fn sendto(sockfd: int, buf: *opaque, len_: size, flags: int,$/;"	f
sendto	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sendto($/;"	f
serial	$HARELIB/linux/keyctl/+linux/types.ha	/^export type serial = i32;$/;"	t
server_failure	$HARELIB/net/dns/error.ha	/^export type server_failure = !void;$/;"	t
sessionkey	$HARELIB/crypto/authenc.ha	/^export type sessionkey = [32]u8;$/;"	t
set	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export fn set($/;"	f
set	$HARELIB/path/buffer.ha	/^export fn set(buf: *buffer, items: str...) (str | error) = {$/;"	f
set_flag	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export type set_flag = enum int {$/;"	t
set_winsize	$HARELIB/unix/tty/+darwin/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
set_winsize	$HARELIB/unix/tty/+freebsd/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
set_winsize	$HARELIB/unix/tty/+linux/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
set_winsize	$HARELIB/unix/tty/+openbsd/pty.ha	/^export fn set_winsize(pty: io::file, sz: ttysize) (void | error) = {$/;"	f
setctr	$HARELIB/crypto/chacha/chacha20.ha	/^export fn setctr(s: *stream, counter: u32) void = {$/;"	f
setctr	$HARELIB/crypto/salsa/salsa20.ha	/^export fn setctr(s: *stream, counter: u64) void = {$/;"	f
setegid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setegid(gid: gid_t) (void | errno) = {$/;"	f
setegid	$HARELIB/unix/+darwin/creds.ha	/^export fn setegid(gid: gid) void = rt::setregid(-1i: uint, gid)!;$/;"	f
setegid	$HARELIB/unix/+freebsd/creds.ha	/^export fn setegid(gid: gid) void = rt::setresgid(-1i: uint, gid, -1i: uint)!;$/;"	f
setegid	$HARELIB/unix/+linux/creds.ha	/^export fn setegid(gid: gid) void = rt::setresgid(-1i: uint, gid, -1i: uint)!;$/;"	f
setegid	$HARELIB/unix/+openbsd/creds.ha	/^export fn setegid(gid: gid) void = rt::setegid(gid)!;$/;"	f
setenv	$HARELIB/os/environ.ha	/^export fn setenv(name: const str, value: const str) (void | errors::invalid) = {$/;"	f
setenv	$HARELIB/os/exec/cmd.ha	/^export fn setenv(cmd: *command, key: str, value: str) (void | errors::invalid) = {$/;"	f
seteuid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn seteuid(uid: uid_t) (void | errno) = {$/;"	f
seteuid	$HARELIB/unix/+darwin/creds.ha	/^export fn seteuid(uid: uid) void = rt::setreuid(-1i: uint, uid)!;$/;"	f
seteuid	$HARELIB/unix/+freebsd/creds.ha	/^export fn seteuid(uid: uid) void = rt::setresuid(-1i: uint, uid, -1i: uint)!;$/;"	f
seteuid	$HARELIB/unix/+linux/creds.ha	/^export fn seteuid(uid: uid) void = rt::setresuid(-1i: uint, uid, -1i: uint)!;$/;"	f
seteuid	$HARELIB/unix/+openbsd/creds.ha	/^export fn seteuid(uid: uid) void = rt::seteuid(uid)!;$/;"	f
setflags	$HARELIB/net/msg.ha	/^export fn setflags(msg: *msghdr, flags: int) void = {$/;"	f
setflush	$HARELIB/bufio/stream.ha	/^export fn setflush(s: io::handle, b: []u8) void = {$/;"	f
setgid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setgid(gid: gid_t) (void | errno) = {$/;"	f
setgid	$HARELIB/unix/+darwin/creds.ha	/^export fn setgid(gid: gid) void = rt::setregid(gid, -1i: uint)!;$/;"	f
setgid	$HARELIB/unix/+freebsd/creds.ha	/^export fn setgid(gid: gid) void = rt::setresgid(gid, -1i: uint, -1i: uint)!;$/;"	f
setgid	$HARELIB/unix/+linux/creds.ha	/^export fn setgid(gid: gid) void = rt::setresgid(gid, -1i: uint, -1i: uint)!;$/;"	f
setgid	$HARELIB/unix/+openbsd/creds.ha	/^export fn setgid(gid: gid) void = rt::setgid(gid)!;$/;"	f
setgroups	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setgroups(gids: []gid_t) (void | errno) = {$/;"	f
setgroups	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn setgroups(gids: []uint) (void | errno) = {$/;"	f
setgroups	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setgroups(gids: []gid_t) (void | errno) = {$/;"	f
setgroups	$HARELIB/rt/+linux/syscalls.ha	/^export fn setgroups(gids: []gid_t) (void | errno) = {$/;"	f
setgroups	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setgroups(gids: []gid_t) (void | errno) = {$/;"	f
setgroups	$HARELIB/unix/+darwin/creds.ha	/^export fn setgroups(gids: []gid) void = rt::setgroups(gids: []rt::gid_t)!;$/;"	f
setgroups	$HARELIB/unix/+freebsd/creds.ha	/^export fn setgroups(gids: []gid) void = rt::setgroups(gids: []rt::gid_t)!;$/;"	f
setgroups	$HARELIB/unix/+linux/creds.ha	/^export fn setgroups(gids: []gid) void = rt::setgroups(gids: []rt::gid_t)!;$/;"	f
setgroups	$HARELIB/unix/+openbsd/creds.ha	/^export fn setgroups(gids: []gid) void = rt::setgroups(gids: []rt::gid_t)!;$/;"	f
setjmp	$HARELIB/rt/jmp.ha	/^export fn setjmp(buf: *jmpbuf) int;$/;"	f
setlogger	$HARELIB/log/global.ha	/^export fn setlogger(log: *logger) void = {$/;"	f
setname	$HARELIB/net/msg.ha	/^export fn setname(msg: *msghdr, name: *opaque, length: size) void = {$/;"	f
setname	$HARELIB/os/exec/cmd.ha	/^export fn setname(cmd: *command, name: str) void = {$/;"	f
setperm	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn setperm(id: serial, perm: perm) (void | error) = {$/;"	f
setpgid	$HARELIB/rt/+linux/syscalls.ha	/^export fn setpgid(pid: pid_t, pgid: pid_t) (void | errno) = {$/;"	f
setpgid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setpgid(pid: pid_t, pgrp: pid_t) (void | errno) = {$/;"	f
setpgid	$HARELIB/unix/+linux/creds.ha	/^export fn setpgid(targ: pid, pgid: pid) (void | errors::error) = {$/;"	f
setpgid	$HARELIB/unix/+openbsd/creds.ha	/^export fn setpgid(targ: pid, pgid: pid) (void | errors::error) = {$/;"	f
setpriority	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setpriority(which: int, who: id_t, prio: int) (void | errno) = {$/;"	f
setpriority	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn setpriority(which: int, who: id_t, prio: int) (void | errno) = {$/;"	f
setpriority	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setpriority(which: int, who: id_t, prio: int) (void | errno) = {$/;"	f
setpriority	$HARELIB/rt/+linux/syscalls.ha	/^export fn setpriority(which: int, who: id_t, prio: int) (void | errno) = {$/;"	f
setpriority	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setpriority(which: int, who: id_t, prio: int) (void | errno) = {$/;"	f
setprocmask	$HARELIB/unix/signal/+darwin.ha	/^export fn setprocmask(how: how, mask: *sigset) sigset = {$/;"	f
setprocmask	$HARELIB/unix/signal/+freebsd.ha	/^export fn setprocmask(how: how, mask: *sigset) sigset = {$/;"	f
setprocmask	$HARELIB/unix/signal/+linux.ha	/^export fn setprocmask(how: how, mask: *sigset) sigset = {$/;"	f
setprocmask	$HARELIB/unix/signal/+openbsd.ha	/^export fn setprocmask(how: how, mask: *sigset) sigset = {$/;"	f
setregid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setregid(gid: gid_t, egid: gid_t) (void | errno) = {$/;"	f
setregid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn setregid(gid: gid_t, egid: gid_t) (void | errno) = {$/;"	f
setresgid	$HARELIB/rt/+darwin/syscalls.ha	/^\/\/ export fn setresgid(gid: gid_t, egid: gid_t, sgid: gid_t) (void | errno) = {$/;"	f
setresgid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^\/\/ export fn setresgid(gid: gid_t, egid: gid_t, sgid: gid_t) (void | errno) = {$/;"	f
setresgid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setresgid(gid: gid_t, egid: gid_t, sgid: gid_t) (void | errno) = {$/;"	f
setresgid	$HARELIB/rt/+linux/syscalls.ha	/^export fn setresgid(gid: gid_t, egid: gid_t, sgid: gid_t) (void | errno) = {$/;"	f
setresuid	$HARELIB/rt/+darwin/syscalls.ha	/^\/\/ export fn setresuid(uid: uid_t, euid: uid_t, suid: uid_t) (void | errno) = {$/;"	f
setresuid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^\/\/ export fn setresuid(uid: uid_t, euid: uid_t, suid: uid_t) (void | errno) = {$/;"	f
setresuid	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setresuid(uid: uid_t, euid: uid_t, suid: uid_t) (void | errno) = {$/;"	f
setresuid	$HARELIB/rt/+linux/syscalls.ha	/^export fn setresuid(uid: uid_t, euid: uid_t, suid: uid_t) (void | errno) = {$/;"	f
setreuid	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setreuid(uid: uid_t, euid: uid_t) (void | errno) = {$/;"	f
setreuid	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn setreuid(uid: uid_t, euid: uid_t) (void | errno) = {$/;"	f
setrlimit	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setrlimit(resource: int, rlim: *const rlimit) (void | errno) = {$/;"	f
setrlimit	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setrlimit(resource: int, rlim: *const rlimit) (void | errno) = {$/;"	f
setrlimit	$HARELIB/rt/+linux/syscalls.ha	/^export fn setrlimit(resource: int, rlim: *const rlimit) (void | errno) = {$/;"	f
setround	$HARELIB/math/fenv_func.ha	/^export fn setround(mode: fround) void = rt::fesetround(mode: uint);$/;"	f
setsid	$HARELIB/rt/+linux/syscalls.ha	/^export fn setsid() (void | errno) = {$/;"	f
setsid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setsid() (void | errno) = {$/;"	f
setsid	$HARELIB/unix/+linux/creds.ha	/^export fn setsid() void = rt::setsid()!;$/;"	f
setsid	$HARELIB/unix/+openbsd/creds.ha	/^export fn setsid() void = rt::setsid()!;$/;"	f
setsockopt	$HARELIB/rt/+darwin/syscalls.ha	/^export fn setsockopt(sockfd: int, level: int, optname: int, optval: *opaque, optlen: u32) (void /;"	f
setsockopt	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn setsockopt(sockfd: int, level: int, optname: int, optval: *opaque, optlen: u32) (void /;"	f
setsockopt	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn setsockopt(sockfd: int, level: int, optname: int, optval: *opaque, optlen: u32) (int |/;"	f
setsockopt	$HARELIB/rt/+linux/syscalls.ha	/^export fn setsockopt(sockfd: int, level: int, optname: int, optval: *opaque, optlen: u32) (int |/;"	f
setsockopt	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setsockopt($/;"	f
setuid	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn setuid(uid: uid_t) (void | errno) = {$/;"	f
setuid	$HARELIB/unix/+darwin/creds.ha	/^export fn setuid(uid: uid) void = rt::setreuid(uid, -1i: uint)!;$/;"	f
setuid	$HARELIB/unix/+freebsd/creds.ha	/^export fn setuid(uid: uid) void = rt::setresuid(uid, -1i: uint, -1i: uint)!;$/;"	f
setuid	$HARELIB/unix/+linux/creds.ha	/^export fn setuid(uid: uid) void = rt::setresuid(uid, -1i: uint, -1i: uint)!;$/;"	f
setuid	$HARELIB/unix/+openbsd/creds.ha	/^export fn setuid(uid: uid) void = rt::setuid(uid)!;$/;"	f
sh_error	$HARELIB/wordexp/error.ha	/^export type sh_error = !void;$/;"	t
sha1	$HARELIB/crypto/hmac/sha1.ha	/^export fn sha1(key: []u8) sha1state = {$/;"	f
sha1	$HARELIB/crypto/sha1/sha1.ha	/^export fn sha1() state = {$/;"	f
sha1state	$HARELIB/crypto/hmac/sha1.ha	/^export type sha1state = struct {$/;"	t
sha256	$HARELIB/crypto/hmac/sha256.ha	/^export fn sha256(key: []u8) sha256state = {$/;"	f
sha256	$HARELIB/crypto/sha256/sha256.ha	/^export fn sha256() state = {$/;"	f
sha256state	$HARELIB/crypto/hmac/sha256.ha	/^export type sha256state = struct {$/;"	t
sha384	$HARELIB/crypto/sha512/sha512.ha	/^export fn sha384() digest = init(variant::SHA384, SZ384);$/;"	f
sha512	$HARELIB/crypto/sha512/sha512.ha	/^export fn sha512() digest = init(variant::SHA512, SZ);$/;"	f
sha512_224	$HARELIB/crypto/sha512/sha512.ha	/^export fn sha512_224() digest = init(variant::SHA512_224, SZ224);$/;"	f
sha512_256	$HARELIB/crypto/sha512/sha512.ha	/^export fn sha512_256() digest = init(variant::SHA512_256, SZ256);$/;"	f
shf	$HARELIB/format/elf/types.ha	/^export type shf = enum u32 {$/;"	t
shmat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn shmat(id: int, addr: *const opaque, flag: int) *opaque = {$/;"	f
shmat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn shmat(id: int, addr: *const opaque, flag: int) *opaque = {$/;"	f
shmat	$HARELIB/rt/+linux/syscalls.ha	/^export fn shmat(id: int, addr: *const opaque, flag: int) *opaque = {$/;"	f
shn	$HARELIB/format/elf/types.ha	/^export type shn = enum u16 {$/;"	t
short	$HARELIB/types/c/arch+aarch64.ha	/^export type short = i16;$/;"	t
short	$HARELIB/types/c/arch+riscv64.ha	/^export type short = i16;$/;"	t
short	$HARELIB/types/c/arch+x86_64.ha	/^export type short = i16;$/;"	t
sht	$HARELIB/format/elf/types.ha	/^export type sht = enum u32 {$/;"	t
shut	$HARELIB/net/types.ha	/^export type shut = enum {$/;"	t
shutdown	$HARELIB/net/+darwin.ha	/^export fn shutdown(sock: socket, how: shut) (void | error) = {$/;"	f
shutdown	$HARELIB/net/+freebsd.ha	/^export fn shutdown(sock: socket, how: shut) (void | error) = {$/;"	f
shutdown	$HARELIB/net/+linux.ha	/^export fn shutdown(sock: socket, how: shut) (void | error) = {$/;"	f
shutdown	$HARELIB/net/+openbsd.ha	/^export fn shutdown(sock: socket, how: shut) (void | error) = {$/;"	f
shutdown	$HARELIB/rt/+darwin/syscalls.ha	/^export fn shutdown(sockfd: int, how: int) (void | errno) = {$/;"	f
shutdown	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn shutdown(sockfd: int, how: int) (void | errno) = {$/;"	f
shutdown	$HARELIB/rt/+linux/syscalls.ha	/^export fn shutdown(sockfd: int, how: int) (void | errno) = {$/;"	f
shutdown	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn shutdown(s: int, how: int) (void | errno) = {$/;"	f
si_band_t	$HARELIB/rt/+linux/types.ha	/^export type si_band_t = i64;$/;"	t
sig	$HARELIB/os/exec/+darwin/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
sig	$HARELIB/os/exec/+freebsd/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
sig	$HARELIB/os/exec/+linux/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
sig	$HARELIB/os/exec/+openbsd/process.ha	/^export fn sig(proc: process, sig: signal::sig) (void | errors::error) = {$/;"	f
sig	$HARELIB/unix/signal/+darwin.ha	/^export type sig = enum int {$/;"	t
sig	$HARELIB/unix/signal/+freebsd.ha	/^export type sig = enum int {$/;"	t
sig	$HARELIB/unix/signal/+linux.ha	/^export type sig = enum int {$/;"	t
sig	$HARELIB/unix/signal/+openbsd.ha	/^export type sig = enum int {$/;"	t
sigact	$HARELIB/rt/+darwin/types.ha	/^export type sigact = struct {$/;"	t
sigact	$HARELIB/rt/+freebsd/types.ha	/^export type sigact = struct {$/;"	t
sigact	$HARELIB/rt/+linux/types.ha	/^export type sigact = struct {$/;"	t
sigact	$HARELIB/rt/+openbsd/types.ha	/^export type sigact = struct {$/;"	t
sigaction	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sigaction($/;"	f
sigaction	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sigaction($/;"	f
sigaction	$HARELIB/rt/+linux/syscalls.ha	/^export fn sigaction($/;"	f
sigaction	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sigaction($/;"	f
sigaction	$HARELIB/unix/signal/+darwin.ha	/^export type sigaction = rt::sigact;$/;"	t
sigaction	$HARELIB/unix/signal/+freebsd.ha	/^export type sigaction = rt::sigact;$/;"	t
sigaction	$HARELIB/unix/signal/+linux.ha	/^export type sigaction = rt::sigact;$/;"	t
sigaction	$HARELIB/unix/signal/+openbsd.ha	/^export type sigaction = rt::sigact;$/;"	t
sigaddset	$HARELIB/rt/+darwin/signal.ha	/^export fn sigaddset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigaddset	$HARELIB/rt/+freebsd/signal.ha	/^export fn sigaddset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigaddset	$HARELIB/rt/+linux/signal.ha	/^export fn sigaddset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigaddset	$HARELIB/rt/+openbsd/signal.ha	/^export fn sigaddset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigaltstack	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sigaltstack($/;"	f
sigaltstack	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sigaltstack($/;"	f
sigaltstack	$HARELIB/rt/+linux/syscalls.ha	/^export fn sigaltstack($/;"	f
sigaltstack	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sigaltstack($/;"	f
sigcontext	$HARELIB/rt/+linux/+aarch64.ha	/^export type sigcontext = struct {$/;"	t
sigcontext	$HARELIB/rt/+linux/+riscv64.ha	/^export type sigcontext = struct {$/;"	t
sigcontext	$HARELIB/rt/+linux/+x86_64.ha	/^export type sigcontext = struct {$/;"	t
sigcontext	$HARELIB/rt/+openbsd/+aarch64.ha	/^export type sigcontext = struct {$/;"	t
sigcontext	$HARELIB/rt/+openbsd/+riscv64.ha	/^export type sigcontext = struct {$/;"	t
sigcontext	$HARELIB/rt/+openbsd/+x86_64.ha	/^export type sigcontext = struct {$/;"	t
sigdelset	$HARELIB/rt/+darwin/signal.ha	/^export fn sigdelset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigdelset	$HARELIB/rt/+freebsd/signal.ha	/^export fn sigdelset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigdelset	$HARELIB/rt/+linux/signal.ha	/^export fn sigdelset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigdelset	$HARELIB/rt/+openbsd/signal.ha	/^export fn sigdelset(set: *sigset, signum: int) (void | errno) = {$/;"	f
sigemptyset	$HARELIB/rt/+darwin/signal.ha	/^export fn sigemptyset(set: *sigset) void = {$/;"	f
sigemptyset	$HARELIB/rt/+freebsd/signal.ha	/^export fn sigemptyset(set: *sigset) void = {$/;"	f
sigemptyset	$HARELIB/rt/+linux/signal.ha	/^export fn sigemptyset(set: *sigset) void = {$/;"	f
sigemptyset	$HARELIB/rt/+openbsd/signal.ha	/^export fn sigemptyset(set: *sigset) void = {$/;"	f
sigfillset	$HARELIB/rt/+darwin/signal.ha	/^export fn sigfillset(set: *sigset) (void | errno) = {$/;"	f
sigfillset	$HARELIB/rt/+freebsd/signal.ha	/^export fn sigfillset(set: *sigset) (void | errno) = {$/;"	f
sigfillset	$HARELIB/rt/+linux/signal.ha	/^export fn sigfillset(set: *sigset) void = {$/;"	f
sigfillset	$HARELIB/rt/+openbsd/signal.ha	/^export fn sigfillset(set: *sigset) (void | errno) = {$/;"	f
siginfo	$HARELIB/rt/+darwin/types.ha	/^export type siginfo = struct {$/;"	t
siginfo	$HARELIB/rt/+freebsd/+aarch64.ha	/^export type siginfo = struct {$/;"	t
siginfo	$HARELIB/rt/+freebsd/+riscv64.ha	/^export type siginfo = struct {$/;"	t
siginfo	$HARELIB/rt/+freebsd/+x86_64.ha	/^export type siginfo = struct {$/;"	t
siginfo	$HARELIB/rt/+linux/types.ha	/^export type siginfo = union {$/;"	t
siginfo	$HARELIB/rt/+openbsd/types.ha	/^export type siginfo = struct {$/;"	t
siginfo	$HARELIB/unix/signal/+darwin.ha	/^export type siginfo = union {$/;"	t
siginfo	$HARELIB/unix/signal/+freebsd.ha	/^export type siginfo = union {$/;"	t
siginfo	$HARELIB/unix/signal/+linux.ha	/^export type siginfo = union {$/;"	t
siginfo	$HARELIB/unix/signal/+openbsd.ha	/^export type siginfo = struct {$/;"	t
sigismember	$HARELIB/rt/+darwin/signal.ha	/^export fn sigismember(set: *sigset, signum: int) (bool | errno) = {$/;"	f
sigismember	$HARELIB/rt/+freebsd/signal.ha	/^export fn sigismember(set: *sigset, signum: int) (bool | errno) = {$/;"	f
sigismember	$HARELIB/rt/+linux/signal.ha	/^export fn sigismember(set: *sigset, signum: int) (bool | errno) = {$/;"	f
sigismember	$HARELIB/rt/+openbsd/signal.ha	/^export fn sigismember(set: *sigset, signum: int) (bool | errno) = {$/;"	f
sign	$HARELIB/crypto/ed25519/ed25519.ha	/^export fn sign(priv: []u8, msg: []u8) [SIGNATURESZ]u8 = {$/;"	f
signaled	$HARELIB/os/exec/+darwin/process.ha	/^export type signaled = signal::sig;$/;"	t
signaled	$HARELIB/os/exec/+freebsd/process.ha	/^export type signaled = signal::sig;$/;"	t
signaled	$HARELIB/os/exec/+linux/process.ha	/^export type signaled = signal::sig;$/;"	t
signaled	$HARELIB/os/exec/+openbsd/process.ha	/^export type signaled = signal::sig;$/;"	t
signalfd	$HARELIB/rt/+linux/syscalls.ha	/^export fn signalfd(fd: int, mask: *const sigset, flags: int) (int | errno) = {$/;"	f
signalfd	$HARELIB/unix/signal/+linux.ha	/^export fn signalfd(signals: sig...) (io::file | errors::error) = {$/;"	f
signalfd_siginfo	$HARELIB/rt/+linux/types.ha	/^export type signalfd_siginfo = struct {$/;"	t
signame	$HARELIB/unix/signal/+darwin.ha	/^export fn signame(sig: sig) const str = {$/;"	f
signame	$HARELIB/unix/signal/+freebsd.ha	/^export fn signame(sig: sig) const str = {$/;"	f
signame	$HARELIB/unix/signal/+linux.ha	/^export fn signame(sig: sig) const str = {$/;"	f
signame	$HARELIB/unix/signal/+openbsd.ha	/^export fn signame(sig: sig) const str = {$/;"	f
signed	$HARELIB/math/ints.ha	/^export fn signi(n: types::signed) i64 = {$/;"	f
signed	$HARELIB/strconv/numeric.ha	/^export fn signedtosb(n: types::signed, b: base) const str = {$/;"	f
signed	$HARELIB/types/classes.ha	/^export type signed = (i8 | i16 | i32 | i64 | int);$/;"	t
signedtos	$HARELIB/strconv/numeric.ha	/^export fn signedtos(n: types::signed) const str = signedtosb(n, base::DEC);$/;"	f
signedtosb	$HARELIB/strconv/numeric.ha	/^export fn signedtosb(n: types::signed, b: base) const str = {$/;"	f
signf	$HARELIB/math/floats.ha	/^export fn signf(x: types::floating) i64 = {$/;"	f
signf32	$HARELIB/math/floats.ha	/^export fn signf32(x: f32) i64 = {$/;"	f
signf64	$HARELIB/math/floats.ha	/^export fn signf64(x: f64) i64 = {$/;"	f
signi	$HARELIB/math/ints.ha	/^export fn signi(n: types::signed) i64 = {$/;"	f
signi16	$HARELIB/math/ints.ha	/^export fn signi16(n: i16) i16 = {$/;"	f
signi32	$HARELIB/math/ints.ha	/^export fn signi32(n: i32) i32 = {$/;"	f
signi64	$HARELIB/math/ints.ha	/^export fn signi64(n: i64) i64 = {$/;"	f
signi8	$HARELIB/math/ints.ha	/^export fn signi8(n: i8) i8 = {$/;"	f
sigprocmask	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sigprocmask($/;"	f
sigprocmask	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sigprocmask($/;"	f
sigprocmask	$HARELIB/rt/+linux/syscalls.ha	/^export fn sigprocmask($/;"	f
sigprocmask	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sigprocmask($/;"	f
sigset	$HARELIB/rt/+darwin/types.ha	/^export type sigset = struct {$/;"	t
sigset	$HARELIB/rt/+freebsd/types.ha	/^export type sigset = struct {$/;"	t
sigset	$HARELIB/rt/+linux/types.ha	/^export type sigset = struct {$/;"	t
sigset	$HARELIB/rt/+openbsd/types.ha	/^export type sigset = uint;$/;"	t
sigset	$HARELIB/unix/signal/+darwin.ha	/^export type sigset = rt::sigset;$/;"	t
sigset	$HARELIB/unix/signal/+freebsd.ha	/^export type sigset = rt::sigset;$/;"	t
sigset	$HARELIB/unix/signal/+linux.ha	/^export type sigset = rt::sigset;$/;"	t
sigset	$HARELIB/unix/signal/+openbsd.ha	/^export type sigset = rt::sigset;$/;"	t
sigset_add	$HARELIB/unix/signal/+darwin.ha	/^export fn sigset_add(set: *sigset, items: sig...) void = {$/;"	f
sigset_add	$HARELIB/unix/signal/+freebsd.ha	/^export fn sigset_add(set: *sigset, items: sig...) void = {$/;"	f
sigset_add	$HARELIB/unix/signal/+linux.ha	/^export fn sigset_add(set: *sigset, items: sig...) void = {$/;"	f
sigset_add	$HARELIB/unix/signal/+openbsd.ha	/^export fn sigset_add(set: *sigset, items: sig...) void = {$/;"	f
sigset_del	$HARELIB/unix/signal/+darwin.ha	/^export fn sigset_del(set: *sigset, items: sig...) void = {$/;"	f
sigset_del	$HARELIB/unix/signal/+freebsd.ha	/^export fn sigset_del(set: *sigset, items: sig...) void = {$/;"	f
sigset_del	$HARELIB/unix/signal/+linux.ha	/^export fn sigset_del(set: *sigset, items: sig...) void = {$/;"	f
sigset_del	$HARELIB/unix/signal/+openbsd.ha	/^export fn sigset_del(set: *sigset, items: sig...) void = {$/;"	f
sigset_empty	$HARELIB/unix/signal/+darwin.ha	/^export fn sigset_empty(set: *sigset) void = {$/;"	f
sigset_empty	$HARELIB/unix/signal/+freebsd.ha	/^export fn sigset_empty(set: *sigset) void = {$/;"	f
sigset_empty	$HARELIB/unix/signal/+linux.ha	/^export fn sigset_empty(set: *sigset) void = {$/;"	f
sigset_empty	$HARELIB/unix/signal/+openbsd.ha	/^export fn sigset_empty(set: *sigset) void = {$/;"	f
sigset_fill	$HARELIB/unix/signal/+darwin.ha	/^export fn sigset_fill(set: *sigset) void = {$/;"	f
sigset_fill	$HARELIB/unix/signal/+freebsd.ha	/^export fn sigset_fill(set: *sigset) void = {$/;"	f
sigset_fill	$HARELIB/unix/signal/+linux.ha	/^export fn sigset_fill(set: *sigset) void = {$/;"	f
sigset_fill	$HARELIB/unix/signal/+openbsd.ha	/^export fn sigset_fill(set: *sigset) void = {$/;"	f
sigset_member	$HARELIB/unix/signal/+darwin.ha	/^export fn sigset_member(set: *sigset, item: sig) bool = {$/;"	f
sigset_member	$HARELIB/unix/signal/+freebsd.ha	/^export fn sigset_member(set: *sigset, item: sig) bool = {$/;"	f
sigset_member	$HARELIB/unix/signal/+linux.ha	/^export fn sigset_member(set: *sigset, item: sig) bool = {$/;"	f
sigset_member	$HARELIB/unix/signal/+openbsd.ha	/^export fn sigset_member(set: *sigset, item: sig) bool = {$/;"	f
sigval	$HARELIB/rt/+darwin/types.ha	/^export type sigval = union {$/;"	t
sigval	$HARELIB/rt/+freebsd/types.ha	/^export type sigval = union {$/;"	t
sigval	$HARELIB/rt/+linux/types.ha	/^export type sigval = union {$/;"	t
sigval	$HARELIB/rt/+openbsd/types.ha	/^export type sigval = union {$/;"	t
simultaneous	$HARELIB/time/chrono/arithmetic.ha	/^export fn simultaneous(a: *moment, b: *moment) (bool | discontinuity) = {$/;"	f
sinc128	$HARELIB/math/complex/complex.ha	/^export fn sinc128(z: c128) c128 = {$/;"	f
sinf64	$HARELIB/math/trig.ha	/^export fn sinf64(x: f64) f64 = {$/;"	f
sinhc128	$HARELIB/math/complex/complex.ha	/^export fn sinhc128(z: c128) c128 = {$/;"	f
sinhf64	$HARELIB/math/trig.ha	/^export fn sinhf64(x: f64) f64 = {$/;"	f
siphash	$HARELIB/hash/siphash/siphash.ha	/^export fn siphash(c: u8, d: u8, key: *[16]u8) state = {$/;"	f
size_expr	$HARELIB/hare/ast/expr.ha	/^export type size_expr = *_type;$/;"	t
sizes	$HARELIB/sort/cmp/cmp.ha	/^export fn sizes(a: const *opaque, b: const *opaque) int = {$/;"	f
skip	$HARELIB/encoding/asn1/decoder.ha	/^export fn skip(d: *decoder, tag: utag, max: size) (size | error) = {$/;"	f
skip	$HARELIB/format/tar/reader.ha	/^export fn skip(ent: *entry) (void | io::error) = {$/;"	f
skip	$HARELIB/test/util+test.ha	/^export fn skip(reason: str) never = {$/;"	f
skip	$HARELIB/test/util.ha	/^export fn skip(reason: str) never = {$/;"	f
sleep	$HARELIB/time/+darwin/functions.ha	/^export fn sleep(d: duration) void = {$/;"	f
sleep	$HARELIB/time/+freebsd/functions.ha	/^export fn sleep(d: duration) void = {$/;"	f
sleep	$HARELIB/time/+linux/functions.ha	/^export fn sleep(d: duration) void = {$/;"	f
sleep	$HARELIB/time/+openbsd/functions.ha	/^export fn sleep(d: duration) void = {$/;"	f
slice	$HARELIB/hare/types/types.ha	/^export type slice = const *_type;$/;"	t
slice	$HARELIB/rt/ensure.ha	/^export type slice = struct {$/;"	t
slice	$HARELIB/strings/iter.ha	/^export fn slice(begin: *iterator, end: *iterator) str = {$/;"	f
slice	$HARELIB/types/classes.ha	/^export type slice = struct {$/;"	t
slice_expr	$HARELIB/hare/ast/expr.ha	/^export type slice_expr = struct {$/;"	t
soa	$HARELIB/net/dns/types.ha	/^export type soa = struct {$/;"	t
sock_filter	$HARELIB/rt/+linux/socket.ha	/^export type sock_filter = struct {$/;"	t
sock_fprog	$HARELIB/rt/+linux/socket.ha	/^export type sock_fprog = struct {$/;"	t
sockaddr	$HARELIB/net/ip/+darwin.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
sockaddr	$HARELIB/net/ip/+freebsd.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
sockaddr	$HARELIB/net/ip/+linux.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
sockaddr	$HARELIB/net/ip/+openbsd.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
sockaddr	$HARELIB/rt/+darwin/socket.ha	/^export type sockaddr = struct {$/;"	t
sockaddr	$HARELIB/rt/+freebsd/socket.ha	/^export type sockaddr = struct {$/;"	t
sockaddr	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr = struct {$/;"	t
sockaddr	$HARELIB/rt/+openbsd/socket.ha	/^export type sockaddr = struct {$/;"	t
sockaddr_in	$HARELIB/rt/+darwin/socket.ha	/^export type sockaddr_in = struct {$/;"	t
sockaddr_in	$HARELIB/rt/+freebsd/socket.ha	/^export type sockaddr_in = struct {$/;"	t
sockaddr_in	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr_in = struct {$/;"	t
sockaddr_in	$HARELIB/rt/+openbsd/socket.ha	/^export type sockaddr_in = struct {$/;"	t
sockaddr_in6	$HARELIB/rt/+darwin/socket.ha	/^export type sockaddr_in6 = struct {$/;"	t
sockaddr_in6	$HARELIB/rt/+freebsd/socket.ha	/^export type sockaddr_in6 = struct {$/;"	t
sockaddr_in6	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr_in6 = struct {$/;"	t
sockaddr_in6	$HARELIB/rt/+openbsd/socket.ha	/^export type sockaddr_in6 = struct {$/;"	t
sockaddr_ll	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr_ll = struct {$/;"	t
sockaddr_nl	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr_nl = struct {$/;"	t
sockaddr_un	$HARELIB/rt/+darwin/socket.ha	/^export type sockaddr_un = struct {$/;"	t
sockaddr_un	$HARELIB/rt/+freebsd/socket.ha	/^export type sockaddr_un = struct {$/;"	t
sockaddr_un	$HARELIB/rt/+linux/socket.ha	/^export type sockaddr_un = struct {$/;"	t
sockaddr_un	$HARELIB/rt/+openbsd/socket.ha	/^export type sockaddr_un = struct {$/;"	t
socket	$HARELIB/net/+darwin.ha	/^export type socket = io::file;$/;"	t
socket	$HARELIB/net/+freebsd.ha	/^export type socket = io::file;$/;"	t
socket	$HARELIB/net/+linux.ha	/^export type socket = io::file;$/;"	t
socket	$HARELIB/net/+openbsd.ha	/^export type socket = io::file;$/;"	t
socket	$HARELIB/net/dial/dial.ha	/^export fn dial_uri(proto: str, uri: *uri::uri) (net::socket | error) = {$/;"	f
socket	$HARELIB/rt/+darwin/syscalls.ha	/^export fn socket(domain: int, type_: int, protocol: int) (int | errno) = {$/;"	f
socket	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn socket(domain: int, type_: int, protocol: int) (int | errno) = {$/;"	f
socket	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn socket(domain: int, type_: int, protocol: int) (int | errno) = {$/;"	f
socket	$HARELIB/rt/+linux/syscalls.ha	/^export fn socket(domain: int, type_: int, protocol: int) (int | errno) = {$/;"	f
socket	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn socket(domain: int, t: int, protocol: int) (int | errno) = {$/;"	f
socketpair	$HARELIB/net/unix/socketpair.ha	/^export fn socketpair(flags: net::sockflag...) ((net::socket, net::socket) | net::error) = {$/;"	f
socketpair	$HARELIB/rt/+darwin/syscalls.ha	/^export fn socketpair($/;"	f
socketpair	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn socketpair($/;"	f
socketpair	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn socketpair($/;"	f
socketpair	$HARELIB/rt/+linux/syscalls.ha	/^export fn socketpair($/;"	f
socketpair	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn socketpair($/;"	f
sockflag	$HARELIB/net/+darwin.ha	/^export type sockflag = enum int {$/;"	t
sockflag	$HARELIB/net/+freebsd.ha	/^export type sockflag = enum int {$/;"	t
sockflag	$HARELIB/net/+linux.ha	/^export type sockflag = enum int {$/;"	t
sockflag	$HARELIB/net/+openbsd.ha	/^export type sockflag = enum int {$/;"	t
socklen_t	$HARELIB/rt/+darwin/socket.ha	/^export type socklen_t = u32;$/;"	t
socklen_t	$HARELIB/rt/+freebsd/socket.ha	/^export type socklen_t = u32;$/;"	t
socklen_t	$HARELIB/rt/+linux/socket.ha	/^export type socklen_t = uint;$/;"	t
socklen_t	$HARELIB/rt/+openbsd/socket.ha	/^export type socklen_t = u32;$/;"	t
sort	$HARELIB/sort/sort.ha	/^export fn sort(items: []opaque, itemsz: size, cmp: *cmpfunc) void = {$/;"	f
sorted	$HARELIB/sort/sort.ha	/^export fn sorted(items: []opaque, itemsz: size, cmp: *cmpfunc) bool = {$/;"	f
speed_t	$HARELIB/rt/+darwin/types.ha	/^export type speed_t = u64;$/;"	t
splice	$HARELIB/rt/+linux/syscalls.ha	/^export fn splice($/;"	f
split	$HARELIB/shlex/split.ha	/^export fn split(in: const str) ([]str | syntaxerr) = {$/;"	f
split	$HARELIB/strings/tokenize.ha	/^export fn split(in: str, delim: str) []str = splitn(in, delim, types::SIZE_MAX);$/;"	f
splitaddr	$HARELIB/net/dial/resolve.ha	/^export fn splitaddr(addr: str, service: str) ((str, u16) | invalid_address) = {$/;"	f
splitn	$HARELIB/strings/tokenize.ha	/^export fn splitn(in: str, delim: str, n: size) []str = {$/;"	f
sqrtc128	$HARELIB/math/complex/complex.ha	/^export fn sqrtc128(z: c128) c128 = {$/;"	f
sqrtf64	$HARELIB/math/math.ha	/^export fn sqrtf64(x: f64) f64 = {$/;"	f
srcset	$HARELIB/hare/module/srcs.ha	/^export type srcset = struct {$/;"	t
srv	$HARELIB/net/dns/types.ha	/^export type srv = struct {$/;"	t
sshfp	$HARELIB/net/dns/types.ha	/^export type sshfp = struct {$/;"	t
ssize	$HARELIB/types/c/arch+aarch64.ha	/^export type ssize = i64;$/;"	t
ssize	$HARELIB/types/c/arch+riscv64.ha	/^export type ssize = i64;$/;"	t
ssize	$HARELIB/types/c/arch+x86_64.ha	/^export type ssize = i64;$/;"	t
st_bind	$HARELIB/format/elf/types.ha	/^export fn st_bind(i: u8) stb = (i >> 4): stb;$/;"	f
st_flock	$HARELIB/rt/+darwin/types.ha	/^export type st_flock = struct {$/;"	t
st_flock	$HARELIB/rt/+freebsd/types.ha	/^export type st_flock = struct {$/;"	t
st_flock	$HARELIB/rt/+linux/types.ha	/^export type st_flock = struct {$/;"	t
st_flock	$HARELIB/rt/+openbsd/types.ha	/^export type st_flock = struct {$/;"	t
st_info	$HARELIB/format/elf/types.ha	/^export fn st_info(b: stb, t: stt) u8 = b: u8 << 4 + t: u8 & 0xF;$/;"	f
st_type	$HARELIB/format/elf/types.ha	/^export fn st_type(i: u8) stt = (i & 0xF): stt;$/;"	f
stack	$HARELIB/hare/unparse/syn.ha	/^export type stack = struct {$/;"	t
stack_t	$HARELIB/rt/+darwin/types.ha	/^export type stack_t = struct {$/;"	t
stack_t	$HARELIB/rt/+freebsd/types.ha	/^export type stack_t = struct {$/;"	t
stack_t	$HARELIB/rt/+linux/types.ha	/^export type stack_t = struct {$/;"	t
stack_t	$HARELIB/rt/+openbsd/types.ha	/^export type stack_t = struct {$/;"	t
stackframe	$HARELIB/debug/+aarch64/walk.ha	/^export type stackframe = struct {$/;"	t
stackframe	$HARELIB/debug/+riscv64/walk.ha	/^export type stackframe = struct {$/;"	t
stackframe	$HARELIB/debug/+x86_64/walk.ha	/^export type stackframe = struct {$/;"	t
start	$HARELIB/os/exec/cmd.ha	/^export fn start(cmd: *command) (process | error) = {$/;"	f
start_darwin	$HARELIB/rt/+darwin/platformstart+libc.ha	/^export fn start_darwin(iv: *[*]uintptr) void = {$/;"	f
start_darwin	$HARELIB/rt/+darwin/platformstart-libc.ha	/^export fn start_darwin(iv: *[*]uintptr) never = {$/;"	f
start_freebsd	$HARELIB/rt/+freebsd/platformstart-libc.ha	/^export fn start_freebsd(iv: *[*]uintptr) never = {$/;"	f
start_ha	$HARELIB/rt/+darwin/start+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) never = {$/;"	f
start_ha	$HARELIB/rt/+darwin/start+test+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) int = {$/;"	f
start_ha	$HARELIB/rt/+darwin/start+test.ha	/^export fn start_ha() never = {$/;"	f
start_ha	$HARELIB/rt/+darwin/start.ha	/^export fn start_ha() never = {$/;"	f
start_ha	$HARELIB/rt/+freebsd/start+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) never = {$/;"	f
start_ha	$HARELIB/rt/+freebsd/start+test+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) int = {$/;"	f
start_ha	$HARELIB/rt/+freebsd/start+test.ha	/^export fn start_ha() never = {$/;"	f
start_ha	$HARELIB/rt/+freebsd/start.ha	/^export fn start_ha() never = {$/;"	f
start_ha	$HARELIB/rt/+linux/start+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) never = {$/;"	f
start_ha	$HARELIB/rt/+linux/start+test+libc.ha	/^export @symbol("main") fn start_ha(c_argc: int, c_argv: *[*]*u8) int = {$/;"	f
start_ha	$HARELIB/rt/+linux/start+test.ha	/^export fn start_ha() never = {$/;"	f
start_ha	$HARELIB/rt/+linux/start.ha	/^export fn start_ha() never = {$/;"	f
start_linux	$HARELIB/rt/+linux/platformstart-libc.ha	/^export fn start_linux(iv: *[*]uintptr) never = {$/;"	f
stat	$HARELIB/fs/fs.ha	/^export fn stat(fs: *fs, path: str) (filestat | error) = {$/;"	f
stat	$HARELIB/os/os.ha	/^export fn stat(path: str) (fs::filestat | fs::error) = fs::stat(cwd, path);$/;"	f
stat	$HARELIB/rt/+linux/stat.ha	/^export fn stat(path: path, statbuf: *st) (errno | void) =$/;"	f
stat	$HARELIB/rt/+openbsd/types.ha	/^export type stat = struct {$/;"	t
stat_mask	$HARELIB/fs/types.ha	/^export type stat_mask = enum uint {$/;"	t
stat_t	$HARELIB/rt/+darwin/types.ha	/^export type stat_t = struct {$/;"	t
state	$HARELIB/crypto/blowfish/blowfish.ha	/^export type state = struct {$/;"	t
state	$HARELIB/crypto/hmac/hmac.ha	/^export type state = struct {$/;"	t
state	$HARELIB/crypto/poly1305/poly1305.ha	/^export type state = struct {$/;"	t
state	$HARELIB/crypto/sha1/sha1.ha	/^export type state = struct {$/;"	t
state	$HARELIB/crypto/sha256/sha256.ha	/^export type state = struct {$/;"	t
state	$HARELIB/dirs/xdg.ha	/^export fn state(prog: str) str = {$/;"	f
state	$HARELIB/hash/adler32/adler32.ha	/^export type state = struct {$/;"	t
state	$HARELIB/hash/crc16/crc16.ha	/^export type state = struct {$/;"	t
state	$HARELIB/hash/crc32/crc32.ha	/^export type state = struct {$/;"	t
state	$HARELIB/hash/crc64/crc64.ha	/^export type state = struct {$/;"	t
state	$HARELIB/hash/siphash/siphash.ha	/^export type state = struct {$/;"	t
state32	$HARELIB/hash/fnv/fnv.ha	/^export type state32 = struct {$/;"	t
state64	$HARELIB/hash/fnv/fnv.ha	/^export type state64 = struct {$/;"	t
statfunc	$HARELIB/fs/types.ha	/^export type statfunc = fn(fs: *fs, path: str) (filestat | error);$/;"	t
status	$HARELIB/os/+darwin/status.ha	/^export type status = enum {$/;"	t
status	$HARELIB/os/+freebsd/status.ha	/^export type status = enum {$/;"	t
status	$HARELIB/os/+linux/status.ha	/^export type status = enum {$/;"	t
status	$HARELIB/os/+openbsd/status.ha	/^export type status = enum {$/;"	t
status	$HARELIB/os/exec/+darwin/process.ha	/^export type status = struct {$/;"	t
status	$HARELIB/os/exec/+freebsd/process.ha	/^export type status = struct {$/;"	t
status	$HARELIB/os/exec/+linux/process.ha	/^export type status = struct {$/;"	t
status	$HARELIB/os/exec/+openbsd/process.ha	/^export type status = struct {$/;"	t
stb	$HARELIB/format/elf/types.ha	/^export type stb = enum u8 {$/;"	t
stdlogger	$HARELIB/log/logger.ha	/^export type stdlogger = struct {$/;"	t
stof32	$HARELIB/strconv/stof.ha	/^export fn stof32(s: str) (f32 | invalid | overflow) = stof32b(s, base::DEC);$/;"	f
stof32b	$HARELIB/strconv/stof.ha	/^export fn stof32b(s: str, b: base) (f32 | invalid | overflow) = {$/;"	f
stof64	$HARELIB/strconv/stof.ha	/^export fn stof64(s: str) (f64 | invalid | overflow) = stof64b(s, base::DEC);$/;"	f
stof64b	$HARELIB/strconv/stof.ha	/^export fn stof64b(s: str, b: base) (f64 | invalid | overflow) = {$/;"	f
stoi	$HARELIB/strconv/stoi.ha	/^export fn stoi(s: str) (int | invalid | overflow) = stoib(s, base::DEC);$/;"	f
stoi16	$HARELIB/strconv/stoi.ha	/^export fn stoi16(s: str) (i16 | invalid | overflow) = stoi16b(s, base::DEC);$/;"	f
stoi16b	$HARELIB/strconv/stoi.ha	/^export fn stoi16b(s: str, base: base) (i16 | invalid | overflow) =$/;"	f
stoi32	$HARELIB/strconv/stoi.ha	/^export fn stoi32(s: str) (i32 | invalid | overflow) = stoi32b(s, base::DEC);$/;"	f
stoi32b	$HARELIB/strconv/stoi.ha	/^export fn stoi32b(s: str, base: base) (i32 | invalid | overflow) =$/;"	f
stoi64	$HARELIB/strconv/stoi.ha	/^export fn stoi64(s: str) (i64 | invalid | overflow) = stoi64b(s, base::DEC);$/;"	f
stoi64b	$HARELIB/strconv/stoi.ha	/^export fn stoi64b(s: str, base: base) (i64 | invalid | overflow) = {$/;"	f
stoi8	$HARELIB/strconv/stoi.ha	/^export fn stoi8(s: str) (i8 | invalid | overflow) = stoi8b(s, base::DEC);$/;"	f
stoi8b	$HARELIB/strconv/stoi.ha	/^export fn stoi8b(s: str, base: base) (i8 | invalid | overflow) =$/;"	f
stoib	$HARELIB/strconv/stoi.ha	/^export fn stoib(s: str, base: base) (int | invalid | overflow) =$/;"	f
store	$HARELIB/hare/types/store.ha	/^export fn store($/;"	f
store_free	$HARELIB/hare/types/store.ha	/^export fn store_free(store: *typestore) void = {$/;"	f
stou	$HARELIB/strconv/stou.ha	/^export fn stou(s: str) (uint | invalid | overflow) = stoub(s, base::DEC);$/;"	f
stou16	$HARELIB/strconv/stou.ha	/^export fn stou16(s: str) (u16 | invalid | overflow) = stou16b(s, base::DEC);$/;"	f
stou16b	$HARELIB/strconv/stou.ha	/^export fn stou16b(s: str, base: base) (u16 | invalid | overflow) =$/;"	f
stou32	$HARELIB/strconv/stou.ha	/^export fn stou32(s: str) (u32 | invalid | overflow) = stou32b(s, base::DEC);$/;"	f
stou32b	$HARELIB/strconv/stou.ha	/^export fn stou32b(s: str, base: base) (u32 | invalid | overflow) =$/;"	f
stou64	$HARELIB/strconv/stou.ha	/^export fn stou64(s: str) (u64 | invalid | overflow) = stou64b(s, base::DEC);$/;"	f
stou64b	$HARELIB/strconv/stou.ha	/^export fn stou64b(s: str, base: base) (u64 | invalid | overflow) = {$/;"	f
stou8	$HARELIB/strconv/stou.ha	/^export fn stou8(s: str) (u8 | invalid | overflow) = stou8b(s, base::DEC);$/;"	f
stou8b	$HARELIB/strconv/stou.ha	/^export fn stou8b(s: str, base: base) (u8 | invalid | overflow) =$/;"	f
stoub	$HARELIB/strconv/stou.ha	/^export fn stoub(s: str, base: base) (uint | invalid | overflow) =$/;"	f
stoz	$HARELIB/strconv/stou.ha	/^export fn stoz(s: str) (size | invalid | overflow) = stozb(s, base::DEC);$/;"	f
stozb	$HARELIB/strconv/stou.ha	/^export fn stozb(s: str, base: base) (size | invalid | overflow) =$/;"	f
strcasecmp	$HARELIB/ascii/string.ha	/^export fn strcasecmp(a: str, b: str) int = {$/;"	f
strclass	$HARELIB/encoding/asn1/types.ha	/^export fn strclass(c: class) str = {$/;"	f
strcmp	$HARELIB/rt/strcmp.ha	/^export fn strcmp(_a: str, _b: str) bool = {$/;"	f
strdecoder	$HARELIB/encoding/asn1/strings.ha	/^export type strdecoder = fn($/;"	t
stream	$HARELIB/bufio/stream.ha	/^export type stream = struct {$/;"	t
stream	$HARELIB/crypto/chacha/chacha20.ha	/^export type stream = struct {$/;"	t
stream	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export type stream = struct {$/;"	t
stream	$HARELIB/crypto/salsa/salsa20.ha	/^export type stream = struct {$/;"	t
stream	$HARELIB/debug/image/sections.ha	/^export fn section_reader(image: *image, sec: *elf::section64) memio::stream = {$/;"	f
stream	$HARELIB/encoding/asn1/encoder.ha	/^export fn derencoder(mem: *memio::stream) encoder = encoder {$/;"	f
stream	$HARELIB/io/stream.ha	/^export type stream = *vtable;$/;"	t
stream	$HARELIB/memio/stream.ha	/^export type stream = struct {$/;"	t
strerror	$HARELIB/crypto/rsa/errors.ha	/^export fn strerror(err: error) str = {$/;"	f
strerror	$HARELIB/encoding/asn1/errors.ha	/^export fn strerror(e: error) str = {$/;"	f
strerror	$HARELIB/encoding/pem/pem.ha	/^export fn strerror(err: io::error) const str = {$/;"	f
strerror	$HARELIB/encoding/utf8/types.ha	/^export fn strerror(err: invalid) str = "Invalid UTF-8";$/;"	f
strerror	$HARELIB/errors/string.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/format/ini/types.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/format/tar/types.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/fs/types.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/getopt/getopts.ha	/^export fn strerror(err: error) str = {$/;"	f
strerror	$HARELIB/glob/glob.ha	/^export fn strerror(err: failure) str = {$/;"	f
strerror	$HARELIB/hare/lex/lex.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/hare/module/types.ha	/^export fn strerror(e: error) str = {$/;"	f
strerror	$HARELIB/hare/parse/doc/doc.ha	/^export fn strerror(err: error) const str = lex::strerror(err);$/;"	f
strerror	$HARELIB/hare/parse/parse.ha	/^export fn strerror(err: error) const str = lex::strerror(err: lex::error);$/;"	f
strerror	$HARELIB/hare/types/store.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/io/types.ha	/^export fn strerror(err: error) str = {$/;"	f
strerror	$HARELIB/linux/keyctl/+linux/types.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/net/dial/registry.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/net/dns/error.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/net/errors.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/os/exec/types.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/path/error.ha	/^export fn strerror(e: error) str = match (e) {$/;"	f
strerror	$HARELIB/regex/regex.ha	/^export fn strerror(err: error) str = err;$/;"	f
strerror	$HARELIB/rt/+darwin/errno.ha	/^export fn strerror(err: errno) str = {$/;"	f
strerror	$HARELIB/rt/+freebsd/errno.ha	/^export fn strerror(err: errno) str = {$/;"	f
strerror	$HARELIB/rt/+linux/errno.ha	/^export fn strerror(err: errno) str = {$/;"	f
strerror	$HARELIB/rt/+openbsd/errno.ha	/^export fn strerror(err: errno) str = {$/;"	f
strerror	$HARELIB/shlex/split.ha	/^export fn strerror(err: syntaxerr) str = "Invalid shell syntax";$/;"	f
strerror	$HARELIB/strconv/types.ha	/^export fn strerror(err: error) str = {$/;"	f
strerror	$HARELIB/strings/template/template.ha	/^export fn strerror(err: invalid) str = "Template string has invalid format";$/;"	f
strerror	$HARELIB/time/chrono/error.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/time/date/error.ha	/^export fn strerror(err: error) const str = {$/;"	f
strerror	$HARELIB/unix/hosts/hosts.ha	/^export fn strerror(err: error) const str = match (err) {$/;"	f
strerror	$HARELIB/unix/poll/types.ha	/^export fn strerror(err: error) const str = errors::strerror(err);$/;"	f
strerror	$HARELIB/unix/tty/types.ha	/^export fn strerror(err: error) str = {$/;"	f
strerror	$HARELIB/wordexp/error.ha	/^export fn strerror(err: error) const str = {$/;"	f
string	$HARELIB/hash/fnv/+aarch64.ha	/^export fn string(s: str) size = string64(s): size;$/;"	f
string	$HARELIB/hash/fnv/+riscv64.ha	/^export fn string(s: str) size = string64(s): size;$/;"	f
string	$HARELIB/hash/fnv/+x86_64.ha	/^export fn string(s: str) size = string64(s): size;$/;"	f
string	$HARELIB/memio/stream.ha	/^export fn string(in: *stream) (str | utf8::invalid) = {$/;"	f
string	$HARELIB/net/ip/ip.ha	/^export fn string(item: (...addr | subnet)) str = {$/;"	f
string	$HARELIB/net/uri/fmt.ha	/^export fn string(u: *const uri) str = {$/;"	f
string	$HARELIB/path/buffer.ha	/^export fn string(buf: *buffer) str = {$/;"	f
string	$HARELIB/types/classes.ha	/^export type string = struct {$/;"	t
string32	$HARELIB/hash/fnv/fnv.ha	/^export fn string32(s: str) u32 = {$/;"	f
string64	$HARELIB/hash/fnv/fnv.ha	/^export fn string64(s: str) u64 = {$/;"	f
string_table	$HARELIB/debug/dwarf/strings.ha	/^export type string_table = struct {$/;"	t
strlen	$HARELIB/types/c/strings.ha	/^export fn strlen(cstr: *const char) size = {$/;"	f
strlower	$HARELIB/ascii/string.ha	/^export fn strlower(s: str) str = {$/;"	f
strlower_buf	$HARELIB/ascii/string.ha	/^export fn strlower_buf(s: str, buf: []u8) str = {$/;"	f
stroid	$HARELIB/encoding/asn1/oid.ha	/^export fn stroid(db: *oiddb, o: oid) str = {$/;"	f
strrawoid	$HARELIB/encoding/asn1/oid.ha	/^export fn strrawoid(der: []u8) (str | io::error) = {$/;"	f
strreader	$HARELIB/encoding/asn1/strings.ha	/^export fn strreader(d: *decoder, t: utag) (utf8stream | error) = {$/;"	f
strs	$HARELIB/sort/cmp/cmp.ha	/^export fn strs(a: const *opaque, b: const *opaque) int = {$/;"	f
strstack	$HARELIB/glob/glob.ha	/^export type strstack = struct {$/;"	t
strtag	$HARELIB/encoding/asn1/types.ha	/^export fn strtag(dh: head) str = {$/;"	f
struct_alias	$HARELIB/hare/ast/type.ha	/^export type struct_alias = ident;$/;"	t
struct_embedded	$HARELIB/hare/ast/type.ha	/^export type struct_embedded = *_type;$/;"	t
struct_field	$HARELIB/hare/ast/type.ha	/^export type struct_field = struct {$/;"	t
struct_field	$HARELIB/hare/types/types.ha	/^export type struct_field = struct {$/;"	t
struct_literal	$HARELIB/hare/ast/expr.ha	/^export type struct_literal = struct {$/;"	t
struct_member	$HARELIB/hare/ast/type.ha	/^export type struct_member = struct {$/;"	t
struct_type	$HARELIB/hare/ast/type.ha	/^export type struct_type = struct {$/;"	t
struct_union	$HARELIB/hare/types/types.ha	/^export type struct_union = enum {$/;"	t
struct_union_type	$HARELIB/hare/ast/type.ha	/^export type struct_union_type = (struct_type | union_type);$/;"	t
struct_value	$HARELIB/hare/ast/expr.ha	/^export type struct_value = struct {$/;"	t
strupper	$HARELIB/ascii/string.ha	/^export fn strupper(s: str) str = {$/;"	f
strupper_buf	$HARELIB/ascii/string.ha	/^export fn strupper_buf(s: str, buf: []u8) str = {$/;"	f
stt	$HARELIB/format/elf/types.ha	/^export type stt = enum u8 {$/;"	t
sub	$HARELIB/crypto/bigint/arithm.ha	/^export fn sub(a: []word, b: const []word, do: u32) u32 = {$/;"	f
sub	$HARELIB/strings/sub.ha	/^export fn sub(s: str, start: size, end: (size | end)) str = {$/;"	f
subc128	$HARELIB/math/complex/complex.ha	/^export fn subc128(a: c128, b: c128) c128 = (a.0 - b.0, a.1 - b.1);$/;"	f
subc64	$HARELIB/math/complex/complex.ha	/^export fn subc64(a: c64, b: c64) c64 = (a.0 - b.0, a.1 - b.1);$/;"	f
subcmd_help	$HARELIB/getopt/getopts.ha	/^export type subcmd_help = (str, []help);$/;"	t
subi16	$HARELIB/math/checked/checked.ha	/^export fn subi16(a: i16, b: i16) (i16, bool) = addi16(a, -b);$/;"	f
subi32	$HARELIB/math/checked/checked.ha	/^export fn subi32(a: i32, b: i32) (i32, bool) = addi32(a, -b);$/;"	f
subi64	$HARELIB/math/checked/checked.ha	/^export fn subi64(a: i64, b: i64) (i64, bool) = addi64(a, -b);$/;"	f
subi8	$HARELIB/math/checked/checked.ha	/^export fn subi8(a: i8, b: i8) (i8, bool) = addi8(a, -b);$/;"	f
subnet	$HARELIB/net/ip/ip.ha	/^export type subnet = struct {$/;"	t
subnet_contains	$HARELIB/net/ip/ip.ha	/^export fn subnet_contains(sub: subnet, item: (addr | subnet)) bool = {$/;"	f
subu	$HARELIB/math/uints.ha	/^export fn subu(x: uint, y: uint, carry: uint) (uint, uint) = {$/;"	f
subu16	$HARELIB/math/checked/checked.ha	/^export fn subu16(a: u16, b: u16) (u16, bool) = {$/;"	f
subu32	$HARELIB/math/checked/checked.ha	/^export fn subu32(a: u32, b: u32) (u32, bool) = {$/;"	f
subu32	$HARELIB/math/uints.ha	/^export fn subu32(x: u32, y: u32, borrow: u32) (u32, u32) = {$/;"	f
subu64	$HARELIB/math/checked/checked.ha	/^export fn subu64(a: u64, b: u64) (u64, bool) = {$/;"	f
subu64	$HARELIB/math/uints.ha	/^export fn subu64(x: u64, y: u64, borrow: u64) (u64, u64) = {$/;"	f
subu8	$HARELIB/math/checked/checked.ha	/^export fn subu8(a: u8, b: u8) (u8, bool) = {$/;"	f
subunit	$HARELIB/hare/ast/unit.ha	/^export type subunit = struct {$/;"	t
subunit	$HARELIB/hare/parse/unit.ha	/^export fn subunit(lexer: *lex::lexer) (ast::subunit | error) = {$/;"	f
subunit	$HARELIB/hare/unparse/unit.ha	/^export fn subunit($/;"	f
subunit_finish	$HARELIB/hare/ast/unit.ha	/^export fn subunit_finish(u: subunit) void = {$/;"	f
sum	$HARELIB/crypto/mac/mac.ha	/^export fn sum(m: *mac, buf: []u8) void = {$/;"	f
sum	$HARELIB/hash/hash.ha	/^export fn sum(h: *hash, buf: []u8) void = {$/;"	f
sum	$HARELIB/hash/siphash/siphash.ha	/^export fn sum(h: *state) u64 = {$/;"	f
sum	$HARELIB/time/date/period.ha	/^export fn sum(ps: period...) period = {$/;"	f
sum16	$HARELIB/hash/crc16/crc16.ha	/^export fn sum16(h: *hash::hash) u16 = {$/;"	f
sum32	$HARELIB/hash/adler32/adler32.ha	/^export fn sum32(h: *hash::hash) u32 = {$/;"	f
sum32	$HARELIB/hash/crc32/crc32.ha	/^export fn sum32(h: *hash::hash) u32 = {$/;"	f
sum32	$HARELIB/hash/fnv/fnv.ha	/^export fn sum32(h: *hash::hash) u32 = {$/;"	f
sum64	$HARELIB/hash/crc64/crc64.ha	/^export fn sum64(h: *hash::hash) u64 = {$/;"	f
sum64	$HARELIB/hash/fnv/fnv.ha	/^export fn sum64(h: *hash::hash) u64 = {$/;"	f
sundayweek	$HARELIB/time/date/observe.ha	/^export fn sundayweek(d: *date) int = _sundayweek(d);$/;"	f
support	$HARELIB/linux/keyctl/+linux/types.ha	/^export type support = enum u32 {$/;"	t
suseconds_t	$HARELIB/rt/+darwin/types.ha	/^export type suseconds_t = i64;$/;"	t
suseconds_t	$HARELIB/rt/+freebsd/types.ha	/^export type suseconds_t = i64;$/;"	t
suseconds_t	$HARELIB/rt/+linux/types.ha	/^export type suseconds_t = i64;$/;"	t
suseconds_t	$HARELIB/rt/+openbsd/types.ha	/^export type suseconds_t = i64;$/;"	t
switch_case	$HARELIB/hare/ast/expr.ha	/^export type switch_case = struct {$/;"	t
switch_expr	$HARELIB/hare/ast/expr.ha	/^export type switch_expr = struct {$/;"	t
sym64	$HARELIB/format/elf/types.ha	/^export type sym64 = struct {$/;"	t
symbol_byaddr	$HARELIB/debug/symbols.ha	/^export fn symbol_byaddr($/;"	f
symbol_byname	$HARELIB/debug/symbols.ha	/^export fn symbol_byname($/;"	f
symbol_name	$HARELIB/debug/symbols.ha	/^export fn symbol_name($/;"	f
symlink	$HARELIB/fs/fs.ha	/^export fn symlink(fs: *fs, target: str, path: str) (void | error) = {$/;"	f
symlink	$HARELIB/os/os.ha	/^export fn symlink(target: str, path: str) (void | fs::error) =$/;"	f
symlinkat	$HARELIB/rt/+linux/syscalls.ha	/^export fn symlinkat($/;"	f
symlinkat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn symlinkat($/;"	f
symlinkfunc	$HARELIB/fs/types.ha	/^export type symlinkfunc = fn(fs: *fs, target: str, path: str) (void | error);$/;"	t
symname_to_ident	$HARELIB/debug/ident.ha	/^export fn symname_to_ident(name: str) const str = {$/;"	f
syn_nowrap	$HARELIB/hare/unparse/syn.ha	/^export fn syn_nowrap($/;"	f
syn_wrap	$HARELIB/hare/unparse/syn.ha	/^export fn syn_wrap(ctx: *context, s: str, kind: synkind) (size | io::error) = {$/;"	f
sync	$HARELIB/rt/+linux/syscalls.ha	/^export fn sync() void = {$/;"	f
synfunc	$HARELIB/hare/unparse/syn.ha	/^export type synfunc = fn($/;"	t
synkind	$HARELIB/hare/unparse/syn.ha	/^export type synkind = enum {$/;"	t
syntax	$HARELIB/hare/lex/lex.ha	/^export type syntax = !(location, str);$/;"	t
syntaxerr	$HARELIB/format/ini/types.ha	/^export type syntaxerr = !size;$/;"	t
syntaxerr	$HARELIB/hare/lex/lex.ha	/^export fn syntaxerr(loc: location, why: str) error = {$/;"	f
syntaxerr	$HARELIB/shlex/split.ha	/^export type syntaxerr = !void;$/;"	t
syscall	$HARELIB/rt/+darwin/syscalls.ha	/^export fn syscall(num: u64, args: u64...) u64 = {$/;"	f
syscall	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn syscall(num: u64, args: u64...) u64 = {$/;"	f
syscall	$HARELIB/rt/+linux/syscalls.ha	/^export fn syscall(num: u64, args: u64...) u64 = {$/;"	f
sysctl	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn sysctl($/;"	f
sysctlbyname	$HARELIB/rt/+darwin/syscalls.ha	/^export fn sysctlbyname(name: str, oldp: nullable *opaque, oldlenp: nullable *size,$/;"	f
sysctlbyname	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn sysctlbyname(name: str, oldp: nullable *opaque, oldlenp: nullable *size,$/;"	f
sysctlbyname	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn sysctlbyname(name: str, oldp: nullable *opaque, oldlenp: nullable *size,$/;"	f
sysname	$HARELIB/os/+darwin/platform_environ.ha	/^export fn sysname() const str = {$/;"	f
sysname	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn sysname() const str = {$/;"	f
sysname	$HARELIB/os/+linux/platform_environ.ha	/^export fn sysname() const str = {$/;"	f
sysname	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn sysname() const str = {$/;"	f
t61_chardecode	$HARELIB/encoding/asn1/t61.ha	/^export fn t61_chardecode(in: []u8) (rune | insufficient | invalid) = {$/;"	f
table_reader	$HARELIB/debug/dwarf/reader.ha	/^export type table_reader = struct {$/;"	t
tag	$HARELIB/hare/module/srcs.ha	/^export type tag = struct {$/;"	t
tag_bad_format	$HARELIB/hare/module/types.ha	/^export type tag_bad_format = !void;$/;"	t
tag_has_dot	$HARELIB/hare/module/types.ha	/^export type tag_has_dot = !void;$/;"	t
tagged	$HARELIB/hare/types/types.ha	/^export type tagged = []const *_type;$/;"	t
tagged_type	$HARELIB/hare/ast/type.ha	/^export type tagged_type = []*_type;$/;"	t
tags_compat	$HARELIB/hare/module/srcs.ha	/^export fn tags_compat(have: []str, want: []tag) bool = {$/;"	f
tanc128	$HARELIB/math/complex/complex.ha	/^export fn tanc128(x: c128) c128 = {$/;"	f
tanf64	$HARELIB/math/trig.ha	/^export fn tanf64(x: f64) f64 = {$/;"	f
tanhc128	$HARELIB/math/complex/complex.ha	/^export fn tanhc128(x: c128) c128 = {$/;"	f
tanhf64	$HARELIB/math/trig.ha	/^export fn tanhf64(x: f64) f64 = {$/;"	f
tcflag	$HARELIB/rt/+darwin/types.ha	/^export type tcflag = enum uint {$/;"	t
tcflag	$HARELIB/rt/+freebsd/types.ha	/^export type tcflag = enum uint {$/;"	t
tcflag	$HARELIB/rt/+linux/types.ha	/^export type tcflag = enum uint {$/;"	t
tcflag	$HARELIB/rt/+openbsd/types.ha	/^export type tcflag = enum uint {$/;"	t
tcsetpgrp	$HARELIB/unix/tty/+darwin/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
tcsetpgrp	$HARELIB/unix/tty/+freebsd/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
tcsetpgrp	$HARELIB/unix/tty/+linux/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
tcsetpgrp	$HARELIB/unix/tty/+openbsd/pgid.ha	/^export fn tcsetpgrp(fd: io::file, pg: exec::process) (void | errors::error) = {$/;"	f
tee	$HARELIB/io/tee.ha	/^export fn tee(h: handle, sink: handle) teestream = {$/;"	f
tee	$HARELIB/rt/+linux/syscalls.ha	/^export fn tee(fd_in: int, fd_out: int, ln: size, flags: uint) (size | errno) = {$/;"	f
teestream	$HARELIB/io/tee.ha	/^export type teestream = struct {$/;"	t
tell	$HARELIB/io/handle.ha	/^export fn tell(h: handle) (off | error) = {$/;"	f
template	$HARELIB/strings/template/template.ha	/^export type template = []instruction;$/;"	t
termios	$HARELIB/rt/+darwin/types.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/rt/+freebsd/types.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/rt/+linux/types.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/rt/+openbsd/types.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/unix/tty/+darwin/termios.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/unix/tty/+freebsd/termios.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/unix/tty/+linux/termios.ha	/^export type termios = struct {$/;"	t
termios	$HARELIB/unix/tty/+openbsd/termios.ha	/^export type termios = struct {$/;"	t
termios_query	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn termios_query(file: io::file) (termios | errors::error) = {$/;"	f
termios_query	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn termios_query(file: io::file) (termios | errors::error) = {$/;"	f
termios_query	$HARELIB/unix/tty/+linux/termios.ha	/^export fn termios_query(file: io::file) (termios | errors::error) = {$/;"	f
termios_query	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn termios_query(file: io::file) (termios | errors::error) = {$/;"	f
termios_restore	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn termios_restore(termios: *const termios) void = {$/;"	f
termios_restore	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn termios_restore(termios: *const termios) void = {$/;"	f
termios_restore	$HARELIB/unix/tty/+linux/termios.ha	/^export fn termios_restore(termios: *const termios) void = {$/;"	f
termios_restore	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn termios_restore(termios: *const termios) void = {$/;"	f
termios_set	$HARELIB/unix/tty/+darwin/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
termios_set	$HARELIB/unix/tty/+freebsd/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
termios_set	$HARELIB/unix/tty/+linux/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
termios_set	$HARELIB/unix/tty/+openbsd/termios.ha	/^export fn termios_set(termios: *const termios) (void | errors::error) = {$/;"	f
test	$HARELIB/regex/regex.ha	/^export fn test(re: *regex, string: str) bool = {$/;"	f
testexcept	$HARELIB/math/fenv_func.ha	/^export fn testexcept(ex: fexcept) fexcept = rt::fetestexcept(ex: uint): fexcept;$/;"	f
time_t	$HARELIB/rt/+darwin/types.ha	/^export type time_t      = i64;$/;"	t
time_t	$HARELIB/rt/+freebsd/types.ha	/^export type time_t = i64;$/;"	t
time_t	$HARELIB/rt/+linux/types.ha	/^export type time_t = i64;$/;"	t
time_t	$HARELIB/rt/+openbsd/types.ha	/^export type time_t = i64;$/;"	t
timeout	$HARELIB/errors/common.ha	/^export type timeout = !void;$/;"	t
timer_t	$HARELIB/rt/+linux/types.ha	/^export type timer_t = *opaque;$/;"	t
timerfd_create	$HARELIB/rt/+linux/syscalls.ha	/^export fn timerfd_create(clock_id: int, flags: int) (int | errno) = {$/;"	f
timerfd_gettime	$HARELIB/rt/+linux/syscalls.ha	/^export fn timerfd_gettime(fd: int, curr_value: *itimerspec) (int | errno) = {$/;"	f
timerfd_settime	$HARELIB/rt/+linux/syscalls.ha	/^export fn timerfd_settime($/;"	f
timescale	$HARELIB/time/chrono/timescale.ha	/^export type timescale = struct {$/;"	t
timespec	$HARELIB/rt/+darwin/types.ha	/^export type timespec = struct {$/;"	t
timespec	$HARELIB/rt/+freebsd/types.ha	/^export type timespec = struct {$/;"	t
timespec	$HARELIB/rt/+linux/types.ha	/^export type timespec = struct {$/;"	t
timespec	$HARELIB/rt/+openbsd/types.ha	/^export type timespec = struct {$/;"	t
timespec	$HARELIB/time/+darwin/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec	$HARELIB/time/+freebsd/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec	$HARELIB/time/+linux/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec	$HARELIB/time/+openbsd/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec_to_instant	$HARELIB/time/+darwin/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec_to_instant	$HARELIB/time/+freebsd/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec_to_instant	$HARELIB/time/+linux/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timespec_to_instant	$HARELIB/time/+openbsd/functions.ha	/^export fn timespec_to_instant(ts: rt::timespec) instant = instant {$/;"	f
timeval	$HARELIB/rt/+darwin/types.ha	/^export type timeval = struct {$/;"	t
timeval	$HARELIB/rt/+freebsd/types.ha	/^export type timeval = struct {$/;"	t
timeval	$HARELIB/rt/+linux/types.ha	/^export type timeval = struct {$/;"	t
timeval	$HARELIB/rt/+openbsd/types.ha	/^export type timeval = struct {$/;"	t
timezone	$HARELIB/time/chrono/timezone.ha	/^export type timezone = struct {$/;"	t
timezone_free	$HARELIB/time/chrono/timezone.ha	/^export fn timezone_free(tz: *timezone) void = {$/;"	f
to_native	$HARELIB/net/ip/+darwin.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
to_native	$HARELIB/net/ip/+freebsd.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
to_native	$HARELIB/net/ip/+linux.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
to_native	$HARELIB/net/ip/+openbsd.ha	/^export fn to_native(a: addr, port: u16) rt::sockaddr = {$/;"	f
tohex	$HARELIB/crypto/bigint/+test/utils.ha	/^export fn tohex(x: []word) str = {$/;"	f
token	$HARELIB/hare/lex/token.ha	/^export type token = (ltok, value, location);$/;"	t
tokenize	$HARELIB/bytes/tokenize.ha	/^export fn tokenize(s: []u8, delim: []u8) tokenizer = {$/;"	f
tokenize	$HARELIB/strings/tokenize.ha	/^export fn tokenize(s: str, delim: str) tokenizer =$/;"	f
tokenizer	$HARELIB/bytes/tokenize.ha	/^export type tokenizer = struct {$/;"	t
tokenizer	$HARELIB/strings/tokenize.ha	/^export type tokenizer = bytes::tokenizer;$/;"	t
tokstr	$HARELIB/hare/lex/token.ha	/^export fn tokstr(tok: token) const str = {$/;"	f
tolower	$HARELIB/ascii/ctype.ha	/^export fn tolower(c: rune) rune = {$/;"	f
tomonty	$HARELIB/crypto/bigint/monty.ha	/^export fn tomonty(x: []word, m: const []word) void = {$/;"	f
too_long	$HARELIB/path/error.ha	/^export type too_long = !void;$/;"	t
torunes	$HARELIB/strings/runes.ha	/^export fn torunes(s: str) []rune = {$/;"	f
tostr	$HARELIB/types/c/strings.ha	/^export fn tostr(cstr: *const char) (const str | utf8::invalid) = {$/;"	f
tostr_unsafe	$HARELIB/types/c/strings.ha	/^export fn tostr_unsafe(cstr: *const char) const str = {$/;"	f
tostrn	$HARELIB/types/c/strings.ha	/^export fn tostrn(cstr: *const char, length: size) (const str | utf8::invalid) = {$/;"	f
tostrn_unsafe	$HARELIB/types/c/strings.ha	/^export fn tostrn_unsafe(cstr: *const char, length: size) const str = {$/;"	f
toupper	$HARELIB/ascii/ctype.ha	/^export fn toupper(c: rune) rune = {$/;"	f
toutf8	$HARELIB/strings/utf8.ha	/^export fn toutf8(in: str) []u8 = *(&in: *[]u8);$/;"	f
trailing_zeros_u	$HARELIB/math/uints.ha	/^export fn trailing_zeros_u(x: uint) u8 = {$/;"	f
trailing_zeros_u16	$HARELIB/math/uints.ha	/^export fn trailing_zeros_u16(x: u16) u8 = {$/;"	f
trailing_zeros_u32	$HARELIB/math/uints.ha	/^export fn trailing_zeros_u32(x: u32) u8 = {$/;"	f
trailing_zeros_u64	$HARELIB/math/uints.ha	/^export fn trailing_zeros_u64(x: u64) u8 = {$/;"	f
trailing_zeros_u8	$HARELIB/math/uints.ha	/^export fn trailing_zeros_u8(x: u8) u8 = NTZ8TAB[x];$/;"	f
transition	$HARELIB/time/chrono/timezone.ha	/^export type transition = struct {$/;"	t
translate	$HARELIB/debug/+darwin/translate.ha	/^export fn translate(ptr: uintptr) (uintptr | void) = {$/;"	f
translate	$HARELIB/debug/+freebsd/translate.ha	/^export fn translate(ptr: uintptr) (uintptr | void) = {$/;"	f
translate	$HARELIB/debug/+linux/translate.ha	/^export fn translate(ptr: uintptr) (uintptr | void) = {$/;"	f
translate	$HARELIB/debug/+openbsd/translate.ha	/^export fn translate(ptr: uintptr) (uintptr | void) = {$/;"	f
trim	$HARELIB/bytes/trim.ha	/^export fn trim(in: []u8, trim: u8...) []u8 = ltrim(rtrim(in, trim...), trim...);$/;"	f
trim	$HARELIB/strings/trim.ha	/^export fn trim(input: str, exclude: rune...) str =$/;"	f
trimprefix	$HARELIB/path/prefix.ha	/^export fn trimprefix(buf: *buffer, prefix: str) (str | error) = {$/;"	f
trimprefix	$HARELIB/strings/trim.ha	/^export fn trimprefix(input: str, trim: str) str = {$/;"	f
trimsuffix	$HARELIB/strings/trim.ha	/^export fn trimsuffix(input: str, trim: str) str = {$/;"	f
trunc	$HARELIB/io/file.ha	/^export fn trunc(fd: file, ln: size) (void | error) = fd_trunc(fd, ln);$/;"	f
truncate	$HARELIB/time/date/parithm.ha	/^export fn truncate(d: date, u: unit) date = {$/;"	f
truncated	$HARELIB/encoding/asn1/errors.ha	/^export type truncated = !void;$/;"	t
truncf64	$HARELIB/math/math.ha	/^export fn truncf64(x: f64) f64 = {$/;"	f
tryenv	$HARELIB/os/environ.ha	/^export fn tryenv(name: const str, default: str) str = match (getenv(name)) {$/;"	f
tryparse	$HARELIB/getopt/getopts.ha	/^export fn tryparse(args: []str, help: help...) (command | error) = {$/;"	f
trypeek	$HARELIB/encoding/asn1/decoder.ha	/^export fn trypeek(d: *decoder) (head | error | io::EOF) = {$/;"	f
tsconverter	$HARELIB/time/chrono/timescale.ha	/^export type tsconverter = fn(ts: *timescale, i: time::instant) ([]time::instant | void);$/;"	t
tsig	$HARELIB/net/dns/types.ha	/^export type tsig = struct {$/;"	t
ttysize	$HARELIB/unix/tty/types.ha	/^export type ttysize = struct {$/;"	t
tuple	$HARELIB/hare/types/types.ha	/^export type tuple = []tuple_value;$/;"	t
tuple_literal	$HARELIB/hare/ast/expr.ha	/^export type tuple_literal = []*expr;$/;"	t
tuple_type	$HARELIB/hare/ast/type.ha	/^export type tuple_type = []*_type;$/;"	t
tuple_value	$HARELIB/hare/types/types.ha	/^export type tuple_value = struct {$/;"	t
txt	$HARELIB/net/dns/types.ha	/^export type txt = [][]u8;$/;"	t
type_finish	$HARELIB/hare/ast/type.ha	/^export fn type_finish(t: nullable *_type) void = match (t) {$/;"	f
type_flag	$HARELIB/hare/ast/type.ha	/^export type type_flag = enum uint {$/;"	t
type_params	$HARELIB/mime/parse.ha	/^export type type_params = strings::tokenizer;$/;"	t
typestore	$HARELIB/hare/types/store.ha	/^export type typestore = struct {$/;"	t
tzdberror	$HARELIB/time/chrono/tzdb.ha	/^export type tzdberror = !(invalidtzif | fs::error | io::error);$/;"	t
u16s	$HARELIB/sort/cmp/cmp.ha	/^export fn u16s(a: const *opaque, b: const *opaque) int = {$/;"	f
u16tos	$HARELIB/strconv/utos.ha	/^export fn u16tos(u: u16) const str = u64tos(u);$/;"	f
u16tosb	$HARELIB/strconv/utos.ha	/^export fn u16tosb(u: u16, b: base) const str = u64tosb(u, b);$/;"	f
u32n	$HARELIB/math/random/random.ha	/^export fn u32n(r: *random, n: u32) u32 = {$/;"	f
u32s	$HARELIB/sort/cmp/cmp.ha	/^export fn u32s(a: const *opaque, b: const *opaque) int = {$/;"	f
u32tos	$HARELIB/strconv/utos.ha	/^export fn u32tos(u: u32) const str = u64tos(u);$/;"	f
u32tosb	$HARELIB/strconv/utos.ha	/^export fn u32tosb(u: u32, b: base) const str = u64tosb(u, b);$/;"	f
u64n	$HARELIB/math/random/random.ha	/^export fn u64n(r: *random, n: u64) u64 = {$/;"	f
u64s	$HARELIB/sort/cmp/cmp.ha	/^export fn u64s(a: const *opaque, b: const *opaque) int = {$/;"	f
u64tos	$HARELIB/strconv/utos.ha	/^export fn u64tos(u: u64) const str = u64tosb(u, base::DEC);$/;"	f
u64tosb	$HARELIB/strconv/utos.ha	/^export fn u64tosb(u: u64, b: base) const str = {$/;"	f
u8s	$HARELIB/sort/cmp/cmp.ha	/^export fn u8s(a: const *opaque, b: const *opaque) int = {$/;"	f
u8tos	$HARELIB/strconv/utos.ha	/^export fn u8tos(u: u8) const str = u64tos(u);$/;"	f
u8tosb	$HARELIB/strconv/utos.ha	/^export fn u8tosb(u: u8, b: base) const str = u64tosb(u, b);$/;"	f
uchar	$HARELIB/types/c/types.ha	/^export type uchar = u8;$/;"	t
ucontext	$HARELIB/rt/+darwin/+aarch64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+darwin/+riscv64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+darwin/+x86_64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+freebsd/+aarch64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+freebsd/+riscv64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+freebsd/+x86_64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+linux/+aarch64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+linux/+riscv64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+linux/+x86_64.ha	/^export type ucontext = struct {$/;"	t
ucontext	$HARELIB/rt/+openbsd/+aarch64.ha	/^export type ucontext = sigcontext;$/;"	t
ucontext	$HARELIB/rt/+openbsd/+riscv64.ha	/^export type ucontext = sigcontext;$/;"	t
ucontext	$HARELIB/rt/+openbsd/+x86_64.ha	/^export type ucontext = sigcontext;$/;"	t
uid	$HARELIB/unix/+darwin/creds.ha	/^export type uid = rt::uid_t;$/;"	t
uid	$HARELIB/unix/+freebsd/creds.ha	/^export type uid = rt::uid_t;$/;"	t
uid	$HARELIB/unix/+linux/creds.ha	/^export type uid = rt::uid_t;$/;"	t
uid	$HARELIB/unix/+openbsd/creds.ha	/^export type uid = rt::uid_t;$/;"	t
uid	$HARELIB/unix/passwd/passwd.ha	/^export fn getuid(uid: unix::uid) (pwent | void) = {$/;"	f
uid_t	$HARELIB/rt/+darwin/types.ha	/^export type uid_t       = uint;$/;"	t
uid_t	$HARELIB/rt/+freebsd/types.ha	/^export type uid_t = uint;$/;"	t
uid_t	$HARELIB/rt/+linux/types.ha	/^export type uid_t = uint;$/;"	t
uid_t	$HARELIB/rt/+openbsd/types.ha	/^export type uid_t = u32;$/;"	t
uint_fast16	$HARELIB/types/c/types.ha	/^export type uint_fast16 = u16;$/;"	t
uint_fast32	$HARELIB/types/c/types.ha	/^export type uint_fast32 = u32;$/;"	t
uint_fast64	$HARELIB/types/c/types.ha	/^export type uint_fast64 = u64;$/;"	t
uint_fast8	$HARELIB/types/c/types.ha	/^export type uint_fast8 = u8;$/;"	t
uint_least16	$HARELIB/types/c/types.ha	/^export type uint_least16 = u16;$/;"	t
uint_least32	$HARELIB/types/c/types.ha	/^export type uint_least32 = u32;$/;"	t
uint_least64	$HARELIB/types/c/types.ha	/^export type uint_least64 = u64;$/;"	t
uint_least8	$HARELIB/types/c/types.ha	/^export type uint_least8 = u8;$/;"	t
uintmax	$HARELIB/types/c/types.ha	/^export type uintmax = u64;$/;"	t
uints	$HARELIB/sort/cmp/cmp.ha	/^export fn uints(a: const *opaque, b: const *opaque) int = {$/;"	f
ulong	$HARELIB/types/c/arch+aarch64.ha	/^export type ulong = u64;$/;"	t
ulong	$HARELIB/types/c/arch+riscv64.ha	/^export type ulong = u64;$/;"	t
ulong	$HARELIB/types/c/arch+x86_64.ha	/^export type ulong = u64;$/;"	t
ulonglong	$HARELIB/types/c/arch+aarch64.ha	/^export type ulonglong = u64;$/;"	t
ulonglong	$HARELIB/types/c/arch+riscv64.ha	/^export type ulonglong = u64;$/;"	t
ulonglong	$HARELIB/types/c/arch+x86_64.ha	/^export type ulonglong = u64;$/;"	t
umask	$HARELIB/rt/+darwin/syscalls.ha	/^export fn umask(mode: mode_t) mode_t = {$/;"	f
umask	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn umask(mode: mode_t) mode_t = {$/;"	f
umask	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn umask(mode: mode_t) (mode_t | errno) = {$/;"	f
umask	$HARELIB/rt/+linux/syscalls.ha	/^export fn umask(mode: mode_t) (mode_t | errno) = {$/;"	f
umask	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn umask(mode: mode_t) (mode_t | errno) = {$/;"	f
umask	$HARELIB/unix/+darwin/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t): fs::mode;$/;"	f
umask	$HARELIB/unix/+freebsd/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t)!: fs::mode;$/;"	f
umask	$HARELIB/unix/+linux/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode)!: fs::mode;$/;"	f
umask	$HARELIB/unix/+openbsd/umask.ha	/^export fn umask(mode: fs::mode) fs::mode = rt::umask(mode: rt::mode_t)!: fs::mode;$/;"	f
umount2	$HARELIB/rt/+linux/syscalls.ha	/^export fn umount2(target: path, flags: int) (void | errno) = {$/;"	f
uname	$HARELIB/rt/+linux/syscalls.ha	/^export fn uname(uts: *utsname) (void | errno) = {$/;"	f
unarithm_expr	$HARELIB/hare/ast/expr.ha	/^export type unarithm_expr = struct {$/;"	t
unarithm_op	$HARELIB/hare/ast/expr.ha	/^export type unarithm_op = enum {$/;"	t
unblock	$HARELIB/unix/signal/+darwin.ha	/^export fn unblock(signals: sig...) sigset = {$/;"	f
unblock	$HARELIB/unix/signal/+freebsd.ha	/^export fn unblock(signals: sig...) sigset = {$/;"	f
unblock	$HARELIB/unix/signal/+linux.ha	/^export fn unblock(signals: sig...) sigset = {$/;"	f
unblock	$HARELIB/unix/signal/+openbsd.ha	/^export fn unblock(signals: sig...) sigset = {$/;"	f
underread	$HARELIB/io/types.ha	/^export type underread = !size;$/;"	t
unensure	$HARELIB/rt/ensure.ha	/^export fn unensure(s: *slice, membsz: size) void = {$/;"	f
union_type	$HARELIB/hare/ast/type.ha	/^export type union_type = []struct_member;$/;"	t
unit	$HARELIB/hare/unit/unit.ha	/^export type unit = struct {$/;"	t
unit	$HARELIB/time/date/parithm.ha	/^export type unit = enum int {$/;"	t
unit_finish	$HARELIB/hare/unit/unit.ha	/^export fn unit_finish(unit: unit) void = {$/;"	f
unitdiff	$HARELIB/time/date/parithm.ha	/^export fn unitdiff(a: date, b: date, u: unit) i64 = {$/;"	f
unix	$HARELIB/time/conv.ha	/^export fn unix(i: instant) i64 = i.sec;$/;"	f
unknown_error	$HARELIB/net/dns/error.ha	/^export type unknown_error = !u8;$/;"	t
unknown_option	$HARELIB/getopt/getopts.ha	/^export type unknown_option = rune;$/;"	t
unknown_rdata	$HARELIB/net/dns/types.ha	/^export type unknown_rdata = []u8;$/;"	t
unknown_service	$HARELIB/net/dial/registry.ha	/^export type unknown_service = !void;$/;"	t
unknownproto	$HARELIB/net/errors.ha	/^export type unknownproto = !void;$/;"	t
unlex	$HARELIB/hare/lex/lex.ha	/^export fn unlex(lex: *lexer, tok: token) void = {$/;"	f
unlink	$HARELIB/rt/+darwin/syscalls.ha	/^export fn unlink(path: path) (void | errno) = {$/;"	f
unlink	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn unlink(path: path) (void | errno) = {$/;"	f
unlink	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn unlink(path: path) (void | errno) = {$/;"	f
unlink	$HARELIB/rt/+linux/syscalls.ha	/^export fn unlink(path: path) (void | errno) = {$/;"	f
unlinkat	$HARELIB/rt/+darwin/syscalls.ha	/^export fn unlinkat(dirfd: int, path: path, flags: int) (void | errno) = {$/;"	f
unlinkat	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn unlinkat(dirfd: int, path: path, flags: int) (void | errno) = {$/;"	f
unlinkat	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn unlinkat(dirfd: int, path: path, flags: int) (void | errno) = {$/;"	f
unlinkat	$HARELIB/rt/+linux/syscalls.ha	/^export fn unlinkat(dirfd: int, path: path, flags: int) (void | errno) = {$/;"	f
unlinkat	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn unlinkat(dirfd: int, path: path, flags: int) (void | errno) = {$/;"	f
unlockpt	$HARELIB/rt/+darwin/syscalls.ha	/^export fn unlockpt(fd: int) (void | errno) = {$/;"	f
unlockpt	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn unlockpt(fd: int) (void | errno) = {$/;"	f
unparse_domain	$HARELIB/net/dns/strdomain.ha	/^export fn unparse_domain(in: []str) str = strings::join(".", in...);$/;"	f
unread	$HARELIB/bufio/stream.ha	/^export fn unread(s: io::handle, buf: []u8) void = {$/;"	f
unreadrune	$HARELIB/bufio/stream.ha	/^export fn unreadrune(s: io::handle, rn: rune) void = {$/;"	f
unset	$HARELIB/linux/timerfd/+linux/timerfd.ha	/^export fn unset($/;"	f
unsetenv	$HARELIB/os/environ.ha	/^export fn unsetenv(name: const str) (void | errors::invalid) = {$/;"	f
unsetenv	$HARELIB/os/exec/cmd.ha	/^export fn unsetenv(cmd: *command, key: str) (void | errors::invalid) = {$/;"	f
unsigned	$HARELIB/strconv/numeric.ha	/^export fn unsignedtosb(n: types::unsigned, b: base) const str = {$/;"	f
unsigned	$HARELIB/types/classes.ha	/^export type unsigned = (u8 | u16 | u32 | u64 | uint | size);$/;"	t
unsignedtos	$HARELIB/strconv/numeric.ha	/^export fn unsignedtos(n: types::unsigned) const str = unsignedtosb(n, base::DEC);$/;"	f
unsignedtosb	$HARELIB/strconv/numeric.ha	/^export fn unsignedtosb(n: types::unsigned, b: base) const str = {$/;"	f
unsupported	$HARELIB/errors/common.ha	/^export type unsupported = !void;$/;"	t
unterminatedstr	$HARELIB/types/c/strings.ha	/^export fn unterminatedstr(s: const str) *const char = {$/;"	f
unveil	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn unveil($/;"	f
unveil_lock	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn unveil_lock() (void | errno) = {$/;"	f
unwrap_err	$HARELIB/encoding/asn1/errors.ha	/^export fn unwrap_err(e: io::error) error = {$/;"	f
update	$HARELIB/linux/keyctl/+linux/keyctl.ha	/^export fn update(id: serial, payload: []u8) (void | error) = {$/;"	f
update	$HARELIB/unix/signal/+linux.ha	/^export fn update(fd: io::file, signals: sig...) (void | errors::error) = {$/;"	f
uptrtos	$HARELIB/strconv/utos.ha	/^export fn uptrtos(uptr: uintptr) const str = u64tos(uptr: u64);$/;"	f
uptrtosb	$HARELIB/strconv/utos.ha	/^export fn uptrtosb(uptr: uintptr, b: base) const str = u64tosb(uptr: u64, b);$/;"	f
uri	$HARELIB/net/uri/uri.ha	/^export type uri = struct {$/;"	t
uri	$HARELIB/uuid/uuid.ha	/^export fn uri(out: io::handle, in: uuid) (size | io::error) = {$/;"	f
user_regs	$HARELIB/rt/+linux/+riscv64.ha	/^export type user_regs = struct {$/;"	t
ushort	$HARELIB/types/c/arch+aarch64.ha	/^export type ushort = u16;$/;"	t
ushort	$HARELIB/types/c/arch+riscv64.ha	/^export type ushort = u16;$/;"	t
ushort	$HARELIB/types/c/arch+x86_64.ha	/^export type ushort = u16;$/;"	t
utag	$HARELIB/encoding/asn1/types.ha	/^export type utag = enum u8 {$/;"	t
utf8stream	$HARELIB/encoding/asn1/strings.ha	/^export type utf8stream = struct {$/;"	t
utf8sz	$HARELIB/encoding/utf8/rune.ha	/^export fn utf8sz(c: u8) (size | invalid) = {$/;"	f
utos	$HARELIB/strconv/utos.ha	/^export fn utos(u: uint) const str = u64tos(u);$/;"	f
utosb	$HARELIB/strconv/utos.ha	/^export fn utosb(u: uint, b: base) const str = u64tosb(u, b);$/;"	f
utsname	$HARELIB/rt/+linux/types.ha	/^export type utsname = struct {$/;"	t
uuid	$HARELIB/uuid/uuid.ha	/^export type uuid = [16]u8;$/;"	t
vaarg_expr	$HARELIB/hare/ast/expr.ha	/^export type vaarg_expr = *expr;$/;"	t
vaend_expr	$HARELIB/hare/ast/expr.ha	/^export type vaend_expr = *expr;$/;"	t
valid	$HARELIB/ascii/valid.ha	/^export fn valid(c: rune) bool = c: u32 <= 0o177;$/;"	f
validate	$HARELIB/encoding/utf8/decode.ha	/^export fn validate(src: []u8) (void | invalid) = {$/;"	f
validate_point	$HARELIB/crypto/ec/validate.ha	/^export fn validate_point(c: *curve, p: []u8) (void | invalid) = {$/;"	f
validate_pointformat	$HARELIB/crypto/ec/validate.ha	/^export fn validate_pointformat(c: *curve, p: []u8) (void | invalid) = {$/;"	f
validate_scalar	$HARELIB/crypto/ec/validate.ha	/^export fn validate_scalar(c: *curve, n: []u8) (void | invalid) = {$/;"	f
validstr	$HARELIB/ascii/valid.ha	/^export fn validstr(s: str) bool = {$/;"	f
value	$HARELIB/hare/ast/expr.ha	/^export type value = (bool | _null | str | rune | void);$/;"	t
value	$HARELIB/hare/lex/token.ha	/^export type value = (str | rune | u64 | f64 | void);$/;"	t
variable	$HARELIB/strings/template/template.ha	/^export type variable = str;$/;"	t
variadic_expr	$HARELIB/hare/ast/expr.ha	/^export type variadic_expr = (vastart_expr | vaarg_expr | vaend_expr);$/;"	t
variadism	$HARELIB/hare/ast/type.ha	/^export type variadism = enum {$/;"	t
variadism	$HARELIB/hare/types/types.ha	/^export type variadism = enum {$/;"	t
variant	$HARELIB/crypto/sha512/sha512.ha	/^export type variant = enum {$/;"	t
vastart_expr	$HARELIB/hare/ast/expr.ha	/^export type vastart_expr = void;$/;"	t
vector	$HARELIB/io/+darwin/vector.ha	/^export type vector = rt::iovec;$/;"	t
vector	$HARELIB/io/+freebsd/vector.ha	/^export type vector = rt::iovec;$/;"	t
vector	$HARELIB/io/+linux/vector.ha	/^export type vector = rt::iovec;$/;"	t
vector	$HARELIB/io/+openbsd/vector.ha	/^export type vector = rt::iovec;$/;"	t
ver_def	$HARELIB/format/elf/types.ha	/^export type ver_def = enum u16 {$/;"	t
ver_flg	$HARELIB/format/elf/types.ha	/^export type ver_flg = enum u16 {$/;"	t
ver_ndx	$HARELIB/format/elf/types.ha	/^export type ver_ndx = enum u16 {$/;"	t
verdaux64	$HARELIB/format/elf/types.ha	/^export type verdaux64 = struct {$/;"	t
verdef64	$HARELIB/format/elf/types.ha	/^export type verdef64 = struct {$/;"	t
verify	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn verify(s: *stream, tag: []u8) (void | errors::invalid) = {$/;"	f
verify	$HARELIB/crypto/ed25519/ed25519.ha	/^export fn verify(pub: []u8, msg: []u8, sig: []u8) bool = {$/;"	f
version	$HARELIB/os/+darwin/platform_environ.ha	/^export fn version() const str = {$/;"	f
version	$HARELIB/os/+freebsd/platform_environ.ha	/^export fn version() const str = {$/;"	f
version	$HARELIB/os/+linux/platform_environ.ha	/^export fn version() const str = {$/;"	f
version	$HARELIB/os/+openbsd/platform_environ.ha	/^export fn version() const str = {$/;"	f
virtual	$HARELIB/time/date/virtual.ha	/^export type virtual = struct {$/;"	t
vtable	$HARELIB/io/stream.ha	/^export type vtable = struct {$/;"	t
wait	$HARELIB/os/exec/+darwin/process.ha	/^export fn wait(proc: *process) (status | error) = {$/;"	f
wait	$HARELIB/os/exec/+freebsd/process.ha	/^export fn wait(proc: *process) (status | error) = {$/;"	f
wait	$HARELIB/os/exec/+linux/process.ha	/^export fn wait(proc: *process) (status | error) = {$/;"	f
wait	$HARELIB/os/exec/+openbsd/process.ha	/^export fn wait(proc: *process) (status | error) = {$/;"	f
wait4	$HARELIB/rt/+darwin/syscalls.ha	/^export fn wait4($/;"	f
wait4	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn wait4($/;"	f
wait4	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn wait4($/;"	f
wait4	$HARELIB/rt/+linux/syscalls.ha	/^export fn wait4($/;"	f
wait4	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn wait4($/;"	f
waitall	$HARELIB/os/exec/+darwin/process.ha	/^export fn waitall() (uint | error | !(process, exit_status)) = {$/;"	f
waitall	$HARELIB/os/exec/+freebsd/process.ha	/^export fn waitall() (uint | error | !(process, exit_status)) = {$/;"	f
waitall	$HARELIB/os/exec/+linux/process.ha	/^export fn waitall() (uint | error | !(process, exit_status)) = {$/;"	f
waitall	$HARELIB/os/exec/+openbsd/process.ha	/^export fn waitall() (uint | error | !(process, exit_status)) = {$/;"	f
waitany	$HARELIB/os/exec/+darwin/process.ha	/^export fn waitany() ((process, status) | error) = {$/;"	f
waitany	$HARELIB/os/exec/+freebsd/process.ha	/^export fn waitany() ((process, status) | error) = {$/;"	f
waitany	$HARELIB/os/exec/+linux/process.ha	/^export fn waitany() ((process, status) | error) = {$/;"	f
waitany	$HARELIB/os/exec/+openbsd/process.ha	/^export fn waitany() ((process, status) | error) = {$/;"	f
walk	$HARELIB/debug/+aarch64/walk.ha	/^export fn walk() stackframe = *getfp();$/;"	f
walk	$HARELIB/debug/+riscv64/walk.ha	/^export fn walk() stackframe = *getfp();$/;"	f
walk	$HARELIB/debug/+x86_64/walk.ha	/^export fn walk() stackframe = *getfp();$/;"	f
wchar	$HARELIB/types/c/types.ha	/^export type wchar = i32;$/;"	t
wcoredump	$HARELIB/rt/+linux/types.ha	/^export fn wcoredump(s: int) int = s & 0x80;$/;"	f
week	$HARELIB/time/date/observe.ha	/^export fn week(d: *date) int = _week(d);$/;"	f
weekday	$HARELIB/time/date/observe.ha	/^export fn weekday(d: *date) int = _weekday(d);$/;"	f
wexitstatus	$HARELIB/rt/+darwin/syscalls.ha	/^export fn wexitstatus(status: int) int = (status & 0xff00) >> 8;$/;"	f
wexitstatus	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn wexitstatus(status: int) int = (status & 0xff00) >> 8;$/;"	f
wexitstatus	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn wexitstatus(status: int) int = (status & 0xff00) >> 8;$/;"	f
wexitstatus	$HARELIB/rt/+linux/types.ha	/^export fn wexitstatus(s: int) int = (s & 0xff00) >> 8;$/;"	f
wexitstatus	$HARELIB/rt/+openbsd/types.ha	/^export fn wexitstatus(status: int) int = (status >> 8) & 0xff;$/;"	f
whence	$HARELIB/io/types.ha	/^export type whence = enum {$/;"	t
wifcontinued	$HARELIB/rt/+linux/types.ha	/^export fn wifcontinued(s: int) bool = s == 0xFFFF;$/;"	f
wifexited	$HARELIB/rt/+darwin/syscalls.ha	/^export fn wifexited(status: int) bool = wtermsig(status) == 0;$/;"	f
wifexited	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn wifexited(status: int) bool = wtermsig(status) == 0;$/;"	f
wifexited	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn wifexited(status: int) bool = wtermsig(status) == 0;$/;"	f
wifexited	$HARELIB/rt/+linux/types.ha	/^export fn wifexited(s: int) bool = wtermsig(s) <= 0;$/;"	f
wifexited	$HARELIB/rt/+openbsd/types.ha	/^export fn wifexited(status: int) bool = wtermsig(status) == 0;$/;"	f
wifsignaled	$HARELIB/rt/+darwin/syscalls.ha	/^export fn wifsignaled(status: int) bool =$/;"	f
wifsignaled	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn wifsignaled(status: int) bool =$/;"	f
wifsignaled	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn wifsignaled(status: int) bool =$/;"	f
wifsignaled	$HARELIB/rt/+linux/types.ha	/^export fn wifsignaled(s: int) bool = (s & 0xFFFF) - 1 < 0xFF;$/;"	f
wifsignaled	$HARELIB/rt/+openbsd/types.ha	/^export fn wifsignaled(status: int) bool =$/;"	f
wifstopped	$HARELIB/rt/+linux/types.ha	/^export fn wifstopped(s: int) bool = (((s & 0xFFFF) * 0x10001) >> 8) > 0x7f00;$/;"	f
winsize	$HARELIB/rt/+darwin/types.ha	/^export type winsize = struct {$/;"	t
winsize	$HARELIB/rt/+freebsd/types.ha	/^export type winsize = struct {$/;"	t
winsize	$HARELIB/rt/+linux/types.ha	/^export type winsize = struct {$/;"	t
winsize	$HARELIB/rt/+openbsd/types.ha	/^export type winsize = struct {$/;"	t
winsize	$HARELIB/unix/tty/+darwin/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
winsize	$HARELIB/unix/tty/+freebsd/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
winsize	$HARELIB/unix/tty/+linux/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
winsize	$HARELIB/unix/tty/+openbsd/winsize.ha	/^export fn winsize(fd: io::file) (ttysize | error) = {$/;"	f
wint	$HARELIB/types/c/types.ha	/^export type wint = u32;$/;"	t
word	$HARELIB/crypto/bigint/types.ha	/^export type word = u32;$/;"	t
wordexp	$HARELIB/wordexp/wordexp.ha	/^export fn wordexp(s: str, flags: flag) ([]str | error) = {$/;"	f
write	$HARELIB/crypto/mac/mac.ha	/^export fn write(m: *mac, buf: const []u8) size = io::write(m, buf) as size;$/;"	f
write	$HARELIB/hash/hash.ha	/^export fn write(h: *hash, buf: const []u8) size =$/;"	f
write	$HARELIB/io/handle.ha	/^export fn write(h: handle, buf: const []u8) (size | error) = {$/;"	f
write	$HARELIB/rt/+darwin/syscalls.ha	/^export fn write(fd: int, buf: *const opaque, count: size) (size | errno) = {$/;"	f
write	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn write(fd: int, buf: *const opaque, count: size) (size | errno) = {$/;"	f
write	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn write(fd: int, buf: *const opaque, count: size) (size | errno) = {$/;"	f
write	$HARELIB/rt/+linux/syscalls.ha	/^export fn write(fd: int, buf: *const opaque, count: size) (size | errno) = {$/;"	f
write	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn write(fd: int, buf: *const opaque, count: size) (size | errno) = {$/;"	f
write_bool	$HARELIB/encoding/asn1/encoder.ha	/^export fn write_bool(e: *encoder, b: bool) (void | overflow) = {$/;"	f
write_int	$HARELIB/encoding/asn1/encoder.ha	/^export fn write_int(e: *encoder, n: []u8) (void | overflow) = {$/;"	f
write_null	$HARELIB/encoding/asn1/encoder.ha	/^export fn write_null(e: *encoder) (void | overflow) = {$/;"	f
write_oid	$HARELIB/encoding/asn1/oid.ha	/^export fn write_oid(e: *encoder, db: *oiddb, oid: oid) (void | overflow) = {$/;"	f
write_uint	$HARELIB/encoding/asn1/encoder.ha	/^export fn write_uint(e: *encoder, n: []u8) (void | overflow) = {$/;"	f
write_utf8str	$HARELIB/encoding/asn1/encoder.ha	/^export fn write_utf8str(e: *encoder, s: str) (void | overflow) =$/;"	f
writeall	$HARELIB/io/util.ha	/^export fn writeall(out: handle, buf: const []u8) (size | error) = {$/;"	f
writer	$HARELIB/io/types.ha	/^export type writer = fn(s: *stream, buf: const []u8) (size | error);$/;"	t
writev	$HARELIB/io/+darwin/vector.ha	/^export fn writev(fd: file, vectors: vector...) (size | error) = {$/;"	f
writev	$HARELIB/io/+freebsd/vector.ha	/^export fn writev(fd: file, vectors: vector...) (size | error) = {$/;"	f
writev	$HARELIB/io/+linux/vector.ha	/^export fn writev(fd: file, vectors: vector...) (size | error) = {$/;"	f
writev	$HARELIB/io/+openbsd/vector.ha	/^export fn writev(fd: file, vectors: vector...) (size | error) = {$/;"	f
writev	$HARELIB/rt/+darwin/syscalls.ha	/^export fn writev(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
writev	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn writev(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
writev	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn writev(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
writev	$HARELIB/rt/+linux/syscalls.ha	/^export fn writev(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
writev	$HARELIB/rt/+openbsd/syscalls.ha	/^export fn writev(fd: int, iov: const *[*]iovec, iovcnt: int) (size | errno) = {$/;"	f
wrongtype	$HARELIB/fs/types.ha	/^export type wrongtype = !void;$/;"	t
wstopsig	$HARELIB/rt/+linux/types.ha	/^export fn wstopsig(s: int) int = wexitstatus(s);$/;"	f
wtermsig	$HARELIB/rt/+darwin/syscalls.ha	/^export fn wtermsig(status: int) int = status & 0x7f;$/;"	f
wtermsig	$HARELIB/rt/+darwin/syscalls.ha.alt	/^export fn wtermsig(status: int) int = status & 0x7f;$/;"	f
wtermsig	$HARELIB/rt/+freebsd/syscalls.ha	/^export fn wtermsig(status: int) int = status & 0x7f;$/;"	f
wtermsig	$HARELIB/rt/+linux/types.ha	/^export fn wtermsig(s: int) int = s & 0x7f;$/;"	f
wtermsig	$HARELIB/rt/+openbsd/types.ha	/^export fn wtermsig(status: int) int = status & 0o177;$/;"	f
x25519	$HARELIB/crypto/curve25519/curve25519.ha	/^export fn x25519($/;"	f
xchacha20_init	$HARELIB/crypto/chacha/chacha20.ha	/^export fn xchacha20_init($/;"	f
xinit	$HARELIB/crypto/chachapoly/chachapoly.ha	/^export fn xinit($/;"	f
xor	$HARELIB/crypto/math/bits.ha	/^export fn xor(dest: []u8, a: []u8, b: []u8) void = {$/;"	f
xorstream	$HARELIB/crypto/cipher/stream.ha	/^export type xorstream = struct {$/;"	t
xsalsa20_init	$HARELIB/crypto/salsa/salsa20.ha	/^export fn xsalsa20_init($/;"	f
xts	$HARELIB/crypto/aes/xts/xts.ha	/^export fn xts() block = block {$/;"	f
year	$HARELIB/time/date/observe.ha	/^export fn year(d: *date) int = _year(d);$/;"	f
yearday	$HARELIB/time/date/observe.ha	/^export fn yearday(d: *date) int = _yearday(d);$/;"	f
yield_expr	$HARELIB/hare/ast/expr.ha	/^export type yield_expr = struct {$/;"	t
zero	$HARELIB/bytes/zero.ha	/^export fn zero(buf: []u8) void = {$/;"	f
zero	$HARELIB/crypto/bigint/util.ha	/^export fn zero(x: []word, ebitlen: word) void = {$/;"	f
zone	$HARELIB/time/chrono/timezone.ha	/^export type zone = struct {$/;"	t
zone_finish	$HARELIB/time/chrono/timezone.ha	/^export fn zone_finish(z: *zone) void = {$/;"	f
ztos	$HARELIB/strconv/utos.ha	/^export fn ztos(z: size) const str = u64tos(z);$/;"	f
ztosb	$HARELIB/strconv/utos.ha	/^export fn ztosb(u: size, b: base) const str = u64tosb(u, b);$/;"	f
